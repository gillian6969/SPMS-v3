{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { ref, onMounted, computed, watch, onUnmounted, nextTick } from 'vue';\nimport { useStore } from 'vuex';\nimport Chart from 'chart.js/auto';\nimport axios from 'axios';\nimport moment from 'moment';\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: 'http://localhost:8000/api'\n});\nexport default {\n  name: 'Dashboard',\n  setup() {\n    const store = useStore();\n    const performanceChart = ref(null);\n    const assessmentTypeChart = ref(null);\n    const performanceTrendChart = ref(null);\n    const assessmentTypePerformanceChart = ref(null);\n    const selectedYear = ref('');\n    const selectedSection = ref('');\n    const selectedStartDate = ref('');\n    const selectedEndDate = ref('');\n    const dashboardContainer = ref(null);\n    const isLoading = ref(false);\n    const lastUpdate = ref(null);\n    const autoRefreshInterval = ref(null);\n    const sections = ref([]);\n    const subjects = ref([]);\n    const availableYears = ref([]);\n    const today = computed(() => moment().format('YYYY-MM-DD'));\n\n    // Computed properties\n    const isCITHead = computed(() => store.getters.isCITHead);\n    const token = computed(() => store.state.auth.token);\n\n    // Get user name\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'User' : 'User';\n    });\n\n    // Check if filters are active\n    const hasActiveFilters = computed(() => {\n      return Boolean(selectedYear.value || selectedSection.value);\n    });\n\n    // Set auth token for all requests\n    watch(token, newToken => {\n      if (newToken) {\n        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      }\n    }, {\n      immediate: true\n    });\n\n    // Dashboard stats\n    const totalStudents = ref(0);\n    const totalTeachers = ref(0);\n    const averageAttendance = ref(0);\n    const averageScore = ref(0);\n    const activeSections = ref(0);\n    const data = ref(null);\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      if (data.value && data.value.attendanceDistribution) {\n        return data.value.attendanceDistribution.some(val => val > 0);\n      }\n      return false;\n    });\n    const hasScoreData = computed(() => {\n      return data.value?.averageScore > 0;\n    });\n    const hasPerformanceData = computed(() => {\n      // Check if we have any assessment or performance data\n      if (data.value) {\n        // Check for averageScore > 0\n        if (typeof data.value.averageScore === 'number' && data.value.averageScore > 0) {\n          return true;\n        }\n\n        // Check for performance trends\n        if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    });\n    const hasAssessmentData = computed(() => {\n      if (data.value) {\n        // Check directly in assessmentTypes\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n\n        // Fallback to assessmentTypeDistribution\n        if (data.value.assessmentTypeDistribution) {\n          return true;\n        }\n      }\n      return false;\n    });\n    const hasSectionData = computed(() => {\n      return data.value?.sections?.length > 0;\n    });\n\n    // Fetch available years and sections directly from database records\n    const fetchAvailableFilters = async () => {\n      try {\n        isLoading.value = true;\n\n        // Get all student records to extract years and sections\n        const response = await api.get('/students', {\n          headers: {\n            'Authorization': `Bearer ${token.value}`\n          }\n        });\n        if (response.data && Array.isArray(response.data)) {\n          // Extract unique years and sections from student records\n          const students = response.data;\n\n          // Get unique years with data\n          const years = [...new Set(students.map(student => student.year))].filter(Boolean);\n          availableYears.value = years.length > 0 ? years.sort() : ['1st', '2nd', '3rd', '4th'];\n\n          // Get unique sections based on selectedYear\n          await updateSectionsForSelectedYear();\n          console.log('Fetched available filters:', {\n            years: availableYears.value,\n            sections: sections.value\n          });\n        }\n        isLoading.value = false;\n      } catch (error) {\n        console.error('Error fetching available filters:', error);\n        // Keep default years if API fails\n        availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        isLoading.value = false;\n      }\n    };\n\n    // New function to update sections based on selected year\n    const updateSectionsForSelectedYear = async () => {\n      try {\n        console.log('Updating sections for year:', selectedYear.value || 'All Years');\n        sections.value = []; // Clear existing sections first\n\n        const params = {};\n        if (selectedYear.value) {\n          params.year = selectedYear.value;\n        }\n\n        // Get students filtered by year if selected\n        const response = await api.get('/students', {\n          params,\n          headers: {\n            'Authorization': `Bearer ${token.value}`\n          }\n        });\n        if (response.data && Array.isArray(response.data)) {\n          const students = response.data;\n\n          // Get unique sections matching the selected year\n          let uniqueSections = [];\n          if (selectedYear.value) {\n            // Filter students by the selected year before extracting sections\n            uniqueSections = [...new Set(students.filter(student => student.year === selectedYear.value).map(student => student.section))].filter(Boolean);\n          } else {\n            // If no year selected, get all unique sections\n            uniqueSections = [...new Set(students.map(student => student.section))].filter(Boolean);\n          }\n          console.log(`Found ${uniqueSections.length} sections for ${selectedYear.value || 'all years'}:`, uniqueSections);\n\n          // Map sections to include teacher info if available\n          sections.value = uniqueSections.map(sectionName => ({\n            id: sectionName,\n            name: sectionName,\n            teacherName: '' // We could fetch teacher info in the future\n          }));\n        } else {\n          console.warn('No student data received when updating sections');\n          sections.value = [];\n        }\n      } catch (error) {\n        console.error('Error updating sections for year:', error);\n        sections.value = [];\n      }\n    };\n\n    // Get attendance data for the charts\n    const fetchAttendanceData = async () => {\n      try {\n        console.log('Fetching attendance with filters:', {\n          year: selectedYear.value || 'All Years',\n          section: selectedSection.value || 'All Sections'\n        });\n\n        // Create an array to store all attendance records\n        let allAttendanceRecords = [];\n\n        // Try a direct approach to the dashboard stats endpoint first\n        try {\n          console.log('Trying dashboard stats endpoint directly');\n          const statsParams = {\n            year: selectedYear.value,\n            section: selectedSection.value,\n            startDate: selectedStartDate.value || moment().subtract(30, 'days').format('YYYY-MM-DD'),\n            endDate: selectedEndDate.value || moment().format('YYYY-MM-DD')\n          };\n          const statsResponse = await api.get('/dashboard/stats', {\n            params: statsParams\n          });\n          if (statsResponse.data && statsResponse.data.attendanceDistribution && statsResponse.data.attendanceDistribution.some(val => val > 0)) {\n            console.log('Got attendance from dashboard stats:', statsResponse.data.attendanceDistribution);\n            return statsResponse.data.attendanceDistribution;\n          }\n        } catch (error) {\n          console.log('Dashboard stats did not include attendance data');\n        }\n\n        // Second approach: Try getting attendance from individual dates but with proper year/section filtering\n        try {\n          console.log('Trying to get attendance from recent dates with proper filtering');\n          // Query recent dates (last 7 days)\n          const datePromises = [];\n          const dates = [];\n\n          // Generate 7 recent dates\n          for (let i = 0; i < 7; i++) {\n            dates.push(moment().subtract(i, 'days').format('YYYY-MM-DD'));\n          }\n          if (selectedYear.value && selectedSection.value) {\n            // If both year and section are selected, query directly\n            for (const date of dates) {\n              datePromises.push(api.get(`/attendance/date/${date}`, {\n                params: {\n                  year: selectedYear.value,\n                  section: selectedSection.value\n                }\n              }));\n            }\n          } else if (selectedYear.value) {\n            // If only year is selected, get all sections for that year and query each one\n            const response = await api.get('/students', {\n              params: {\n                year: selectedYear.value\n              }\n            });\n            let sections = [];\n            if (response.data && Array.isArray(response.data)) {\n              sections = [...new Set(response.data.filter(student => student.year === selectedYear.value).map(student => student.section))].filter(Boolean);\n            }\n\n            // If no sections found, query with just the year\n            if (sections.length === 0) {\n              for (const date of dates) {\n                datePromises.push(api.get(`/attendance/date/${date}`, {\n                  params: {\n                    year: selectedYear.value\n                  }\n                }));\n              }\n            } else {\n              // Query each section for each date\n              for (const date of dates) {\n                for (const section of sections) {\n                  datePromises.push(api.get(`/attendance/date/${date}`, {\n                    params: {\n                      year: selectedYear.value,\n                      section\n                    }\n                  }));\n                }\n              }\n            }\n          } else {\n            // If no year selected, get attendance for all years and sections\n            // First get all academic years\n            const years = ['1st', '2nd', '3rd', '4th'];\n\n            // Query a few dates for each year\n            for (const date of dates) {\n              for (const year of years) {\n                datePromises.push(api.get(`/attendance/date/${date}`, {\n                  params: {\n                    year\n                  }\n                }));\n              }\n            }\n          }\n\n          // Execute all date queries\n          const dateResults = await Promise.allSettled(datePromises);\n\n          // Process successful responses\n          dateResults.forEach(result => {\n            if (result.status === 'fulfilled' && result.value?.data && Array.isArray(result.value.data)) {\n              // Filter records by year if needed\n              const records = result.value.data;\n              if (selectedYear.value) {\n                const filteredRecords = records.filter(record => {\n                  // Check if the record matches our year filter\n                  return record.year === selectedYear.value || record.students_data && record.students_data[0]?.year === selectedYear.value;\n                });\n                allAttendanceRecords = [...allAttendanceRecords, ...filteredRecords];\n              } else {\n                allAttendanceRecords = [...allAttendanceRecords, ...records];\n              }\n            }\n          });\n          console.log(`Collected ${allAttendanceRecords.length} attendance records from recent dates`);\n        } catch (error) {\n          console.log('Error fetching attendance by date:', error.message);\n        }\n\n        // Process collected attendance records\n        if (allAttendanceRecords.length > 0) {\n          // Process all attendance records\n          const attendanceCounts = [0, 0, 0]; // [present, late, absent]\n\n          allAttendanceRecords.forEach(record => {\n            if (record.status === 'present') attendanceCounts[0]++;else if (record.status === 'late') attendanceCounts[1]++;else if (record.status === 'absent') attendanceCounts[2]++;\n          });\n          console.log('Final attendance counts for filtered data:', attendanceCounts);\n          return attendanceCounts;\n        }\n\n        // Third approach: Try the backend route for all attendance\n        try {\n          console.log('Attempting to use attendance stats endpoint');\n\n          // Build query based on what's selected\n          const params = {\n            year: selectedYear.value\n          };\n          if (selectedSection.value) {\n            params.section = selectedSection.value;\n          }\n\n          // Try stats endpoint first\n          try {\n            const statsResponse = await api.get('/dashboard/stats', {\n              params\n            });\n            if (statsResponse.data && statsResponse.data.attendanceDistribution && statsResponse.data.attendanceDistribution.some(val => val > 0)) {\n              console.log('Got attendance distribution from stats:', statsResponse.data.attendanceDistribution);\n              return statsResponse.data.attendanceDistribution;\n            }\n          } catch (error) {\n            console.log('Stats endpoint failed:', error.message);\n          }\n        } catch (error) {\n          console.log('Failed to get attendance stats:', error.message);\n        }\n\n        // If all approaches failed, return empty data\n        console.log('No attendance data found, using empty data');\n        return [0, 0, 0];\n      } catch (error) {\n        console.error('Error in attendance data fetching:', error);\n        return [0, 0, 0]; // Return empty data on error\n      }\n    };\n    const fetchDashboardData = async () => {\n      try {\n        isLoading.value = true;\n\n        // Prepare query parameters\n        const params = {\n          year: selectedYear.value,\n          section: selectedSection.value,\n          startDate: selectedStartDate.value,\n          endDate: selectedEndDate.value\n        };\n        console.log('Fetching dashboard data with params:', params);\n\n        // First, fetch attendance data\n        const attendanceDistribution = await fetchAttendanceData();\n        console.log('Attendance distribution for current filters:', attendanceDistribution);\n\n        // Get dashboard stats - ensure we're using the same filters\n        const statsResponse = await api.get('/dashboard/stats', {\n          params\n        });\n        data.value = statsResponse.data || {};\n        console.log('Dashboard stats response:', data.value);\n\n        // Check if we received any meaningful data\n        const hasValidData = data.value.totalStudents > 0 || data.value.totalTeachers > 0 || data.value.activeSections > 0 || data.value.performanceTrends && data.value.performanceTrends.length > 0;\n\n        // If no valid data, it means the filter combination doesn't match any records\n        if (!hasValidData && (selectedYear.value || selectedSection.value)) {\n          console.warn('No data found for the selected filters');\n        }\n\n        // Update basic stats\n        totalStudents.value = data.value.totalStudents || 0;\n        totalTeachers.value = data.value.totalTeachers || 0;\n        activeSections.value = data.value.activeSections || 0;\n\n        // Use our fetched attendance data\n        data.value.attendanceDistribution = attendanceDistribution;\n\n        // Calculate average attendance from distribution\n        const totalAttendance = attendanceDistribution.reduce((a, b) => a + b, 0);\n        if (totalAttendance > 0) {\n          // Calculate percentage of present and late (not absent)\n          const presentAttendance = attendanceDistribution[0] + attendanceDistribution[1];\n          averageAttendance.value = Math.round(presentAttendance / totalAttendance * 100);\n        } else {\n          averageAttendance.value = 0;\n        }\n\n        // Process assessment data for charts\n        await fetchAssessmentData();\n\n        // Calculate averageScore from assessment data instead of using stats\n        if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n          let totalScore = 0;\n          let totalCount = 0;\n          data.value.assessmentTypes.forEach(type => {\n            if (type.averageScore > 0 && type.count > 0) {\n              totalScore += type.averageScore * type.count;\n              totalCount += type.count;\n            }\n          });\n          if (totalCount > 0) {\n            averageScore.value = Math.round(totalScore / totalCount);\n            data.value.averageScore = averageScore.value;\n          } else {\n            averageScore.value = 0;\n            data.value.averageScore = 0;\n          }\n          console.log(`Calculated average score: ${averageScore.value}% from ${totalCount} assessments`);\n        } else {\n          averageScore.value = 0;\n          data.value.averageScore = 0;\n        }\n\n        // Update charts with new data\n        updateCharts(data.value);\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Failed to fetch dashboard data:', error);\n        if (error.response) {\n          console.error('Error response:', error.response.data);\n        }\n\n        // Initialize with empty data if main stats request fails\n        data.value = {\n          totalStudents: 0,\n          totalTeachers: 0,\n          activeSections: 0,\n          attendanceDistribution: [0, 0, 0],\n          averageAttendance: 0,\n          assessmentTypes: [],\n          performanceTrends: [],\n          averageScore: 0,\n          sections: []\n        };\n        totalStudents.value = 0;\n        totalTeachers.value = 0;\n        activeSections.value = 0;\n        averageAttendance.value = 0;\n        averageScore.value = 0;\n\n        // Update charts with empty data\n        updateCharts(data.value);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    // Fetch assessment data directly\n    const fetchAssessmentData = async () => {\n      try {\n        // Set date range for better data filtering\n        const assessmentParams = {\n          year: selectedYear.value,\n          section: selectedSection.value,\n          startDate: selectedStartDate.value || moment().subtract(90, 'days').format('YYYY-MM-DD'),\n          endDate: selectedEndDate.value || moment().format('YYYY-MM-DD')\n        };\n        console.log('Fetching assessment data with params:', assessmentParams);\n\n        // Directly fetch assessment data with filters\n        const assessmentResponse = await api.get('/assessments', {\n          params: assessmentParams\n        });\n        console.log('Fetched assessment data count:', assessmentResponse.data?.length || 0);\n        if (assessmentResponse.data && Array.isArray(assessmentResponse.data)) {\n          let assessments = assessmentResponse.data;\n\n          // If year is selected, double-check that we're only using assessments for that year\n          if (selectedYear.value) {\n            assessments = assessments.filter(assessment => {\n              // Check different fields where year might be stored\n              return assessment.year === selectedYear.value || assessment.students && assessment.students[0]?.year === selectedYear.value;\n            });\n            console.log(`After year filtering: ${assessments.length} assessments match year ${selectedYear.value}`);\n          }\n\n          // Group assessments by type\n          const assessmentTypes = {\n            'Quiz': {\n              count: 0,\n              totalScore: 0,\n              scores: []\n            },\n            'Activity': {\n              count: 0,\n              totalScore: 0,\n              scores: []\n            },\n            'Performance Task': {\n              count: 0,\n              totalScore: 0,\n              scores: []\n            }\n          };\n\n          // Process each assessment\n          assessments.forEach(assessment => {\n            const type = assessment.type || 'Other';\n            if (assessmentTypes[type]) {\n              assessmentTypes[type].count++;\n\n              // Process scores if available\n              if (assessment.scores) {\n                // Handle both array and Map formats\n                let scoreArray = [];\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (assessment.scores instanceof Map) {\n                  scoreArray = Array.from(assessment.scores.values());\n                } else if (typeof assessment.scores === 'object') {\n                  // Handle object format\n                  scoreArray = Object.values(assessment.scores);\n                }\n                scoreArray.forEach(score => {\n                  if (typeof score === 'number') {\n                    const percentage = assessment.maxScore ? score / assessment.maxScore * 100 : score;\n                    assessmentTypes[type].totalScore += percentage;\n                    assessmentTypes[type].scores.push(percentage);\n                  }\n                });\n              }\n            }\n          });\n\n          // Calculate averages and prepare for chart\n          data.value.assessmentTypes = Object.keys(assessmentTypes).map(type => {\n            const typeData = assessmentTypes[type];\n            const averageScore = typeData.scores.length > 0 ? typeData.totalScore / typeData.scores.length : 0;\n            return {\n              type,\n              averageScore: Math.round(averageScore),\n              count: typeData.count,\n              completionRate: typeData.count > 0 ? 100 : 0\n            };\n          });\n\n          // Generate performance trends from assessment data\n          data.value.performanceTrends = assessments.filter(a => a.date) // Only include assessments with dates\n          .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n          .map(assessment => {\n            // Calculate average score for this assessment\n            let averageScore = 0;\n            let scoreArray = [];\n\n            // Handle different score formats\n            if (assessment.scores) {\n              if (Array.isArray(assessment.scores)) {\n                scoreArray = assessment.scores;\n              } else if (assessment.scores instanceof Map) {\n                scoreArray = Array.from(assessment.scores.values());\n              } else if (typeof assessment.scores === 'object') {\n                scoreArray = Object.values(assessment.scores);\n              }\n\n              // Calculate average from valid scores\n              const validScores = scoreArray.filter(score => typeof score === 'number');\n              if (validScores.length > 0) {\n                const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                averageScore = assessment.maxScore ? totalScore / validScores.length / assessment.maxScore * 100 : totalScore / validScores.length;\n              }\n            }\n            return {\n              date: assessment.date,\n              title: assessment.name || assessment.type,\n              averageScore: Math.round(averageScore),\n              type: assessment.type\n            };\n          });\n          console.log(`Performance trends data for ${selectedYear.value || 'all years'}: ${data.value.performanceTrends.length} entries`);\n\n          // Process section data if available\n          // Group assessments by section\n          const sectionPerformance = {};\n\n          // Only process section performance if we actually have data\n          if (assessments.length > 0) {\n            assessments.forEach(assessment => {\n              if (assessment.section) {\n                if (!sectionPerformance[assessment.section]) {\n                  sectionPerformance[assessment.section] = {\n                    totalScore: 0,\n                    scoreCount: 0,\n                    attendanceCount: 0,\n                    attendanceTotal: 0\n                  };\n                }\n\n                // Process scores\n                let scoreArray = [];\n                if (assessment.scores) {\n                  if (Array.isArray(assessment.scores)) {\n                    scoreArray = assessment.scores;\n                  } else if (assessment.scores instanceof Map) {\n                    scoreArray = Array.from(assessment.scores.values());\n                  } else if (typeof assessment.scores === 'object') {\n                    scoreArray = Object.values(assessment.scores);\n                  }\n                  scoreArray.forEach(score => {\n                    if (typeof score === 'number') {\n                      const percentage = assessment.maxScore ? score / assessment.maxScore * 100 : score;\n                      sectionPerformance[assessment.section].totalScore += percentage;\n                      sectionPerformance[assessment.section].scoreCount++;\n                    }\n                  });\n                }\n              }\n            });\n\n            // Prepare section data for chart if we have any\n            if (Object.keys(sectionPerformance).length > 0) {\n              data.value.sections = Object.keys(sectionPerformance).map(sectionName => {\n                const section = sectionPerformance[sectionName];\n                const averageScore = section.scoreCount > 0 ? section.totalScore / section.scoreCount : 0;\n                return {\n                  name: sectionName,\n                  averageScore: Math.round(averageScore),\n                  attendanceRate: 0,\n                  // We don't have this data\n                  performance: Math.round(averageScore) // For backward compatibility\n                };\n              });\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching assessment data:', error);\n        // Set default values\n        data.value.assessmentTypes = [{\n          type: 'Quiz',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Activity',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Performance Task',\n          averageScore: 0,\n          count: 0\n        }];\n        data.value.performanceTrends = [];\n        data.value.sections = [];\n      }\n    };\n    const updateCharts = data => {\n      updatePerformanceChart(data);\n      updateAssessmentTypeChart(data);\n      updatePerformanceTrendChart(data);\n      updateAssessmentTypePerformanceChart(data);\n    };\n\n    // Update initEmptyCharts to properly handle chart destruction\n    const initEmptyCharts = () => {\n      // First destroy any existing charts to prevent \"Canvas is already in use\" errors\n      const charts = [performanceChart.value, assessmentTypeChart.value, performanceTrendChart.value, assessmentTypePerformanceChart.value];\n\n      // Destroy all existing charts first\n      charts.forEach(canvas => {\n        if (canvas) {\n          const ctx = canvas.getContext('2d');\n          if (ctx) {\n            const existingChart = Chart.getChart(ctx);\n            if (existingChart) {\n              existingChart.destroy();\n            }\n          }\n        }\n      });\n\n      // Create empty data structure\n      const emptyData = {\n        totalStudents: 0,\n        totalTeachers: 0,\n        activeSections: 0,\n        averageAttendance: 0,\n        averageScore: 0,\n        attendanceDistribution: [0, 0, 0],\n        assessmentTypes: [{\n          type: 'Quiz',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Activity',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Performance Task',\n          averageScore: 0,\n          count: 0\n        }],\n        performanceTrends: [],\n        sections: []\n      };\n\n      // Update charts with empty data\n      updateCharts(emptyData);\n    };\n\n    // Format date for display\n    const formatDate = date => {\n      if (!date) return '';\n      return moment(date).format('MMMM D, YYYY h:mm A');\n    };\n\n    // Handle year change\n    const handleYearChange = async () => {\n      console.log('Year changed to:', selectedYear.value);\n\n      // Reset the section when year changes\n      selectedSection.value = '';\n\n      // Update sections based on the new year\n      await updateSectionsForSelectedYear();\n\n      // Update dashboard data with new filters\n      await fetchDashboardData();\n    };\n\n    // Handle section change\n    const handleSectionChange = async () => {\n      // Update dashboard data with new filters\n      fetchDashboardData();\n    };\n\n    // Handle filter change\n    const handleFilterChange = () => {\n      fetchDashboardData();\n    };\n\n    // Clear all filters\n    const clearFilters = () => {\n      console.log('Clearing all filters');\n\n      // Reset all filter values\n      selectedYear.value = '';\n      selectedSection.value = '';\n      selectedStartDate.value = '';\n      selectedEndDate.value = '';\n\n      // Reset sections \n      sections.value = [];\n\n      // Refresh the dashboard with no filters\n      fetchAvailableFilters().then(() => {\n        console.log('Available filters refreshed, fetching dashboard data');\n        fetchDashboardData();\n      });\n    };\n\n    // Get filter display text\n    const getFilterDisplay = () => {\n      const filters = [];\n      if (selectedYear.value) filters.push(selectedYear.value);\n      if (selectedSection.value) filters.push(selectedSection.value);\n\n      // Add date range to display if selected\n      if (selectedStartDate.value && selectedEndDate.value) {\n        const formattedStart = moment(selectedStartDate.value).format('MMM D');\n        const formattedEnd = moment(selectedEndDate.value).format('MMM D, YYYY');\n        filters.push(`${formattedStart} - ${formattedEnd}`);\n      } else if (selectedStartDate.value) {\n        filters.push(`From ${moment(selectedStartDate.value).format('MMM D, YYYY')}`);\n      } else if (selectedEndDate.value) {\n        filters.push(`Until ${moment(selectedEndDate.value).format('MMM D, YYYY')}`);\n      }\n      return filters.length > 0 ? filters.join(' - ') : 'Filter View';\n    };\n\n    // Update charts with data\n    const updatePerformanceChart = data => {\n      if (!performanceChart.value) return;\n      const ctx = performanceChart.value.getContext('2d');\n      if (!ctx) return;\n\n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Attendance status distribution data\n      const attendanceLabels = ['Present', 'Late', 'Absent'];\n      let attendanceData = data.attendanceDistribution || [0, 0, 0];\n\n      // Ensure we have at least some data to display\n      const totalAttendanceCount = attendanceData.reduce((a, b) => a + b, 0);\n      if (totalAttendanceCount === 0) {\n        // Use empty distribution if no real data\n        attendanceData = [0, 0, 0];\n      }\n\n      // Log for debugging\n      console.log('Final attendance distribution data:', attendanceData);\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n          labels: attendanceLabels,\n          datasets: [{\n            data: attendanceData,\n            backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],\n            borderWidth: 0,\n            hoverOffset: 4\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          cutout: '70%',\n          plugins: {\n            legend: {\n              position: 'bottom',\n              labels: {\n                usePointStyle: true,\n                padding: 15,\n                font: {\n                  size: 12\n                }\n              }\n            },\n            tooltip: {\n              callbacks: {\n                label: function (context) {\n                  const label = context.label || '';\n                  const value = context.raw || 0;\n                  const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);\n                  const percentage = total > 0 ? Math.round(value / total * 100) : 0;\n                  return `${label}: ${value} (${percentage}%)`;\n                }\n              }\n            }\n          }\n        }\n      });\n    };\n    const updateAssessmentTypeChart = data => {\n      if (!assessmentTypeChart.value) return;\n      const ctx = assessmentTypeChart.value.getContext('2d');\n      if (!ctx) return;\n\n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Assessment types data\n      const assessmentData = data.assessmentTypes || [];\n      const labels = [];\n      const values = [];\n      const colors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#6366f1'];\n      try {\n        // Extract assessment types data\n        if (Array.isArray(assessmentData)) {\n          // If array format\n          assessmentData.forEach((item, index) => {\n            if (item && typeof item === 'object') {\n              labels.push(item.type || `Type ${index + 1}`);\n              values.push(parseFloat(item.averageScore) || 0);\n            }\n          });\n        } else if (typeof assessmentData === 'object' && assessmentData !== null) {\n          // If object format\n          Object.entries(assessmentData).forEach(([type, data], index) => {\n            labels.push(type);\n            values.push(parseFloat(data.averageScore) || 0);\n          });\n        }\n\n        // If no data was extracted, use default types\n        if (labels.length === 0) {\n          labels.push('Quiz', 'Activity', 'Performance Task');\n          values.push(0, 0, 0);\n        }\n      } catch (error) {\n        console.error('Error processing assessment data:', error);\n        // Fallback to default labels and values\n        labels.push('Quiz', 'Activity', 'Performance Task');\n        values.push(0, 0, 0);\n      }\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: labels,\n          datasets: [{\n            label: 'Average Score (%)',\n            data: values,\n            backgroundColor: colors.slice(0, labels.length),\n            borderWidth: 0,\n            borderRadius: 6,\n            maxBarThickness: 50\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: function (context) {\n                  return `Average Score: ${context.raw}%`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              ticks: {\n                callback: function (value) {\n                  return value + '%';\n                }\n              }\n            }\n          }\n        }\n      });\n    };\n    const updatePerformanceTrendChart = data => {\n      if (!performanceTrendChart.value) return;\n      const ctx = performanceTrendChart.value.getContext('2d');\n      if (!ctx) return;\n\n      // Properly destroy any existing chart\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      let trends = [];\n      if (data.performanceTrends && Array.isArray(data.performanceTrends)) {\n        // Filter out trends that have no valid score or date\n        trends = data.performanceTrends.filter(trend => trend.date && (typeof trend.averageScore === 'number' || typeof trend.score === 'number')).map(trend => ({\n          date: new Date(trend.date),\n          value: parseFloat(trend.averageScore || trend.score) || 0,\n          name: trend.title || trend.name || 'Assessment'\n        })).sort((a, b) => a.date - b.date);\n      }\n      console.log(`Performance trend chart data: ${trends.length} valid data points`);\n\n      // Check if we have any valid data points\n      const hasData = trends.length > 0 && trends.some(t => t.value > 0);\n      if (hasData) {\n        // Create new chart after destroying the old one\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: trends.map(trend => moment(trend.date).format('MMM D, YYYY')),\n            datasets: [{\n              label: 'Average Score',\n              data: trends.map(trend => trend.value),\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2,\n              tension: 0.4,\n              fill: true,\n              pointRadius: 4,\n              pointBackgroundColor: 'rgb(59, 130, 246)',\n              pointHoverRadius: 6\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  title: tooltipItems => {\n                    if (!tooltipItems.length || !trends[tooltipItems[0].dataIndex]) return '';\n                    const trend = trends[tooltipItems[0].dataIndex];\n                    return `${moment(trend.date).format('MMM D, YYYY')} - ${trend.name}`;\n                  },\n                  label: context => {\n                    return `Score: ${context.raw.toFixed(1)}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart to show the \"No data available\" message\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'Average Score',\n              data: [],\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n    const updateAssessmentTypePerformanceChart = data => {\n      if (!assessmentTypePerformanceChart.value) return;\n      const ctx = assessmentTypePerformanceChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process the performance trends data by assessment type\n      const trendsByType = {\n        Quiz: [],\n        Activity: [],\n        'Performance Task': []\n      };\n\n      // Process performance trends data\n      let hasValidData = false;\n      if (Array.isArray(data.performanceTrends)) {\n        data.performanceTrends.forEach(trend => {\n          // Only process trends with valid scores and dates\n          if (trend.date && (typeof trend.averageScore === 'number' || typeof trend.score === 'number')) {\n            const type = trend.type || trend.title || 'Other';\n            const score = parseFloat(trend.averageScore || trend.score) || 0;\n\n            // Create the array for this type if it doesn't exist\n            if (!trendsByType[type]) {\n              trendsByType[type] = [];\n            }\n            trendsByType[type].push({\n              date: new Date(trend.date),\n              score: score\n            });\n            if (score > 0) {\n              hasValidData = true;\n            }\n          }\n        });\n      }\n\n      // Sort data points by date for each type\n      Object.keys(trendsByType).forEach(type => {\n        trendsByType[type].sort((a, b) => a.date - b.date);\n      });\n\n      // Get unique dates across all types\n      const allDates = [...new Set(Object.values(trendsByType).flat().map(item => item.date))].sort((a, b) => a - b);\n\n      // Only proceed if we have valid dates\n      if (allDates.length > 0 && hasValidData) {\n        console.log(`Assessment type performance chart: ${allDates.length} dates with data`);\n\n        // Create datasets\n        const datasets = Object.entries(trendsByType).filter(([_, data]) => data.length > 0) // Only include types with data\n        .map(([type, data], index) => {\n          const colors = ['rgb(52, 211, 153)',\n          // Green for Quiz\n          'rgb(59, 130, 246)',\n          // Blue for Activity\n          'rgb(251, 191, 36)' // Yellow for Performance Task\n          ];\n          const color = colors[index % colors.length];\n          return {\n            label: type,\n            data: allDates.map(date => {\n              const point = data.find(d => d.date.getTime() === date.getTime());\n              return point ? point.score : null;\n            }),\n            borderColor: color,\n            backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),\n            fill: true,\n            tension: 0.4,\n            pointRadius: 4,\n            pointHoverRadius: 6,\n            spanGaps: true // This will connect points even if there are null values\n          };\n        });\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: allDates.map(date => moment(date).format('MMM D, YYYY')),\n            datasets\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            interaction: {\n              intersect: false,\n              mode: 'index'\n            },\n            plugins: {\n              legend: {\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  label: context => {\n                    const value = context.raw !== null ? context.raw.toFixed(1) : 'N/A';\n                    return `${context.dataset.label}: ${value}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart if no valid data\n        console.log('No valid assessment type performance data, showing empty chart');\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'No Data',\n              data: [],\n              borderColor: 'rgb(203, 213, 225)',\n              backgroundColor: 'rgba(203, 213, 225, 0.1)'\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    // Update the refreshDashboard function to properly handle chart destruction\n    const refreshDashboard = async () => {\n      try {\n        isLoading.value = true;\n\n        // Destroy existing charts before fetching new data\n        initEmptyCharts();\n\n        // Wait a tick to ensure DOM updates\n        await nextTick();\n\n        // Fetch new data\n        await fetchDashboardData();\n\n        // Update the last refresh time\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Error refreshing dashboard:', error);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    const scrollToSection = sectionId => {\n      const section = document.getElementById(sectionId);\n      if (section) {\n        section.scrollIntoView({\n          behavior: 'smooth'\n        });\n      }\n    };\n\n    // Restore auto-refresh in onMounted function\n    onMounted(async () => {\n      try {\n        // Make sure DOM is rendered before initializing charts\n        await nextTick();\n        console.log('Dashboard mounted, initializing');\n\n        // Initialize with empty data while waiting for API\n        initEmptyCharts();\n\n        // Set up API interceptor to handle 404 errors gracefully\n        api.interceptors.response.use(response => response, error => {\n          if (error.response && error.response.status === 404) {\n            console.warn(`API endpoint not found: ${error.config.url}`);\n          }\n          return Promise.reject(error);\n        });\n\n        // Set auth token for API requests\n        if (store.state.auth.token) {\n          api.defaults.headers.common['Authorization'] = `Bearer ${store.state.auth.token}`;\n        }\n\n        // Fetch available years and sections with data\n        await fetchAvailableFilters();\n\n        // Ensure all available years are set properly\n        if (availableYears.value.length === 0) {\n          availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        }\n\n        // Fetch dashboard data\n        await fetchDashboardData();\n\n        // Set up auto-refresh\n        if (autoRefreshInterval.value) {\n          clearInterval(autoRefreshInterval.value);\n        }\n\n        // Refresh every 5 minutes, but only if tab is visible\n        autoRefreshInterval.value = setInterval(() => {\n          if (document.visibilityState === 'visible') {\n            refreshDashboard();\n          }\n        }, 5 * 60 * 1000); // 5 minutes\n      } catch (error) {\n        console.error('Error initializing dashboard:', error);\n        // Make sure we still have empty charts if data loading fails\n        await nextTick();\n        initEmptyCharts();\n      }\n    });\n\n    // Clean up on component unmount\n    onUnmounted(() => {\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n    });\n\n    // Add watch for date changes\n    watch([selectedStartDate, selectedEndDate], () => {\n      if (selectedStartDate.value && selectedEndDate.value) {\n        // Validate date range\n        const start = moment(selectedStartDate.value);\n        const end = moment(selectedEndDate.value);\n        if (end.isBefore(start)) {\n          selectedEndDate.value = selectedStartDate.value;\n        }\n      }\n    });\n    return {\n      performanceChart,\n      assessmentTypeChart,\n      performanceTrendChart,\n      assessmentTypePerformanceChart,\n      selectedYear,\n      selectedSection,\n      sections,\n      subjects,\n      availableYears,\n      isCITHead,\n      userName,\n      hasActiveFilters,\n      totalStudents,\n      totalTeachers,\n      averageAttendance,\n      averageScore,\n      activeSections,\n      hasAttendanceData,\n      hasScoreData,\n      hasPerformanceData,\n      hasAssessmentData,\n      hasSectionData,\n      dashboardContainer,\n      isLoading,\n      lastUpdate,\n      formatDate,\n      scrollToSection,\n      handleYearChange,\n      handleSectionChange,\n      clearFilters,\n      getFilterDisplay,\n      refreshDashboard,\n      fetchAvailableFilters,\n      selectedStartDate,\n      selectedEndDate,\n      today\n    };\n  }\n};","map":{"version":3,"names":["ref","onMounted","computed","watch","onUnmounted","nextTick","useStore","Chart","axios","moment","api","create","baseURL","name","setup","store","performanceChart","assessmentTypeChart","performanceTrendChart","assessmentTypePerformanceChart","selectedYear","selectedSection","selectedStartDate","selectedEndDate","dashboardContainer","isLoading","lastUpdate","autoRefreshInterval","sections","subjects","availableYears","today","format","isCITHead","getters","token","state","auth","userName","user","firstName","lastName","trim","hasActiveFilters","Boolean","value","newToken","defaults","headers","common","immediate","totalStudents","totalTeachers","averageAttendance","averageScore","activeSections","data","hasAttendanceData","attendanceDistribution","some","val","hasScoreData","hasPerformanceData","Array","isArray","performanceTrends","length","hasAssessmentData","assessmentTypes","Object","values","type","count","assessmentTypeDistribution","hasSectionData","fetchAvailableFilters","response","get","students","years","Set","map","student","year","filter","sort","updateSectionsForSelectedYear","console","log","error","params","uniqueSections","section","sectionName","id","teacherName","warn","fetchAttendanceData","allAttendanceRecords","statsParams","startDate","subtract","endDate","statsResponse","datePromises","dates","i","push","date","dateResults","Promise","allSettled","forEach","result","status","records","filteredRecords","record","students_data","message","attendanceCounts","fetchDashboardData","hasValidData","totalAttendance","reduce","a","b","presentAttendance","Math","round","fetchAssessmentData","totalScore","totalCount","updateCharts","Date","assessmentParams","assessmentResponse","assessments","assessment","scores","scoreArray","Map","from","score","percentage","maxScore","keys","typeData","completionRate","validScores","sum","title","sectionPerformance","scoreCount","attendanceCount","attendanceTotal","attendanceRate","performance","updatePerformanceChart","updateAssessmentTypeChart","updatePerformanceTrendChart","updateAssessmentTypePerformanceChart","initEmptyCharts","charts","canvas","ctx","getContext","existingChart","getChart","destroy","emptyData","formatDate","handleYearChange","handleSectionChange","handleFilterChange","clearFilters","then","getFilterDisplay","filters","formattedStart","formattedEnd","join","attendanceLabels","attendanceData","totalAttendanceCount","labels","datasets","backgroundColor","borderWidth","hoverOffset","options","responsive","maintainAspectRatio","cutout","plugins","legend","position","usePointStyle","padding","font","size","tooltip","callbacks","label","context","raw","total","chart","assessmentData","colors","item","index","parseFloat","entries","slice","borderRadius","maxBarThickness","display","scales","y","beginAtZero","max","ticks","callback","trends","trend","hasData","t","borderColor","tension","fill","pointRadius","pointBackgroundColor","pointHoverRadius","tooltipItems","dataIndex","toFixed","text","x","maxRotation","minRotation","trendsByType","Quiz","Activity","allDates","flat","_","color","point","find","d","getTime","replace","spanGaps","interaction","intersect","mode","dataset","refreshDashboard","scrollToSection","sectionId","document","getElementById","scrollIntoView","behavior","interceptors","use","config","url","reject","clearInterval","setInterval","visibilityState","start","end","isBefore"],"sources":["D:\\au_dev\\client\\src\\views\\Dashboard.vue"],"sourcesContent":["<template>\n  <div class=\"dashboard\" ref=\"dashboardContainer\">\n    <!-- Greeting Section -->\n    <div class=\"greeting-section mb-4\">\n      <h2 class=\"greeting\">Welcome, Dean {{ userName }}</h2>\n      <p class=\"greeting-subtitle\">Computer and Information Technology Department Dashboard</p>\n    </div>\n    \n    <div class=\"d-flex justify-content-between align-items-center mb-4\">\n      <!-- Combined Filter Dropdown -->\n      <div class=\"dropdown\">\n        <button class=\"btn btn-filter dropdown-toggle\" type=\"button\" id=\"filterDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n          <i class=\"fas fa-filter me-2\"></i>\n          {{ getFilterDisplay() }}\n        </button>\n        <div class=\"dropdown-menu filter-menu p-3\" aria-labelledby=\"filterDropdown\">\n          <h6 class=\"dropdown-header\">Filter Options</h6>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Academic Year</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedYear\" @change=\"handleYearChange\">\n              <option value=\"\">All Years</option>\n              <option v-for=\"year in availableYears\" :key=\"year\" :value=\"year\">{{ year }}</option>\n          </select>\n        </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Section</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedSection\" @change=\"handleSectionChange\" :disabled=\"!selectedYear\">\n              <option value=\"\">All Sections</option>\n              <option v-for=\"section in sections\" :key=\"section.id\" :value=\"section.name\">\n                {{ section.name }}{{ section.teacherName ? ` - ${section.teacherName}` : '' }}\n              </option>\n            </select>\n          </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Date Range</label>\n            <div class=\"d-flex gap-2\">\n              <div class=\"flex-grow-1\">\n                <label class=\"small text-muted\">From</label>\n                <input \n                  type=\"date\" \n                  class=\"form-control form-control-sm\" \n                  v-model=\"selectedStartDate\"\n                  :max=\"today\"\n                >\n              </div>\n              <div class=\"flex-grow-1\">\n                <label class=\"small text-muted\">To</label>\n                <input \n                  type=\"date\" \n                  class=\"form-control form-control-sm\" \n                  v-model=\"selectedEndDate\"\n                  :max=\"today\"\n                >\n              </div>\n            </div>\n          </div>\n          <div class=\"d-flex justify-content-between\">\n            <button class=\"btn btn-outline-secondary\" @click=\"clearFilters\">Clear Filters</button>\n            <button class=\"btn btn-primary\" @click=\"refreshDashboard\">Apply</button>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Last Updated -->\n      <div class=\"last-update-badge\" v-if=\"lastUpdate\">\n        Last updated: {{ formatDate(lastUpdate) }}\n        <button class=\"btn btn-refresh ms-2\" @click=\"refreshDashboard\" title=\"Refresh Dashboard\">\n          <i class=\"fas fa-sync-alt\"></i>\n        </button>\n      </div>\n    </div>\n\n    <!-- Stats Cards -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Total Students Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-user-graduate\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Students</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ totalStudents }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n        </div>\n      </div>\n      </div>\n\n      <!-- Total Teachers Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-chalkboard-teacher\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Teachers</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ totalTeachers }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n        </div>\n      </div>\n        </div>\n\n      <!-- Active Sections Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-users\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Active Sections</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ activeSections }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Performance Stats -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Average Attendance Card -->\n      <div v-if=\"isCITHead\" class=\"col-md-6\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-clock\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Average Attendance</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading && hasAttendanceData\">{{ averageAttendance }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"isLoading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n        </div>\n      </div>\n      </div>\n      \n      <!-- Average Score Card -->\n      <div class=\"col-md-6\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-chart-line\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Average Score</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading && hasScoreData\">{{ averageScore }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"isLoading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Charts Row -->\n    <div class=\"row mb-4\">\n      <!-- Attendance Distribution Chart -->\n      <div class=\"col-md-6 mb-4\">\n      <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-calendar-check me-2\"></i>\n              Attendance Distribution\n            </h5>\n            <p class=\"chart-description\">Breakdown of student attendance patterns across the department</p>\n        <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n          <canvas ref=\"performanceChart\"></canvas>\n              <p v-if=\"!hasAttendanceData && !isLoading\" class=\"no-data-message\">No attendance data available</p>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Assessment Type Distribution -->\n      <div class=\"col-md-6 mb-4\">\n      <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-tasks me-2\"></i>\n              Assessment Performance Analysis\n            </h5>\n            <p class=\"chart-description\">Average scores by assessment type across the department</p>\n        <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n          <canvas ref=\"assessmentTypeChart\"></canvas>\n              <p v-if=\"!hasAssessmentData && !isLoading\" class=\"no-data-message\">No assessment data available</p>\n            </div>\n        </div>\n      </div>\n    </div>\n\n      <!-- Performance Trend Chart -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-chart-line me-2\"></i>\n              Performance Trends Over Time\n            </h5>\n            <p class=\"chart-description\">Department average scores across recent assessments</p>\n      <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"performanceTrendChart\"></canvas>\n              <p v-if=\"!hasPerformanceData && !isLoading\" class=\"no-data-message\">No performance data available</p>\n            </div>\n          </div>\n      </div>\n    </div>\n\n    <!-- Section Performance -->\n      <div class=\"col-md-6 mb-4\">\n    <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-graduation-cap me-2\"></i>\n              Performance by Assessment Type\n            </h5>\n            <p class=\"chart-description\">Visualizes how students perform across different assessment types</p>\n      <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n        <canvas ref=\"assessmentTypePerformanceChart\"></canvas>\n              <p v-if=\"!hasPerformanceData && !isLoading\" class=\"no-data-message\">No performance data available</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted, computed, watch, onUnmounted, nextTick } from 'vue'\nimport { useStore } from 'vuex'\nimport Chart from 'chart.js/auto'\nimport axios from 'axios'\nimport moment from 'moment'\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: 'http://localhost:8000/api'\n});\n\nexport default {\n  name: 'Dashboard',\n  setup() {\n    const store = useStore()\n    const performanceChart = ref(null)\n    const assessmentTypeChart = ref(null)\n    const performanceTrendChart = ref(null)\n    const assessmentTypePerformanceChart = ref(null)\n    const selectedYear = ref('')\n    const selectedSection = ref('')\n    const selectedStartDate = ref('')\n    const selectedEndDate = ref('')\n    const dashboardContainer = ref(null)\n    const isLoading = ref(false)\n    const lastUpdate = ref(null)\n    const autoRefreshInterval = ref(null)\n    const sections = ref([])\n    const subjects = ref([])\n    const availableYears = ref([])\n    const today = computed(() => moment().format('YYYY-MM-DD'))\n\n    // Computed properties\n    const isCITHead = computed(() => store.getters.isCITHead)\n    const token = computed(() => store.state.auth.token)\n    \n    // Get user name\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'User' : 'User';\n    });\n    \n    // Check if filters are active\n    const hasActiveFilters = computed(() => {\n      return Boolean(selectedYear.value || selectedSection.value);\n    });\n\n    // Set auth token for all requests\n    watch(token, (newToken) => {\n      if (newToken) {\n        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      }\n    }, { immediate: true });\n\n    // Dashboard stats\n    const totalStudents = ref(0)\n    const totalTeachers = ref(0)\n    const averageAttendance = ref(0)\n    const averageScore = ref(0)\n    const activeSections = ref(0)\n    const data = ref(null)\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      if (data.value && data.value.attendanceDistribution) {\n        return data.value.attendanceDistribution.some(val => val > 0);\n      }\n      return false;\n    });\n\n    const hasScoreData = computed(() => {\n      return data.value?.averageScore > 0;\n    });\n\n    const hasPerformanceData = computed(() => {\n      // Check if we have any assessment or performance data\n      if (data.value) {\n        // Check for averageScore > 0\n        if (typeof data.value.averageScore === 'number' && data.value.averageScore > 0) {\n          return true;\n        }\n        \n        // Check for performance trends\n        if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    });\n\n    const hasAssessmentData = computed(() => {\n      if (data.value) {\n        // Check directly in assessmentTypes\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n        \n        // Fallback to assessmentTypeDistribution\n        if (data.value.assessmentTypeDistribution) {\n          return true;\n        }\n      }\n      return false;\n    });\n\n    const hasSectionData = computed(() => {\n      return data.value?.sections?.length > 0;\n    });\n\n    // Fetch available years and sections directly from database records\n    const fetchAvailableFilters = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Get all student records to extract years and sections\n        const response = await api.get('/students', {\n          headers: { 'Authorization': `Bearer ${token.value}` }\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n          // Extract unique years and sections from student records\n          const students = response.data;\n          \n          // Get unique years with data\n          const years = [...new Set(students.map(student => student.year))].filter(Boolean);\n          availableYears.value = years.length > 0 ? years.sort() : ['1st', '2nd', '3rd', '4th'];\n          \n          // Get unique sections based on selectedYear\n          await updateSectionsForSelectedYear();\n          \n          console.log('Fetched available filters:', {\n            years: availableYears.value,\n            sections: sections.value\n          });\n        }\n        \n        isLoading.value = false;\n      } catch (error) {\n        console.error('Error fetching available filters:', error);\n        // Keep default years if API fails\n        availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        isLoading.value = false;\n      }\n    };\n\n    // New function to update sections based on selected year\n    const updateSectionsForSelectedYear = async () => {\n      try {\n        console.log('Updating sections for year:', selectedYear.value || 'All Years');\n        sections.value = []; // Clear existing sections first\n        \n        const params = {};\n        if (selectedYear.value) {\n          params.year = selectedYear.value;\n        }\n        \n        // Get students filtered by year if selected\n        const response = await api.get('/students', {\n          params,\n          headers: { 'Authorization': `Bearer ${token.value}` }\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n          const students = response.data;\n          \n          // Get unique sections matching the selected year\n          let uniqueSections = [];\n          \n          if (selectedYear.value) {\n            // Filter students by the selected year before extracting sections\n            uniqueSections = [...new Set(\n              students\n                .filter(student => student.year === selectedYear.value)\n                .map(student => student.section)\n            )].filter(Boolean);\n          } else {\n            // If no year selected, get all unique sections\n            uniqueSections = [...new Set(\n              students.map(student => student.section)\n            )].filter(Boolean);\n          }\n          \n          console.log(`Found ${uniqueSections.length} sections for ${selectedYear.value || 'all years'}:`, uniqueSections);\n          \n          // Map sections to include teacher info if available\n          sections.value = uniqueSections.map(sectionName => ({\n            id: sectionName,\n            name: sectionName,\n            teacherName: '' // We could fetch teacher info in the future\n          }));\n        } else {\n          console.warn('No student data received when updating sections');\n          sections.value = [];\n        }\n      } catch (error) {\n        console.error('Error updating sections for year:', error);\n        sections.value = [];\n      }\n    };\n\n    // Get attendance data for the charts\n    const fetchAttendanceData = async () => {\n      try {\n        console.log('Fetching attendance with filters:', {\n          year: selectedYear.value || 'All Years',\n          section: selectedSection.value || 'All Sections'\n        });\n        \n        // Create an array to store all attendance records\n        let allAttendanceRecords = [];\n        \n        // Try a direct approach to the dashboard stats endpoint first\n        try {\n          console.log('Trying dashboard stats endpoint directly');\n          const statsParams = {\n            year: selectedYear.value,\n            section: selectedSection.value,\n            startDate: selectedStartDate.value || moment().subtract(30, 'days').format('YYYY-MM-DD'),\n            endDate: selectedEndDate.value || moment().format('YYYY-MM-DD')\n          };\n          \n          const statsResponse = await api.get('/dashboard/stats', { params: statsParams });\n          if (statsResponse.data && statsResponse.data.attendanceDistribution && \n              statsResponse.data.attendanceDistribution.some(val => val > 0)) {\n            console.log('Got attendance from dashboard stats:', statsResponse.data.attendanceDistribution);\n            return statsResponse.data.attendanceDistribution;\n          }\n        } catch (error) {\n          console.log('Dashboard stats did not include attendance data');\n        }\n        \n        // Second approach: Try getting attendance from individual dates but with proper year/section filtering\n        try {\n          console.log('Trying to get attendance from recent dates with proper filtering');\n          // Query recent dates (last 7 days)\n          const datePromises = [];\n          const dates = [];\n          \n          // Generate 7 recent dates\n          for (let i = 0; i < 7; i++) {\n            dates.push(moment().subtract(i, 'days').format('YYYY-MM-DD'));\n          }\n          \n          if (selectedYear.value && selectedSection.value) {\n            // If both year and section are selected, query directly\n            for (const date of dates) {\n              datePromises.push(\n                api.get(`/attendance/date/${date}`, { \n                  params: {\n                    year: selectedYear.value,\n                    section: selectedSection.value\n                  }\n                })\n              );\n            }\n          } else if (selectedYear.value) {\n            // If only year is selected, get all sections for that year and query each one\n            const response = await api.get('/students', { \n              params: { year: selectedYear.value } \n            });\n            \n            let sections = [];\n            if (response.data && Array.isArray(response.data)) {\n              sections = [...new Set(response.data\n                .filter(student => student.year === selectedYear.value)\n                .map(student => student.section)\n              )].filter(Boolean);\n            }\n            \n            // If no sections found, query with just the year\n            if (sections.length === 0) {\n              for (const date of dates) {\n                datePromises.push(\n                  api.get(`/attendance/date/${date}`, { \n                    params: { year: selectedYear.value }\n                  })\n                );\n              }\n            } else {\n              // Query each section for each date\n              for (const date of dates) {\n                for (const section of sections) {\n                  datePromises.push(\n                    api.get(`/attendance/date/${date}`, { \n                      params: {\n                        year: selectedYear.value,\n                        section\n                      }\n                    })\n                  );\n                }\n              }\n            }\n          } else {\n            // If no year selected, get attendance for all years and sections\n            // First get all academic years\n            const years = ['1st', '2nd', '3rd', '4th'];\n            \n            // Query a few dates for each year\n            for (const date of dates) {\n              for (const year of years) {\n                datePromises.push(\n                  api.get(`/attendance/date/${date}`, { \n                    params: { year }\n                  })\n                );\n              }\n            }\n          }\n          \n          // Execute all date queries\n          const dateResults = await Promise.allSettled(datePromises);\n          \n          // Process successful responses\n          dateResults.forEach(result => {\n            if (result.status === 'fulfilled' && result.value?.data && Array.isArray(result.value.data)) {\n              // Filter records by year if needed\n              const records = result.value.data;\n              if (selectedYear.value) {\n                const filteredRecords = records.filter(record => {\n                  // Check if the record matches our year filter\n                  return record.year === selectedYear.value || \n                         (record.students_data && record.students_data[0]?.year === selectedYear.value);\n                });\n                allAttendanceRecords = [...allAttendanceRecords, ...filteredRecords];\n              } else {\n                allAttendanceRecords = [...allAttendanceRecords, ...records];\n              }\n            }\n          });\n          \n          console.log(`Collected ${allAttendanceRecords.length} attendance records from recent dates`);\n        } catch (error) {\n          console.log('Error fetching attendance by date:', error.message);\n        }\n        \n        // Process collected attendance records\n        if (allAttendanceRecords.length > 0) {\n          // Process all attendance records\n          const attendanceCounts = [0, 0, 0]; // [present, late, absent]\n          \n          allAttendanceRecords.forEach(record => {\n            if (record.status === 'present') attendanceCounts[0]++;\n            else if (record.status === 'late') attendanceCounts[1]++;\n            else if (record.status === 'absent') attendanceCounts[2]++;\n          });\n          \n          console.log('Final attendance counts for filtered data:', attendanceCounts);\n          return attendanceCounts;\n        }\n        \n        // Third approach: Try the backend route for all attendance\n        try {\n          console.log('Attempting to use attendance stats endpoint');\n          \n          // Build query based on what's selected\n          const params = {\n            year: selectedYear.value\n          };\n          \n          if (selectedSection.value) {\n            params.section = selectedSection.value;\n          }\n          \n          // Try stats endpoint first\n          try {\n            const statsResponse = await api.get('/dashboard/stats', { params });\n            if (statsResponse.data && statsResponse.data.attendanceDistribution && \n                statsResponse.data.attendanceDistribution.some(val => val > 0)) {\n              console.log('Got attendance distribution from stats:', statsResponse.data.attendanceDistribution);\n              return statsResponse.data.attendanceDistribution;\n            }\n          } catch (error) {\n            console.log('Stats endpoint failed:', error.message);\n          }\n        } catch (error) {\n          console.log('Failed to get attendance stats:', error.message);\n        }\n        \n        // If all approaches failed, return empty data\n        console.log('No attendance data found, using empty data');\n        return [0, 0, 0];\n      } catch (error) {\n        console.error('Error in attendance data fetching:', error);\n        return [0, 0, 0]; // Return empty data on error\n      }\n    };\n\n    const fetchDashboardData = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Prepare query parameters\n        const params = {\n          year: selectedYear.value,\n          section: selectedSection.value,\n          startDate: selectedStartDate.value,\n          endDate: selectedEndDate.value\n        };\n        \n        console.log('Fetching dashboard data with params:', params);\n        \n        // First, fetch attendance data\n        const attendanceDistribution = await fetchAttendanceData();\n        console.log('Attendance distribution for current filters:', attendanceDistribution);\n        \n        // Get dashboard stats - ensure we're using the same filters\n        const statsResponse = await api.get('/dashboard/stats', { params });\n        \n        data.value = statsResponse.data || {};\n        console.log('Dashboard stats response:', data.value);\n        \n        // Check if we received any meaningful data\n        const hasValidData = \n          (data.value.totalStudents > 0) || \n          (data.value.totalTeachers > 0) || \n          (data.value.activeSections > 0) || \n          (data.value.performanceTrends && data.value.performanceTrends.length > 0);\n        \n        // If no valid data, it means the filter combination doesn't match any records\n        if (!hasValidData && (selectedYear.value || selectedSection.value)) {\n          console.warn('No data found for the selected filters');\n        }\n        \n        // Update basic stats\n        totalStudents.value = data.value.totalStudents || 0;\n        totalTeachers.value = data.value.totalTeachers || 0;\n        activeSections.value = data.value.activeSections || 0;\n        \n        // Use our fetched attendance data\n        data.value.attendanceDistribution = attendanceDistribution;\n        \n        // Calculate average attendance from distribution\n        const totalAttendance = attendanceDistribution.reduce((a, b) => a + b, 0);\n        if (totalAttendance > 0) {\n          // Calculate percentage of present and late (not absent)\n          const presentAttendance = attendanceDistribution[0] + attendanceDistribution[1];\n          averageAttendance.value = Math.round((presentAttendance / totalAttendance) * 100);\n        } else {\n          averageAttendance.value = 0;\n        }\n        \n        // Process assessment data for charts\n        await fetchAssessmentData();\n        \n        // Calculate averageScore from assessment data instead of using stats\n        if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n          let totalScore = 0;\n          let totalCount = 0;\n          \n          data.value.assessmentTypes.forEach(type => {\n            if (type.averageScore > 0 && type.count > 0) {\n              totalScore += type.averageScore * type.count;\n              totalCount += type.count;\n            }\n          });\n          \n          if (totalCount > 0) {\n            averageScore.value = Math.round(totalScore / totalCount);\n            data.value.averageScore = averageScore.value;\n          } else {\n            averageScore.value = 0;\n            data.value.averageScore = 0;\n          }\n          \n          console.log(`Calculated average score: ${averageScore.value}% from ${totalCount} assessments`);\n        } else {\n          averageScore.value = 0;\n          data.value.averageScore = 0;\n        }\n\n        // Update charts with new data\n        updateCharts(data.value);\n        \n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Failed to fetch dashboard data:', error);\n        if (error.response) {\n          console.error('Error response:', error.response.data);\n        }\n        \n        // Initialize with empty data if main stats request fails\n        data.value = {\n          totalStudents: 0,\n          totalTeachers: 0,\n          activeSections: 0,\n          attendanceDistribution: [0, 0, 0],\n          averageAttendance: 0,\n          assessmentTypes: [],\n          performanceTrends: [],\n          averageScore: 0,\n          sections: []\n        };\n        \n        totalStudents.value = 0;\n        totalTeachers.value = 0;\n        activeSections.value = 0;\n        averageAttendance.value = 0;\n        averageScore.value = 0;\n        \n        // Update charts with empty data\n        updateCharts(data.value);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    \n    // Fetch assessment data directly\n    const fetchAssessmentData = async () => {\n      try {\n        // Set date range for better data filtering\n        const assessmentParams = {\n          year: selectedYear.value,\n          section: selectedSection.value,\n          startDate: selectedStartDate.value || moment().subtract(90, 'days').format('YYYY-MM-DD'),\n          endDate: selectedEndDate.value || moment().format('YYYY-MM-DD')\n        };\n        \n        console.log('Fetching assessment data with params:', assessmentParams);\n        \n        // Directly fetch assessment data with filters\n        const assessmentResponse = await api.get('/assessments', {\n          params: assessmentParams\n        });\n        \n        console.log('Fetched assessment data count:', assessmentResponse.data?.length || 0);\n        \n        if (assessmentResponse.data && Array.isArray(assessmentResponse.data)) {\n          let assessments = assessmentResponse.data;\n          \n          // If year is selected, double-check that we're only using assessments for that year\n          if (selectedYear.value) {\n            assessments = assessments.filter(assessment => {\n              // Check different fields where year might be stored\n              return (assessment.year === selectedYear.value) || \n                     (assessment.students && assessment.students[0]?.year === selectedYear.value);\n            });\n            \n            console.log(`After year filtering: ${assessments.length} assessments match year ${selectedYear.value}`);\n          }\n          \n          // Group assessments by type\n          const assessmentTypes = {\n            'Quiz': { count: 0, totalScore: 0, scores: [] },\n            'Activity': { count: 0, totalScore: 0, scores: [] },\n            'Performance Task': { count: 0, totalScore: 0, scores: [] }\n          };\n          \n          // Process each assessment\n          assessments.forEach(assessment => {\n            const type = assessment.type || 'Other';\n            if (assessmentTypes[type]) {\n              assessmentTypes[type].count++;\n              \n              // Process scores if available\n              if (assessment.scores) {\n                // Handle both array and Map formats\n                let scoreArray = [];\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (assessment.scores instanceof Map) {\n                  scoreArray = Array.from(assessment.scores.values());\n                } else if (typeof assessment.scores === 'object') {\n                  // Handle object format\n                  scoreArray = Object.values(assessment.scores);\n                }\n                \n                scoreArray.forEach(score => {\n                  if (typeof score === 'number') {\n                    const percentage = assessment.maxScore ? (score / assessment.maxScore) * 100 : score;\n                    assessmentTypes[type].totalScore += percentage;\n                    assessmentTypes[type].scores.push(percentage);\n                  }\n                });\n              }\n            }\n          });\n          \n          // Calculate averages and prepare for chart\n          data.value.assessmentTypes = Object.keys(assessmentTypes).map(type => {\n            const typeData = assessmentTypes[type];\n            const averageScore = typeData.scores.length > 0 \n              ? typeData.totalScore / typeData.scores.length \n              : 0;\n              \n            return {\n              type,\n              averageScore: Math.round(averageScore),\n              count: typeData.count,\n              completionRate: typeData.count > 0 ? 100 : 0\n            };\n          });\n          \n          // Generate performance trends from assessment data\n          data.value.performanceTrends = assessments\n            .filter(a => a.date) // Only include assessments with dates\n            .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n            .map(assessment => {\n              // Calculate average score for this assessment\n              let averageScore = 0;\n              let scoreArray = [];\n              \n              // Handle different score formats\n              if (assessment.scores) {\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (assessment.scores instanceof Map) {\n                  scoreArray = Array.from(assessment.scores.values());\n                } else if (typeof assessment.scores === 'object') {\n                  scoreArray = Object.values(assessment.scores);\n                }\n                \n                // Calculate average from valid scores\n                const validScores = scoreArray.filter(score => typeof score === 'number');\n                if (validScores.length > 0) {\n                  const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                  averageScore = assessment.maxScore \n                    ? (totalScore / validScores.length / assessment.maxScore) * 100\n                    : totalScore / validScores.length;\n                }\n              }\n              \n              return {\n                date: assessment.date,\n                title: assessment.name || assessment.type,\n                averageScore: Math.round(averageScore),\n                type: assessment.type\n              };\n            });\n          \n          console.log(`Performance trends data for ${selectedYear.value || 'all years'}: ${data.value.performanceTrends.length} entries`);\n          \n          // Process section data if available\n          // Group assessments by section\n          const sectionPerformance = {};\n          \n          // Only process section performance if we actually have data\n          if (assessments.length > 0) {\n            assessments.forEach(assessment => {\n              if (assessment.section) {\n                if (!sectionPerformance[assessment.section]) {\n                  sectionPerformance[assessment.section] = {\n                    totalScore: 0,\n                    scoreCount: 0,\n                    attendanceCount: 0,\n                    attendanceTotal: 0\n                  };\n                }\n                \n                // Process scores\n                let scoreArray = [];\n                if (assessment.scores) {\n                  if (Array.isArray(assessment.scores)) {\n                    scoreArray = assessment.scores;\n                  } else if (assessment.scores instanceof Map) {\n                    scoreArray = Array.from(assessment.scores.values());\n                  } else if (typeof assessment.scores === 'object') {\n                    scoreArray = Object.values(assessment.scores);\n                  }\n                  \n                  scoreArray.forEach(score => {\n                    if (typeof score === 'number') {\n                      const percentage = assessment.maxScore ? (score / assessment.maxScore) * 100 : score;\n                      sectionPerformance[assessment.section].totalScore += percentage;\n                      sectionPerformance[assessment.section].scoreCount++;\n                    }\n                  });\n                }\n              }\n            });\n            \n            // Prepare section data for chart if we have any\n            if (Object.keys(sectionPerformance).length > 0) {\n              data.value.sections = Object.keys(sectionPerformance).map(sectionName => {\n                const section = sectionPerformance[sectionName];\n                const averageScore = section.scoreCount > 0 \n                  ? section.totalScore / section.scoreCount \n                  : 0;\n                \n                return {\n                  name: sectionName,\n                  averageScore: Math.round(averageScore),\n                  attendanceRate: 0, // We don't have this data\n                  performance: Math.round(averageScore) // For backward compatibility\n                };\n              });\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching assessment data:', error);\n        // Set default values\n        data.value.assessmentTypes = [\n          { type: 'Quiz', averageScore: 0, count: 0 },\n          { type: 'Activity', averageScore: 0, count: 0 },\n          { type: 'Performance Task', averageScore: 0, count: 0 }\n        ];\n        data.value.performanceTrends = [];\n        data.value.sections = [];\n      }\n    };\n\n    const updateCharts = (data) => {\n      updatePerformanceChart(data);\n      updateAssessmentTypeChart(data);\n      updatePerformanceTrendChart(data);\n      updateAssessmentTypePerformanceChart(data);\n    };\n\n    // Update initEmptyCharts to properly handle chart destruction\n    const initEmptyCharts = () => {\n      // First destroy any existing charts to prevent \"Canvas is already in use\" errors\n      const charts = [\n        performanceChart.value, \n        assessmentTypeChart.value, \n        performanceTrendChart.value,\n        assessmentTypePerformanceChart.value\n      ];\n      \n      // Destroy all existing charts first\n      charts.forEach(canvas => {\n        if (canvas) {\n          const ctx = canvas.getContext('2d');\n          if (ctx) {\n            const existingChart = Chart.getChart(ctx);\n            if (existingChart) {\n              existingChart.destroy();\n            }\n          }\n        }\n      });\n      \n      // Create empty data structure\n      const emptyData = {\n        totalStudents: 0,\n        totalTeachers: 0,\n        activeSections: 0,\n        averageAttendance: 0,\n        averageScore: 0,\n        attendanceDistribution: [0, 0, 0],\n        assessmentTypes: [\n          { type: 'Quiz', averageScore: 0, count: 0 },\n          { type: 'Activity', averageScore: 0, count: 0 },\n          { type: 'Performance Task', averageScore: 0, count: 0 }\n        ],\n        performanceTrends: [],\n        sections: []\n      };\n      \n      // Update charts with empty data\n      updateCharts(emptyData);\n    };\n\n    // Format date for display\n    const formatDate = (date) => {\n      if (!date) return '';\n      return moment(date).format('MMMM D, YYYY h:mm A');\n    };\n\n    // Handle year change\n    const handleYearChange = async () => {\n      console.log('Year changed to:', selectedYear.value);\n      \n      // Reset the section when year changes\n      selectedSection.value = '';\n      \n      // Update sections based on the new year\n      await updateSectionsForSelectedYear();\n      \n      // Update dashboard data with new filters\n      await fetchDashboardData();\n    };\n\n    // Handle section change\n    const handleSectionChange = async () => {\n      // Update dashboard data with new filters\n      fetchDashboardData();\n    };\n\n    // Handle filter change\n    const handleFilterChange = () => {\n      fetchDashboardData();\n    };\n\n    // Clear all filters\n    const clearFilters = () => {\n      console.log('Clearing all filters');\n      \n      // Reset all filter values\n      selectedYear.value = '';\n      selectedSection.value = '';\n      selectedStartDate.value = '';\n      selectedEndDate.value = '';\n      \n      // Reset sections \n      sections.value = [];\n      \n      // Refresh the dashboard with no filters\n      fetchAvailableFilters().then(() => {\n        console.log('Available filters refreshed, fetching dashboard data');\n        fetchDashboardData();\n      });\n    };\n\n    // Get filter display text\n    const getFilterDisplay = () => {\n      const filters = []\n      if (selectedYear.value) filters.push(selectedYear.value)\n      if (selectedSection.value) filters.push(selectedSection.value)\n      \n      // Add date range to display if selected\n      if (selectedStartDate.value && selectedEndDate.value) {\n        const formattedStart = moment(selectedStartDate.value).format('MMM D')\n        const formattedEnd = moment(selectedEndDate.value).format('MMM D, YYYY')\n        filters.push(`${formattedStart} - ${formattedEnd}`)\n      } else if (selectedStartDate.value) {\n        filters.push(`From ${moment(selectedStartDate.value).format('MMM D, YYYY')}`)\n      } else if (selectedEndDate.value) {\n        filters.push(`Until ${moment(selectedEndDate.value).format('MMM D, YYYY')}`)\n      }\n      \n      return filters.length > 0 ? filters.join(' - ') : 'Filter View'\n    };\n\n    // Update charts with data\n    const updatePerformanceChart = (data) => {\n      if (!performanceChart.value) return;\n      \n      const ctx = performanceChart.value.getContext('2d');\n      if (!ctx) return;\n      \n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      \n      // Attendance status distribution data\n      const attendanceLabels = ['Present', 'Late', 'Absent'];\n      let attendanceData = data.attendanceDistribution || [0, 0, 0];\n      \n      // Ensure we have at least some data to display\n      const totalAttendanceCount = attendanceData.reduce((a, b) => a + b, 0);\n      if (totalAttendanceCount === 0) {\n        // Use empty distribution if no real data\n        attendanceData = [0, 0, 0];\n      }\n      \n      // Log for debugging\n      console.log('Final attendance distribution data:', attendanceData);\n      \n      // Create chart\n      new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n          labels: attendanceLabels,\n          datasets: [{\n            data: attendanceData,\n            backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],\n            borderWidth: 0,\n            hoverOffset: 4\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          cutout: '70%',\n            plugins: {\n              legend: {\n              position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function(context) {\n                  const label = context.label || '';\n                  const value = context.raw || 0;\n                  const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);\n                  const percentage = total > 0 ? Math.round((value / total) * 100) : 0;\n                  return `${label}: ${value} (${percentage}%)`;\n                  }\n                }\n              }\n            }\n          }\n      });\n    };\n\n    const updateAssessmentTypeChart = (data) => {\n      if (!assessmentTypeChart.value) return;\n      \n      const ctx = assessmentTypeChart.value.getContext('2d');\n      if (!ctx) return;\n      \n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      \n      // Assessment types data\n      const assessmentData = data.assessmentTypes || [];\n      const labels = [];\n      const values = [];\n      const colors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#6366f1'];\n      \n      try {\n        // Extract assessment types data\n        if (Array.isArray(assessmentData)) {\n          // If array format\n          assessmentData.forEach((item, index) => {\n            if (item && typeof item === 'object') {\n              labels.push(item.type || `Type ${index + 1}`);\n              values.push(parseFloat(item.averageScore) || 0);\n            }\n          });\n        } else if (typeof assessmentData === 'object' && assessmentData !== null) {\n          // If object format\n          Object.entries(assessmentData).forEach(([type, data], index) => {\n            labels.push(type);\n            values.push(parseFloat(data.averageScore) || 0);\n          });\n        }\n        \n        // If no data was extracted, use default types\n        if (labels.length === 0) {\n          labels.push('Quiz', 'Activity', 'Performance Task');\n          values.push(0, 0, 0);\n        }\n      } catch (error) {\n        console.error('Error processing assessment data:', error);\n        // Fallback to default labels and values\n        labels.push('Quiz', 'Activity', 'Performance Task');\n        values.push(0, 0, 0);\n      }\n      \n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n          data: {\n          labels: labels,\n            datasets: [{\n            label: 'Average Score (%)',\n            data: values,\n            backgroundColor: colors.slice(0, labels.length),\n            borderWidth: 0,\n            borderRadius: 6,\n            maxBarThickness: 50\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n          plugins: {\n            legend: {\n                display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: function(context) {\n                  return `Average Score: ${context.raw}%`;\n                }\n              }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function(value) {\n                    return value + '%';\n                  }\n                }\n              }\n          }\n        }\n      });\n    };\n\n    const updatePerformanceTrendChart = (data) => {\n      if (!performanceTrendChart.value) return;\n      \n      const ctx = performanceTrendChart.value.getContext('2d');\n      if (!ctx) return;\n      \n      // Properly destroy any existing chart\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      let trends = [];\n      if (data.performanceTrends && Array.isArray(data.performanceTrends)) {\n        // Filter out trends that have no valid score or date\n        trends = data.performanceTrends\n          .filter(trend => \n            trend.date && \n            (typeof trend.averageScore === 'number' || typeof trend.score === 'number')\n          )\n          .map(trend => ({\n            date: new Date(trend.date),\n            value: parseFloat(trend.averageScore || trend.score) || 0,\n            name: trend.title || trend.name || 'Assessment'\n          }))\n          .sort((a, b) => a.date - b.date);\n      }\n      \n      console.log(`Performance trend chart data: ${trends.length} valid data points`);\n      \n      // Check if we have any valid data points\n      const hasData = trends.length > 0 && trends.some(t => t.value > 0);\n      \n      if (hasData) {\n        // Create new chart after destroying the old one\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: trends.map(trend => moment(trend.date).format('MMM D, YYYY')),\n            datasets: [{\n              label: 'Average Score',\n              data: trends.map(trend => trend.value),\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2,\n              tension: 0.4,\n              fill: true,\n              pointRadius: 4,\n              pointBackgroundColor: 'rgb(59, 130, 246)',\n              pointHoverRadius: 6\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  title: (tooltipItems) => {\n                    if (!tooltipItems.length || !trends[tooltipItems[0].dataIndex]) return '';\n                    const trend = trends[tooltipItems[0].dataIndex];\n                    return `${moment(trend.date).format('MMM D, YYYY')} - ${trend.name}`;\n                  },\n                  label: (context) => {\n                    return `Score: ${context.raw.toFixed(1)}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart to show the \"No data available\" message\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'Average Score',\n              data: [],\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const updateAssessmentTypePerformanceChart = (data) => {\n      if (!assessmentTypePerformanceChart.value) return;\n      \n      const ctx = assessmentTypePerformanceChart.value.getContext('2d');\n      if (!ctx) return;\n\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process the performance trends data by assessment type\n      const trendsByType = {\n        Quiz: [],\n        Activity: [],\n        'Performance Task': []\n      };\n\n      // Process performance trends data\n      let hasValidData = false;\n      if (Array.isArray(data.performanceTrends)) {\n        data.performanceTrends.forEach(trend => {\n          // Only process trends with valid scores and dates\n          if (trend.date && (typeof trend.averageScore === 'number' || typeof trend.score === 'number')) {\n            const type = trend.type || trend.title || 'Other';\n            const score = parseFloat(trend.averageScore || trend.score) || 0;\n            \n            // Create the array for this type if it doesn't exist\n            if (!trendsByType[type]) {\n              trendsByType[type] = [];\n            }\n            \n            trendsByType[type].push({\n              date: new Date(trend.date),\n              score: score\n            });\n            \n            if (score > 0) {\n              hasValidData = true;\n            }\n          }\n        });\n      }\n\n      // Sort data points by date for each type\n      Object.keys(trendsByType).forEach(type => {\n        trendsByType[type].sort((a, b) => a.date - b.date);\n      });\n\n      // Get unique dates across all types\n      const allDates = [...new Set(\n        Object.values(trendsByType)\n          .flat()\n          .map(item => item.date)\n      )].sort((a, b) => a - b);\n      \n      // Only proceed if we have valid dates\n      if (allDates.length > 0 && hasValidData) {\n        console.log(`Assessment type performance chart: ${allDates.length} dates with data`);\n        \n        // Create datasets\n        const datasets = Object.entries(trendsByType)\n          .filter(([_, data]) => data.length > 0) // Only include types with data\n          .map(([type, data], index) => {\n            const colors = [\n              'rgb(52, 211, 153)',   // Green for Quiz\n              'rgb(59, 130, 246)',   // Blue for Activity\n              'rgb(251, 191, 36)'    // Yellow for Performance Task\n            ];\n            const color = colors[index % colors.length];\n  \n            return {\n              label: type,\n              data: allDates.map(date => {\n                const point = data.find(d => d.date.getTime() === date.getTime());\n                return point ? point.score : null;\n              }),\n              borderColor: color,\n              backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),\n              fill: true,\n              tension: 0.4,\n              pointRadius: 4,\n              pointHoverRadius: 6,\n              spanGaps: true // This will connect points even if there are null values\n            };\n          });\n  \n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: allDates.map(date => moment(date).format('MMM D, YYYY')),\n            datasets\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            interaction: {\n              intersect: false,\n              mode: 'index'\n            },\n            plugins: {\n              legend: {\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  label: (context) => {\n                    const value = context.raw !== null ? context.raw.toFixed(1) : 'N/A';\n                    return `${context.dataset.label}: ${value}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart if no valid data\n        console.log('No valid assessment type performance data, showing empty chart');\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'No Data',\n              data: [],\n              borderColor: 'rgb(203, 213, 225)',\n              backgroundColor: 'rgba(203, 213, 225, 0.1)'\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    // Update the refreshDashboard function to properly handle chart destruction\n    const refreshDashboard = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Destroy existing charts before fetching new data\n        initEmptyCharts();\n        \n        // Wait a tick to ensure DOM updates\n        await nextTick();\n        \n        // Fetch new data\n        await fetchDashboardData();\n        \n        // Update the last refresh time\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Error refreshing dashboard:', error);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    const scrollToSection = (sectionId) => {\n      const section = document.getElementById(sectionId);\n      if (section) {\n        section.scrollIntoView({ behavior: 'smooth' });\n      }\n    };\n\n    // Restore auto-refresh in onMounted function\n    onMounted(async () => {\n      try {\n        // Make sure DOM is rendered before initializing charts\n        await nextTick();\n\n        console.log('Dashboard mounted, initializing');\n        \n        // Initialize with empty data while waiting for API\n        initEmptyCharts();\n        \n        // Set up API interceptor to handle 404 errors gracefully\n        api.interceptors.response.use(\n          response => response,\n          error => {\n            if (error.response && error.response.status === 404) {\n              console.warn(`API endpoint not found: ${error.config.url}`);\n            }\n            return Promise.reject(error);\n          }\n        );\n        \n        // Set auth token for API requests\n        if (store.state.auth.token) {\n          api.defaults.headers.common['Authorization'] = `Bearer ${store.state.auth.token}`;\n        }\n        \n        // Fetch available years and sections with data\n        await fetchAvailableFilters();\n        \n        // Ensure all available years are set properly\n        if (availableYears.value.length === 0) {\n          availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        }\n        \n        // Fetch dashboard data\n        await fetchDashboardData();\n        \n        // Set up auto-refresh\n        if (autoRefreshInterval.value) {\n          clearInterval(autoRefreshInterval.value);\n        }\n        \n        // Refresh every 5 minutes, but only if tab is visible\n        autoRefreshInterval.value = setInterval(() => {\n          if (document.visibilityState === 'visible') {\n            refreshDashboard();\n          }\n        }, 5 * 60 * 1000); // 5 minutes\n      } catch (error) {\n        console.error('Error initializing dashboard:', error);\n        // Make sure we still have empty charts if data loading fails\n        await nextTick();\n        initEmptyCharts();\n      }\n    });\n\n    // Clean up on component unmount\n    onUnmounted(() => {\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n    });\n\n    // Add watch for date changes\n    watch([selectedStartDate, selectedEndDate], () => {\n      if (selectedStartDate.value && selectedEndDate.value) {\n        // Validate date range\n        const start = moment(selectedStartDate.value);\n        const end = moment(selectedEndDate.value);\n        \n        if (end.isBefore(start)) {\n          selectedEndDate.value = selectedStartDate.value;\n        }\n      }\n    });\n\n    return {\n      performanceChart,\n      assessmentTypeChart,\n      performanceTrendChart,\n      assessmentTypePerformanceChart,\n      selectedYear,\n      selectedSection,\n      sections,\n      subjects,\n      availableYears,\n      isCITHead,\n      userName,\n      hasActiveFilters,\n      totalStudents,\n      totalTeachers,\n      averageAttendance,\n      averageScore,\n      activeSections,\n      hasAttendanceData,\n      hasScoreData,\n      hasPerformanceData,\n      hasAssessmentData,\n      hasSectionData,\n      dashboardContainer,\n      isLoading,\n      lastUpdate,\n      formatDate,\n      scrollToSection,\n      handleYearChange,\n      handleSectionChange,\n      clearFilters,\n      getFilterDisplay,\n      refreshDashboard,\n      fetchAvailableFilters,\n      selectedStartDate,\n      selectedEndDate,\n      today\n    }\n  }\n}\n</script>\n\n<style scoped>\n.dashboard {\n  padding: 2rem;\n  background-color: #f8f9fa;\n  min-height: 100vh;\n}\n\n/* Greeting Section Styles */\n.greeting-section {\n  padding-bottom: 1.5rem;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n}\n\n.greeting {\n  font-size: 2.25rem;\n  font-weight: 700;\n  color: #003366;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.5px;\n}\n\n.greeting-subtitle {\n  color: #64748b;\n  font-size: 1.125rem;\n  font-weight: 400;\n  margin: 0;\n}\n\n/* Filter and Form Styles */\n.btn-filter {\n  background-color: white;\n  border: 1px solid #e2e8f0;\n  padding: 0.75rem 1.25rem;\n  font-size: 0.9rem;\n  color: #1e293b;\n  min-width: 220px;\n  text-align: left;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s ease;\n}\n\n.btn-filter:hover {\n  background-color: #f8fafc;\n  border-color: #003366;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);\n}\n\n.filter-menu {\n  width: 320px;\n  padding: 1.25rem;\n  border: none;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\n  border-radius: 12px;\n}\n\n.dropdown-header {\n  color: #003366;\n  font-weight: 700;\n  padding: 0;\n  margin-bottom: 1.25rem;\n  font-size: 1rem;\n}\n\n.form-label {\n  font-weight: 600;\n  color: #475569;\n  margin-bottom: 0.5rem;\n  font-size: 0.875rem;\n}\n\n.last-update-badge {\n  font-size: 0.85rem;\n  color: #64748b;\n  display: flex;\n  align-items: center;\n}\n\n.btn-refresh {\n  background: white;\n  border: 1px solid #e2e8f0;\n  color: #4a5568;\n  padding: 0.5rem;\n  border-radius: 8px;\n  width: 36px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s ease;\n}\n\n.btn-refresh:hover {\n  background: #f7fafc;\n  color: #2d3748;\n  border-color: #cbd5e1;\n}\n\n/* Dashboard Cards */\n.dashboard-card {\n  background: #fff;\n  border-radius: 12px;\n  padding: 1.5rem;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  display: flex;\n  align-items: center;\n  gap: 1.25rem;\n  height: 100%;\n  transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n.dashboard-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);\n}\n\n.icon-container {\n  width: 52px;\n  height: 52px;\n  border-radius: 12px;\n  background-color: #003366;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: transform 0.2s ease;\n}\n\n.dashboard-card:hover .icon-container {\n  transform: scale(1.05);\n}\n\n.icon-container i {\n  color: white;\n  font-size: 1.5rem;\n}\n\n.card-info {\n  flex: 1;\n}\n\n.stat-title {\n  font-size: 0.875rem;\n  color: #64748b;\n  margin: 0 0 0.5rem 0;\n  font-weight: 600;\n  letter-spacing: 0.3px;\n}\n\n.stat-value {\n  font-size: 1.75rem;\n  font-weight: 700;\n  color: #1e293b;\n  line-height: 1.2;\n}\n\n.stat-value.loading {\n  color: #94a3b8;\n  font-size: 1.5rem;\n}\n\n.no-data {\n  color: #94a3b8;\n  font-style: italic;\n  font-size: 0.875rem;\n}\n\n/* Chart Cards */\n.chart-card {\n  background: white;\n  border-radius: 12px;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  height: 100%;\n}\n\n.card-body {\n  padding: 1.5rem;\n}\n\n.card-title {\n  font-size: 1.125rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.3px;\n}\n\n.chart-description {\n  font-size: 0.85rem;\n  color: #64748b;\n  margin-bottom: 1.25rem;\n  font-style: italic;\n}\n\n.chart-container {\n  position: relative;\n  height: 400px;\n  width: 100%;\n  margin-bottom: 1rem;\n}\n\n.loading-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background-color: rgba(255, 255, 255, 0.8);\n  z-index: 10;\n  border-radius: 8px;\n}\n\n.loading-overlay i {\n  font-size: 2rem;\n  color: #003366;\n  margin-bottom: 1rem;\n}\n\n.loading-overlay p {\n  font-size: 0.9rem;\n  color: #64748b;\n}\n\n.no-data-message {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  color: #94a3b8;\n  font-style: italic;\n  text-align: center;\n  width: 100%;\n  padding: 1rem;\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n  .dashboard {\n    padding: 1rem;\n  }\n\n  .greeting {\n    font-size: 1.75rem;\n  }\n  \n  .filter-menu {\n    width: 100%;\n    max-width: 320px;\n  }\n\n  .btn-filter {\n    min-width: auto;\n    width: 100%;\n  }\n  \n  .chart-container {\n    height: 300px;\n  }\n}\n</style> "],"mappings":";;;;;;;;;;;;;;;AAgPA,SAASA,GAAG,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,WAAW,EAAEC,QAAO,QAAS,KAAI;AAC3E,SAASC,QAAO,QAAS,MAAK;AAC9B,OAAOC,KAAI,MAAO,eAAc;AAChC,OAAOC,KAAI,MAAO,OAAM;AACxB,OAAOC,MAAK,MAAO,QAAO;;AAE1B;AACA,MAAMC,GAAE,GAAIF,KAAK,CAACG,MAAM,CAAC;EACvBC,OAAO,EAAE;AACX,CAAC,CAAC;AAEF,eAAe;EACbC,IAAI,EAAE,WAAW;EACjBC,KAAKA,CAAA,EAAG;IACN,MAAMC,KAAI,GAAIT,QAAQ,CAAC;IACvB,MAAMU,gBAAe,GAAIhB,GAAG,CAAC,IAAI;IACjC,MAAMiB,mBAAkB,GAAIjB,GAAG,CAAC,IAAI;IACpC,MAAMkB,qBAAoB,GAAIlB,GAAG,CAAC,IAAI;IACtC,MAAMmB,8BAA6B,GAAInB,GAAG,CAAC,IAAI;IAC/C,MAAMoB,YAAW,GAAIpB,GAAG,CAAC,EAAE;IAC3B,MAAMqB,eAAc,GAAIrB,GAAG,CAAC,EAAE;IAC9B,MAAMsB,iBAAgB,GAAItB,GAAG,CAAC,EAAE;IAChC,MAAMuB,eAAc,GAAIvB,GAAG,CAAC,EAAE;IAC9B,MAAMwB,kBAAiB,GAAIxB,GAAG,CAAC,IAAI;IACnC,MAAMyB,SAAQ,GAAIzB,GAAG,CAAC,KAAK;IAC3B,MAAM0B,UAAS,GAAI1B,GAAG,CAAC,IAAI;IAC3B,MAAM2B,mBAAkB,GAAI3B,GAAG,CAAC,IAAI;IACpC,MAAM4B,QAAO,GAAI5B,GAAG,CAAC,EAAE;IACvB,MAAM6B,QAAO,GAAI7B,GAAG,CAAC,EAAE;IACvB,MAAM8B,cAAa,GAAI9B,GAAG,CAAC,EAAE;IAC7B,MAAM+B,KAAI,GAAI7B,QAAQ,CAAC,MAAMO,MAAM,CAAC,CAAC,CAACuB,MAAM,CAAC,YAAY,CAAC;;IAE1D;IACA,MAAMC,SAAQ,GAAI/B,QAAQ,CAAC,MAAMa,KAAK,CAACmB,OAAO,CAACD,SAAS;IACxD,MAAME,KAAI,GAAIjC,QAAQ,CAAC,MAAMa,KAAK,CAACqB,KAAK,CAACC,IAAI,CAACF,KAAK;;IAEnD;IACA,MAAMG,QAAO,GAAIpC,QAAQ,CAAC,MAAM;MAC9B,MAAMqC,IAAG,GAAIxB,KAAK,CAACqB,KAAK,CAACC,IAAI,CAACE,IAAI;MAClC,OAAOA,IAAG,GAAIA,IAAI,CAAC1B,IAAG,IAAK,GAAG0B,IAAI,CAACC,SAAQ,IAAK,EAAE,IAAID,IAAI,CAACE,QAAO,IAAK,EAAE,EAAE,CAACC,IAAI,CAAC,KAAK,MAAK,GAAI,MAAM;IACvG,CAAC,CAAC;;IAEF;IACA,MAAMC,gBAAe,GAAIzC,QAAQ,CAAC,MAAM;MACtC,OAAO0C,OAAO,CAACxB,YAAY,CAACyB,KAAI,IAAKxB,eAAe,CAACwB,KAAK,CAAC;IAC7D,CAAC,CAAC;;IAEF;IACA1C,KAAK,CAACgC,KAAK,EAAGW,QAAQ,IAAK;MACzB,IAAIA,QAAQ,EAAE;QACZpC,GAAG,CAACqC,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,IAAI,UAAUH,QAAQ,EAAE;MACrE;IACF,CAAC,EAAE;MAAEI,SAAS,EAAE;IAAK,CAAC,CAAC;;IAEvB;IACA,MAAMC,aAAY,GAAInD,GAAG,CAAC,CAAC;IAC3B,MAAMoD,aAAY,GAAIpD,GAAG,CAAC,CAAC;IAC3B,MAAMqD,iBAAgB,GAAIrD,GAAG,CAAC,CAAC;IAC/B,MAAMsD,YAAW,GAAItD,GAAG,CAAC,CAAC;IAC1B,MAAMuD,cAAa,GAAIvD,GAAG,CAAC,CAAC;IAC5B,MAAMwD,IAAG,GAAIxD,GAAG,CAAC,IAAI;;IAErB;IACA,MAAMyD,iBAAgB,GAAIvD,QAAQ,CAAC,MAAM;MACvC,IAAIsD,IAAI,CAACX,KAAI,IAAKW,IAAI,CAACX,KAAK,CAACa,sBAAsB,EAAE;QACnD,OAAOF,IAAI,CAACX,KAAK,CAACa,sBAAsB,CAACC,IAAI,CAACC,GAAE,IAAKA,GAAE,GAAI,CAAC,CAAC;MAC/D;MACA,OAAO,KAAK;IACd,CAAC,CAAC;IAEF,MAAMC,YAAW,GAAI3D,QAAQ,CAAC,MAAM;MAClC,OAAOsD,IAAI,CAACX,KAAK,EAAES,YAAW,GAAI,CAAC;IACrC,CAAC,CAAC;IAEF,MAAMQ,kBAAiB,GAAI5D,QAAQ,CAAC,MAAM;MACxC;MACA,IAAIsD,IAAI,CAACX,KAAK,EAAE;QACd;QACA,IAAI,OAAOW,IAAI,CAACX,KAAK,CAACS,YAAW,KAAM,QAAO,IAAKE,IAAI,CAACX,KAAK,CAACS,YAAW,GAAI,CAAC,EAAE;UAC9E,OAAO,IAAI;QACb;;QAEA;QACA,IAAIS,KAAK,CAACC,OAAO,CAACR,IAAI,CAACX,KAAK,CAACoB,iBAAiB,KAAKT,IAAI,CAACX,KAAK,CAACoB,iBAAiB,CAACC,MAAK,GAAI,CAAC,EAAE;UAC1F,OAAO,IAAI;QACb;MACF;MACA,OAAO,KAAK;IACd,CAAC,CAAC;IAEF,MAAMC,iBAAgB,GAAIjE,QAAQ,CAAC,MAAM;MACvC,IAAIsD,IAAI,CAACX,KAAK,EAAE;QACd;QACA,IAAIW,IAAI,CAACX,KAAK,CAACuB,eAAe,EAAE;UAC9B,MAAMA,eAAc,GAAIC,MAAM,CAACC,MAAM,CAACd,IAAI,CAACX,KAAK,CAACuB,eAAe,CAAC;UACjE,OAAOA,eAAe,CAACT,IAAI,CAACY,IAAG,IAAKA,IAAI,CAACC,KAAI,GAAI,CAAC,CAAC;QACrD;;QAEA;QACA,IAAIhB,IAAI,CAACX,KAAK,CAAC4B,0BAA0B,EAAE;UACzC,OAAO,IAAI;QACb;MACF;MACA,OAAO,KAAK;IACd,CAAC,CAAC;IAEF,MAAMC,cAAa,GAAIxE,QAAQ,CAAC,MAAM;MACpC,OAAOsD,IAAI,CAACX,KAAK,EAAEjB,QAAQ,EAAEsC,MAAK,GAAI,CAAC;IACzC,CAAC,CAAC;;IAEF;IACA,MAAMS,qBAAoB,GAAI,MAAAA,CAAA,KAAY;MACxC,IAAI;QACFlD,SAAS,CAACoB,KAAI,GAAI,IAAI;;QAEtB;QACA,MAAM+B,QAAO,GAAI,MAAMlE,GAAG,CAACmE,GAAG,CAAC,WAAW,EAAE;UAC1C7B,OAAO,EAAE;YAAE,eAAe,EAAE,UAAUb,KAAK,CAACU,KAAK;UAAG;QACtD,CAAC,CAAC;QAEF,IAAI+B,QAAQ,CAACpB,IAAG,IAAKO,KAAK,CAACC,OAAO,CAACY,QAAQ,CAACpB,IAAI,CAAC,EAAE;UACjD;UACA,MAAMsB,QAAO,GAAIF,QAAQ,CAACpB,IAAI;;UAE9B;UACA,MAAMuB,KAAI,GAAI,CAAC,GAAG,IAAIC,GAAG,CAACF,QAAQ,CAACG,GAAG,CAACC,OAAM,IAAKA,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAACxC,OAAO,CAAC;UACjFd,cAAc,CAACe,KAAI,GAAIkC,KAAK,CAACb,MAAK,GAAI,IAAIa,KAAK,CAACM,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;;UAErF;UACA,MAAMC,6BAA6B,CAAC,CAAC;UAErCC,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAE;YACxCT,KAAK,EAAEjD,cAAc,CAACe,KAAK;YAC3BjB,QAAQ,EAAEA,QAAQ,CAACiB;UACrB,CAAC,CAAC;QACJ;QAEApB,SAAS,CAACoB,KAAI,GAAI,KAAK;MACzB,EAAE,OAAO4C,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;QACzD;QACA3D,cAAc,CAACe,KAAI,GAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QACnDpB,SAAS,CAACoB,KAAI,GAAI,KAAK;MACzB;IACF,CAAC;;IAED;IACA,MAAMyC,6BAA4B,GAAI,MAAAA,CAAA,KAAY;MAChD,IAAI;QACFC,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEpE,YAAY,CAACyB,KAAI,IAAK,WAAW,CAAC;QAC7EjB,QAAQ,CAACiB,KAAI,GAAI,EAAE,EAAE;;QAErB,MAAM6C,MAAK,GAAI,CAAC,CAAC;QACjB,IAAItE,YAAY,CAACyB,KAAK,EAAE;UACtB6C,MAAM,CAACP,IAAG,GAAI/D,YAAY,CAACyB,KAAK;QAClC;;QAEA;QACA,MAAM+B,QAAO,GAAI,MAAMlE,GAAG,CAACmE,GAAG,CAAC,WAAW,EAAE;UAC1Ca,MAAM;UACN1C,OAAO,EAAE;YAAE,eAAe,EAAE,UAAUb,KAAK,CAACU,KAAK;UAAG;QACtD,CAAC,CAAC;QAEF,IAAI+B,QAAQ,CAACpB,IAAG,IAAKO,KAAK,CAACC,OAAO,CAACY,QAAQ,CAACpB,IAAI,CAAC,EAAE;UACjD,MAAMsB,QAAO,GAAIF,QAAQ,CAACpB,IAAI;;UAE9B;UACA,IAAImC,cAAa,GAAI,EAAE;UAEvB,IAAIvE,YAAY,CAACyB,KAAK,EAAE;YACtB;YACA8C,cAAa,GAAI,CAAC,GAAG,IAAIX,GAAG,CAC1BF,QAAO,CACJM,MAAM,CAACF,OAAM,IAAKA,OAAO,CAACC,IAAG,KAAM/D,YAAY,CAACyB,KAAK,EACrDoC,GAAG,CAACC,OAAM,IAAKA,OAAO,CAACU,OAAO,CACnC,CAAC,CAAC,CAACR,MAAM,CAACxC,OAAO,CAAC;UACpB,OAAO;YACL;YACA+C,cAAa,GAAI,CAAC,GAAG,IAAIX,GAAG,CAC1BF,QAAQ,CAACG,GAAG,CAACC,OAAM,IAAKA,OAAO,CAACU,OAAO,CACzC,CAAC,CAAC,CAACR,MAAM,CAACxC,OAAO,CAAC;UACpB;UAEA2C,OAAO,CAACC,GAAG,CAAC,SAASG,cAAc,CAACzB,MAAM,iBAAiB9C,YAAY,CAACyB,KAAI,IAAK,WAAW,GAAG,EAAE8C,cAAc,CAAC;;UAEhH;UACA/D,QAAQ,CAACiB,KAAI,GAAI8C,cAAc,CAACV,GAAG,CAACY,WAAU,KAAM;YAClDC,EAAE,EAAED,WAAW;YACfhF,IAAI,EAAEgF,WAAW;YACjBE,WAAW,EAAE,EAAC,CAAE;UAClB,CAAC,CAAC,CAAC;QACL,OAAO;UACLR,OAAO,CAACS,IAAI,CAAC,iDAAiD,CAAC;UAC/DpE,QAAQ,CAACiB,KAAI,GAAI,EAAE;QACrB;MACF,EAAE,OAAO4C,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;QACzD7D,QAAQ,CAACiB,KAAI,GAAI,EAAE;MACrB;IACF,CAAC;;IAED;IACA,MAAMoD,mBAAkB,GAAI,MAAAA,CAAA,KAAY;MACtC,IAAI;QACFV,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAE;UAC/CL,IAAI,EAAE/D,YAAY,CAACyB,KAAI,IAAK,WAAW;UACvC+C,OAAO,EAAEvE,eAAe,CAACwB,KAAI,IAAK;QACpC,CAAC,CAAC;;QAEF;QACA,IAAIqD,oBAAmB,GAAI,EAAE;;QAE7B;QACA,IAAI;UACFX,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;UACvD,MAAMW,WAAU,GAAI;YAClBhB,IAAI,EAAE/D,YAAY,CAACyB,KAAK;YACxB+C,OAAO,EAAEvE,eAAe,CAACwB,KAAK;YAC9BuD,SAAS,EAAE9E,iBAAiB,CAACuB,KAAI,IAAKpC,MAAM,CAAC,CAAC,CAAC4F,QAAQ,CAAC,EAAE,EAAE,MAAM,CAAC,CAACrE,MAAM,CAAC,YAAY,CAAC;YACxFsE,OAAO,EAAE/E,eAAe,CAACsB,KAAI,IAAKpC,MAAM,CAAC,CAAC,CAACuB,MAAM,CAAC,YAAY;UAChE,CAAC;UAED,MAAMuE,aAAY,GAAI,MAAM7F,GAAG,CAACmE,GAAG,CAAC,kBAAkB,EAAE;YAAEa,MAAM,EAAES;UAAY,CAAC,CAAC;UAChF,IAAII,aAAa,CAAC/C,IAAG,IAAK+C,aAAa,CAAC/C,IAAI,CAACE,sBAAqB,IAC9D6C,aAAa,CAAC/C,IAAI,CAACE,sBAAsB,CAACC,IAAI,CAACC,GAAE,IAAKA,GAAE,GAAI,CAAC,CAAC,EAAE;YAClE2B,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAEe,aAAa,CAAC/C,IAAI,CAACE,sBAAsB,CAAC;YAC9F,OAAO6C,aAAa,CAAC/C,IAAI,CAACE,sBAAsB;UAClD;QACF,EAAE,OAAO+B,KAAK,EAAE;UACdF,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;QAChE;;QAEA;QACA,IAAI;UACFD,OAAO,CAACC,GAAG,CAAC,kEAAkE,CAAC;UAC/E;UACA,MAAMgB,YAAW,GAAI,EAAE;UACvB,MAAMC,KAAI,GAAI,EAAE;;UAEhB;UACA,KAAK,IAAIC,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;YAC1BD,KAAK,CAACE,IAAI,CAAClG,MAAM,CAAC,CAAC,CAAC4F,QAAQ,CAACK,CAAC,EAAE,MAAM,CAAC,CAAC1E,MAAM,CAAC,YAAY,CAAC,CAAC;UAC/D;UAEA,IAAIZ,YAAY,CAACyB,KAAI,IAAKxB,eAAe,CAACwB,KAAK,EAAE;YAC/C;YACA,KAAK,MAAM+D,IAAG,IAAKH,KAAK,EAAE;cACxBD,YAAY,CAACG,IAAI,CACfjG,GAAG,CAACmE,GAAG,CAAC,oBAAoB+B,IAAI,EAAE,EAAE;gBAClClB,MAAM,EAAE;kBACNP,IAAI,EAAE/D,YAAY,CAACyB,KAAK;kBACxB+C,OAAO,EAAEvE,eAAe,CAACwB;gBAC3B;cACF,CAAC,CACH,CAAC;YACH;UACF,OAAO,IAAIzB,YAAY,CAACyB,KAAK,EAAE;YAC7B;YACA,MAAM+B,QAAO,GAAI,MAAMlE,GAAG,CAACmE,GAAG,CAAC,WAAW,EAAE;cAC1Ca,MAAM,EAAE;gBAAEP,IAAI,EAAE/D,YAAY,CAACyB;cAAM;YACrC,CAAC,CAAC;YAEF,IAAIjB,QAAO,GAAI,EAAE;YACjB,IAAIgD,QAAQ,CAACpB,IAAG,IAAKO,KAAK,CAACC,OAAO,CAACY,QAAQ,CAACpB,IAAI,CAAC,EAAE;cACjD5B,QAAO,GAAI,CAAC,GAAG,IAAIoD,GAAG,CAACJ,QAAQ,CAACpB,IAAG,CAChC4B,MAAM,CAACF,OAAM,IAAKA,OAAO,CAACC,IAAG,KAAM/D,YAAY,CAACyB,KAAK,EACrDoC,GAAG,CAACC,OAAM,IAAKA,OAAO,CAACU,OAAO,CACjC,CAAC,CAAC,CAACR,MAAM,CAACxC,OAAO,CAAC;YACpB;;YAEA;YACA,IAAIhB,QAAQ,CAACsC,MAAK,KAAM,CAAC,EAAE;cACzB,KAAK,MAAM0C,IAAG,IAAKH,KAAK,EAAE;gBACxBD,YAAY,CAACG,IAAI,CACfjG,GAAG,CAACmE,GAAG,CAAC,oBAAoB+B,IAAI,EAAE,EAAE;kBAClClB,MAAM,EAAE;oBAAEP,IAAI,EAAE/D,YAAY,CAACyB;kBAAM;gBACrC,CAAC,CACH,CAAC;cACH;YACF,OAAO;cACL;cACA,KAAK,MAAM+D,IAAG,IAAKH,KAAK,EAAE;gBACxB,KAAK,MAAMb,OAAM,IAAKhE,QAAQ,EAAE;kBAC9B4E,YAAY,CAACG,IAAI,CACfjG,GAAG,CAACmE,GAAG,CAAC,oBAAoB+B,IAAI,EAAE,EAAE;oBAClClB,MAAM,EAAE;sBACNP,IAAI,EAAE/D,YAAY,CAACyB,KAAK;sBACxB+C;oBACF;kBACF,CAAC,CACH,CAAC;gBACH;cACF;YACF;UACF,OAAO;YACL;YACA;YACA,MAAMb,KAAI,GAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;;YAE1C;YACA,KAAK,MAAM6B,IAAG,IAAKH,KAAK,EAAE;cACxB,KAAK,MAAMtB,IAAG,IAAKJ,KAAK,EAAE;gBACxByB,YAAY,CAACG,IAAI,CACfjG,GAAG,CAACmE,GAAG,CAAC,oBAAoB+B,IAAI,EAAE,EAAE;kBAClClB,MAAM,EAAE;oBAAEP;kBAAK;gBACjB,CAAC,CACH,CAAC;cACH;YACF;UACF;;UAEA;UACA,MAAM0B,WAAU,GAAI,MAAMC,OAAO,CAACC,UAAU,CAACP,YAAY,CAAC;;UAE1D;UACAK,WAAW,CAACG,OAAO,CAACC,MAAK,IAAK;YAC5B,IAAIA,MAAM,CAACC,MAAK,KAAM,WAAU,IAAKD,MAAM,CAACpE,KAAK,EAAEW,IAAG,IAAKO,KAAK,CAACC,OAAO,CAACiD,MAAM,CAACpE,KAAK,CAACW,IAAI,CAAC,EAAE;cAC3F;cACA,MAAM2D,OAAM,GAAIF,MAAM,CAACpE,KAAK,CAACW,IAAI;cACjC,IAAIpC,YAAY,CAACyB,KAAK,EAAE;gBACtB,MAAMuE,eAAc,GAAID,OAAO,CAAC/B,MAAM,CAACiC,MAAK,IAAK;kBAC/C;kBACA,OAAOA,MAAM,CAAClC,IAAG,KAAM/D,YAAY,CAACyB,KAAI,IAChCwE,MAAM,CAACC,aAAY,IAAKD,MAAM,CAACC,aAAa,CAAC,CAAC,CAAC,EAAEnC,IAAG,KAAM/D,YAAY,CAACyB,KAAM;gBACvF,CAAC,CAAC;gBACFqD,oBAAmB,GAAI,CAAC,GAAGA,oBAAoB,EAAE,GAAGkB,eAAe,CAAC;cACtE,OAAO;gBACLlB,oBAAmB,GAAI,CAAC,GAAGA,oBAAoB,EAAE,GAAGiB,OAAO,CAAC;cAC9D;YACF;UACF,CAAC,CAAC;UAEF5B,OAAO,CAACC,GAAG,CAAC,aAAaU,oBAAoB,CAAChC,MAAM,uCAAuC,CAAC;QAC9F,EAAE,OAAOuB,KAAK,EAAE;UACdF,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAEC,KAAK,CAAC8B,OAAO,CAAC;QAClE;;QAEA;QACA,IAAIrB,oBAAoB,CAAChC,MAAK,GAAI,CAAC,EAAE;UACnC;UACA,MAAMsD,gBAAe,GAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;;UAEpCtB,oBAAoB,CAACc,OAAO,CAACK,MAAK,IAAK;YACrC,IAAIA,MAAM,CAACH,MAAK,KAAM,SAAS,EAAEM,gBAAgB,CAAC,CAAC,CAAC,EAAE,MACjD,IAAIH,MAAM,CAACH,MAAK,KAAM,MAAM,EAAEM,gBAAgB,CAAC,CAAC,CAAC,EAAE,MACnD,IAAIH,MAAM,CAACH,MAAK,KAAM,QAAQ,EAAEM,gBAAgB,CAAC,CAAC,CAAC,EAAE;UAC5D,CAAC,CAAC;UAEFjC,OAAO,CAACC,GAAG,CAAC,4CAA4C,EAAEgC,gBAAgB,CAAC;UAC3E,OAAOA,gBAAgB;QACzB;;QAEA;QACA,IAAI;UACFjC,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;;UAE1D;UACA,MAAME,MAAK,GAAI;YACbP,IAAI,EAAE/D,YAAY,CAACyB;UACrB,CAAC;UAED,IAAIxB,eAAe,CAACwB,KAAK,EAAE;YACzB6C,MAAM,CAACE,OAAM,GAAIvE,eAAe,CAACwB,KAAK;UACxC;;UAEA;UACA,IAAI;YACF,MAAM0D,aAAY,GAAI,MAAM7F,GAAG,CAACmE,GAAG,CAAC,kBAAkB,EAAE;cAAEa;YAAO,CAAC,CAAC;YACnE,IAAIa,aAAa,CAAC/C,IAAG,IAAK+C,aAAa,CAAC/C,IAAI,CAACE,sBAAqB,IAC9D6C,aAAa,CAAC/C,IAAI,CAACE,sBAAsB,CAACC,IAAI,CAACC,GAAE,IAAKA,GAAE,GAAI,CAAC,CAAC,EAAE;cAClE2B,OAAO,CAACC,GAAG,CAAC,yCAAyC,EAAEe,aAAa,CAAC/C,IAAI,CAACE,sBAAsB,CAAC;cACjG,OAAO6C,aAAa,CAAC/C,IAAI,CAACE,sBAAsB;YAClD;UACF,EAAE,OAAO+B,KAAK,EAAE;YACdF,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAEC,KAAK,CAAC8B,OAAO,CAAC;UACtD;QACF,EAAE,OAAO9B,KAAK,EAAE;UACdF,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAEC,KAAK,CAAC8B,OAAO,CAAC;QAC/D;;QAEA;QACAhC,OAAO,CAACC,GAAG,CAAC,4CAA4C,CAAC;QACzD,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAClB,EAAE,OAAOC,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;QAC1D,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;MACpB;IACF,CAAC;IAED,MAAMgC,kBAAiB,GAAI,MAAAA,CAAA,KAAY;MACrC,IAAI;QACFhG,SAAS,CAACoB,KAAI,GAAI,IAAI;;QAEtB;QACA,MAAM6C,MAAK,GAAI;UACbP,IAAI,EAAE/D,YAAY,CAACyB,KAAK;UACxB+C,OAAO,EAAEvE,eAAe,CAACwB,KAAK;UAC9BuD,SAAS,EAAE9E,iBAAiB,CAACuB,KAAK;UAClCyD,OAAO,EAAE/E,eAAe,CAACsB;QAC3B,CAAC;QAED0C,OAAO,CAACC,GAAG,CAAC,sCAAsC,EAAEE,MAAM,CAAC;;QAE3D;QACA,MAAMhC,sBAAqB,GAAI,MAAMuC,mBAAmB,CAAC,CAAC;QAC1DV,OAAO,CAACC,GAAG,CAAC,8CAA8C,EAAE9B,sBAAsB,CAAC;;QAEnF;QACA,MAAM6C,aAAY,GAAI,MAAM7F,GAAG,CAACmE,GAAG,CAAC,kBAAkB,EAAE;UAAEa;QAAO,CAAC,CAAC;QAEnElC,IAAI,CAACX,KAAI,GAAI0D,aAAa,CAAC/C,IAAG,IAAK,CAAC,CAAC;QACrC+B,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEhC,IAAI,CAACX,KAAK,CAAC;;QAEpD;QACA,MAAM6E,YAAW,GACdlE,IAAI,CAACX,KAAK,CAACM,aAAY,GAAI,CAAC,IAC5BK,IAAI,CAACX,KAAK,CAACO,aAAY,GAAI,CAAC,IAC5BI,IAAI,CAACX,KAAK,CAACU,cAAa,GAAI,CAAC,IAC7BC,IAAI,CAACX,KAAK,CAACoB,iBAAgB,IAAKT,IAAI,CAACX,KAAK,CAACoB,iBAAiB,CAACC,MAAK,GAAI,CAAE;;QAE3E;QACA,IAAI,CAACwD,YAAW,KAAMtG,YAAY,CAACyB,KAAI,IAAKxB,eAAe,CAACwB,KAAK,CAAC,EAAE;UAClE0C,OAAO,CAACS,IAAI,CAAC,wCAAwC,CAAC;QACxD;;QAEA;QACA7C,aAAa,CAACN,KAAI,GAAIW,IAAI,CAACX,KAAK,CAACM,aAAY,IAAK,CAAC;QACnDC,aAAa,CAACP,KAAI,GAAIW,IAAI,CAACX,KAAK,CAACO,aAAY,IAAK,CAAC;QACnDG,cAAc,CAACV,KAAI,GAAIW,IAAI,CAACX,KAAK,CAACU,cAAa,IAAK,CAAC;;QAErD;QACAC,IAAI,CAACX,KAAK,CAACa,sBAAqB,GAAIA,sBAAsB;;QAE1D;QACA,MAAMiE,eAAc,GAAIjE,sBAAsB,CAACkE,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAA,GAAIC,CAAC,EAAE,CAAC,CAAC;QACzE,IAAIH,eAAc,GAAI,CAAC,EAAE;UACvB;UACA,MAAMI,iBAAgB,GAAIrE,sBAAsB,CAAC,CAAC,IAAIA,sBAAsB,CAAC,CAAC,CAAC;UAC/EL,iBAAiB,CAACR,KAAI,GAAImF,IAAI,CAACC,KAAK,CAAEF,iBAAgB,GAAIJ,eAAe,GAAI,GAAG,CAAC;QACnF,OAAO;UACLtE,iBAAiB,CAACR,KAAI,GAAI,CAAC;QAC7B;;QAEA;QACA,MAAMqF,mBAAmB,CAAC,CAAC;;QAE3B;QACA,IAAI1E,IAAI,CAACX,KAAK,CAACuB,eAAc,IAAKL,KAAK,CAACC,OAAO,CAACR,IAAI,CAACX,KAAK,CAACuB,eAAe,CAAC,EAAE;UAC3E,IAAI+D,UAAS,GAAI,CAAC;UAClB,IAAIC,UAAS,GAAI,CAAC;UAElB5E,IAAI,CAACX,KAAK,CAACuB,eAAe,CAAC4C,OAAO,CAACzC,IAAG,IAAK;YACzC,IAAIA,IAAI,CAACjB,YAAW,GAAI,KAAKiB,IAAI,CAACC,KAAI,GAAI,CAAC,EAAE;cAC3C2D,UAAS,IAAK5D,IAAI,CAACjB,YAAW,GAAIiB,IAAI,CAACC,KAAK;cAC5C4D,UAAS,IAAK7D,IAAI,CAACC,KAAK;YAC1B;UACF,CAAC,CAAC;UAEF,IAAI4D,UAAS,GAAI,CAAC,EAAE;YAClB9E,YAAY,CAACT,KAAI,GAAImF,IAAI,CAACC,KAAK,CAACE,UAAS,GAAIC,UAAU,CAAC;YACxD5E,IAAI,CAACX,KAAK,CAACS,YAAW,GAAIA,YAAY,CAACT,KAAK;UAC9C,OAAO;YACLS,YAAY,CAACT,KAAI,GAAI,CAAC;YACtBW,IAAI,CAACX,KAAK,CAACS,YAAW,GAAI,CAAC;UAC7B;UAEAiC,OAAO,CAACC,GAAG,CAAC,6BAA6BlC,YAAY,CAACT,KAAK,UAAUuF,UAAU,cAAc,CAAC;QAChG,OAAO;UACL9E,YAAY,CAACT,KAAI,GAAI,CAAC;UACtBW,IAAI,CAACX,KAAK,CAACS,YAAW,GAAI,CAAC;QAC7B;;QAEA;QACA+E,YAAY,CAAC7E,IAAI,CAACX,KAAK,CAAC;QAExBnB,UAAU,CAACmB,KAAI,GAAI,IAAIyF,IAAI,CAAC,CAAC;MAC/B,EAAE,OAAO7C,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;QACvD,IAAIA,KAAK,CAACb,QAAQ,EAAE;UAClBW,OAAO,CAACE,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAACb,QAAQ,CAACpB,IAAI,CAAC;QACvD;;QAEA;QACAA,IAAI,CAACX,KAAI,GAAI;UACXM,aAAa,EAAE,CAAC;UAChBC,aAAa,EAAE,CAAC;UAChBG,cAAc,EAAE,CAAC;UACjBG,sBAAsB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UACjCL,iBAAiB,EAAE,CAAC;UACpBe,eAAe,EAAE,EAAE;UACnBH,iBAAiB,EAAE,EAAE;UACrBX,YAAY,EAAE,CAAC;UACf1B,QAAQ,EAAE;QACZ,CAAC;QAEDuB,aAAa,CAACN,KAAI,GAAI,CAAC;QACvBO,aAAa,CAACP,KAAI,GAAI,CAAC;QACvBU,cAAc,CAACV,KAAI,GAAI,CAAC;QACxBQ,iBAAiB,CAACR,KAAI,GAAI,CAAC;QAC3BS,YAAY,CAACT,KAAI,GAAI,CAAC;;QAEtB;QACAwF,YAAY,CAAC7E,IAAI,CAACX,KAAK,CAAC;MAC1B,UAAU;QACRpB,SAAS,CAACoB,KAAI,GAAI,KAAK;MACzB;IACF,CAAC;;IAED;IACA,MAAMqF,mBAAkB,GAAI,MAAAA,CAAA,KAAY;MACtC,IAAI;QACF;QACA,MAAMK,gBAAe,GAAI;UACvBpD,IAAI,EAAE/D,YAAY,CAACyB,KAAK;UACxB+C,OAAO,EAAEvE,eAAe,CAACwB,KAAK;UAC9BuD,SAAS,EAAE9E,iBAAiB,CAACuB,KAAI,IAAKpC,MAAM,CAAC,CAAC,CAAC4F,QAAQ,CAAC,EAAE,EAAE,MAAM,CAAC,CAACrE,MAAM,CAAC,YAAY,CAAC;UACxFsE,OAAO,EAAE/E,eAAe,CAACsB,KAAI,IAAKpC,MAAM,CAAC,CAAC,CAACuB,MAAM,CAAC,YAAY;QAChE,CAAC;QAEDuD,OAAO,CAACC,GAAG,CAAC,uCAAuC,EAAE+C,gBAAgB,CAAC;;QAEtE;QACA,MAAMC,kBAAiB,GAAI,MAAM9H,GAAG,CAACmE,GAAG,CAAC,cAAc,EAAE;UACvDa,MAAM,EAAE6C;QACV,CAAC,CAAC;QAEFhD,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEgD,kBAAkB,CAAChF,IAAI,EAAEU,MAAK,IAAK,CAAC,CAAC;QAEnF,IAAIsE,kBAAkB,CAAChF,IAAG,IAAKO,KAAK,CAACC,OAAO,CAACwE,kBAAkB,CAAChF,IAAI,CAAC,EAAE;UACrE,IAAIiF,WAAU,GAAID,kBAAkB,CAAChF,IAAI;;UAEzC;UACA,IAAIpC,YAAY,CAACyB,KAAK,EAAE;YACtB4F,WAAU,GAAIA,WAAW,CAACrD,MAAM,CAACsD,UAAS,IAAK;cAC7C;cACA,OAAQA,UAAU,CAACvD,IAAG,KAAM/D,YAAY,CAACyB,KAAK,IACtC6F,UAAU,CAAC5D,QAAO,IAAK4D,UAAU,CAAC5D,QAAQ,CAAC,CAAC,CAAC,EAAEK,IAAG,KAAM/D,YAAY,CAACyB,KAAM;YACrF,CAAC,CAAC;YAEF0C,OAAO,CAACC,GAAG,CAAC,yBAAyBiD,WAAW,CAACvE,MAAM,2BAA2B9C,YAAY,CAACyB,KAAK,EAAE,CAAC;UACzG;;UAEA;UACA,MAAMuB,eAAc,GAAI;YACtB,MAAM,EAAE;cAAEI,KAAK,EAAE,CAAC;cAAE2D,UAAU,EAAE,CAAC;cAAEQ,MAAM,EAAE;YAAG,CAAC;YAC/C,UAAU,EAAE;cAAEnE,KAAK,EAAE,CAAC;cAAE2D,UAAU,EAAE,CAAC;cAAEQ,MAAM,EAAE;YAAG,CAAC;YACnD,kBAAkB,EAAE;cAAEnE,KAAK,EAAE,CAAC;cAAE2D,UAAU,EAAE,CAAC;cAAEQ,MAAM,EAAE;YAAG;UAC5D,CAAC;;UAED;UACAF,WAAW,CAACzB,OAAO,CAAC0B,UAAS,IAAK;YAChC,MAAMnE,IAAG,GAAImE,UAAU,CAACnE,IAAG,IAAK,OAAO;YACvC,IAAIH,eAAe,CAACG,IAAI,CAAC,EAAE;cACzBH,eAAe,CAACG,IAAI,CAAC,CAACC,KAAK,EAAE;;cAE7B;cACA,IAAIkE,UAAU,CAACC,MAAM,EAAE;gBACrB;gBACA,IAAIC,UAAS,GAAI,EAAE;gBACnB,IAAI7E,KAAK,CAACC,OAAO,CAAC0E,UAAU,CAACC,MAAM,CAAC,EAAE;kBACpCC,UAAS,GAAIF,UAAU,CAACC,MAAM;gBAChC,OAAO,IAAID,UAAU,CAACC,MAAK,YAAaE,GAAG,EAAE;kBAC3CD,UAAS,GAAI7E,KAAK,CAAC+E,IAAI,CAACJ,UAAU,CAACC,MAAM,CAACrE,MAAM,CAAC,CAAC,CAAC;gBACrD,OAAO,IAAI,OAAOoE,UAAU,CAACC,MAAK,KAAM,QAAQ,EAAE;kBAChD;kBACAC,UAAS,GAAIvE,MAAM,CAACC,MAAM,CAACoE,UAAU,CAACC,MAAM,CAAC;gBAC/C;gBAEAC,UAAU,CAAC5B,OAAO,CAAC+B,KAAI,IAAK;kBAC1B,IAAI,OAAOA,KAAI,KAAM,QAAQ,EAAE;oBAC7B,MAAMC,UAAS,GAAIN,UAAU,CAACO,QAAO,GAAKF,KAAI,GAAIL,UAAU,CAACO,QAAQ,GAAI,GAAE,GAAIF,KAAK;oBACpF3E,eAAe,CAACG,IAAI,CAAC,CAAC4D,UAAS,IAAKa,UAAU;oBAC9C5E,eAAe,CAACG,IAAI,CAAC,CAACoE,MAAM,CAAChC,IAAI,CAACqC,UAAU,CAAC;kBAC/C;gBACF,CAAC,CAAC;cACJ;YACF;UACF,CAAC,CAAC;;UAEF;UACAxF,IAAI,CAACX,KAAK,CAACuB,eAAc,GAAIC,MAAM,CAAC6E,IAAI,CAAC9E,eAAe,CAAC,CAACa,GAAG,CAACV,IAAG,IAAK;YACpE,MAAM4E,QAAO,GAAI/E,eAAe,CAACG,IAAI,CAAC;YACtC,MAAMjB,YAAW,GAAI6F,QAAQ,CAACR,MAAM,CAACzE,MAAK,GAAI,IAC1CiF,QAAQ,CAAChB,UAAS,GAAIgB,QAAQ,CAACR,MAAM,CAACzE,MAAK,GAC3C,CAAC;YAEL,OAAO;cACLK,IAAI;cACJjB,YAAY,EAAE0E,IAAI,CAACC,KAAK,CAAC3E,YAAY,CAAC;cACtCkB,KAAK,EAAE2E,QAAQ,CAAC3E,KAAK;cACrB4E,cAAc,EAAED,QAAQ,CAAC3E,KAAI,GAAI,IAAI,GAAE,GAAI;YAC7C,CAAC;UACH,CAAC,CAAC;;UAEF;UACAhB,IAAI,CAACX,KAAK,CAACoB,iBAAgB,GAAIwE,WAAU,CACtCrD,MAAM,CAACyC,CAAA,IAAKA,CAAC,CAACjB,IAAI,EAAE;UAAA,CACpBvB,IAAI,CAAC,CAACwC,CAAC,EAAEC,CAAC,KAAK,IAAIQ,IAAI,CAACT,CAAC,CAACjB,IAAI,IAAI,IAAI0B,IAAI,CAACR,CAAC,CAAClB,IAAI,CAAC,EAAE;UAAA,CACpD3B,GAAG,CAACyD,UAAS,IAAK;YACjB;YACA,IAAIpF,YAAW,GAAI,CAAC;YACpB,IAAIsF,UAAS,GAAI,EAAE;;YAEnB;YACA,IAAIF,UAAU,CAACC,MAAM,EAAE;cACrB,IAAI5E,KAAK,CAACC,OAAO,CAAC0E,UAAU,CAACC,MAAM,CAAC,EAAE;gBACpCC,UAAS,GAAIF,UAAU,CAACC,MAAM;cAChC,OAAO,IAAID,UAAU,CAACC,MAAK,YAAaE,GAAG,EAAE;gBAC3CD,UAAS,GAAI7E,KAAK,CAAC+E,IAAI,CAACJ,UAAU,CAACC,MAAM,CAACrE,MAAM,CAAC,CAAC,CAAC;cACrD,OAAO,IAAI,OAAOoE,UAAU,CAACC,MAAK,KAAM,QAAQ,EAAE;gBAChDC,UAAS,GAAIvE,MAAM,CAACC,MAAM,CAACoE,UAAU,CAACC,MAAM,CAAC;cAC/C;;cAEA;cACA,MAAMU,WAAU,GAAIT,UAAU,CAACxD,MAAM,CAAC2D,KAAI,IAAK,OAAOA,KAAI,KAAM,QAAQ,CAAC;cACzE,IAAIM,WAAW,CAACnF,MAAK,GAAI,CAAC,EAAE;gBAC1B,MAAMiE,UAAS,GAAIkB,WAAW,CAACzB,MAAM,CAAC,CAAC0B,GAAG,EAAEP,KAAK,KAAKO,GAAE,GAAIP,KAAK,EAAE,CAAC,CAAC;gBACrEzF,YAAW,GAAIoF,UAAU,CAACO,QAAO,GAC5Bd,UAAS,GAAIkB,WAAW,CAACnF,MAAK,GAAIwE,UAAU,CAACO,QAAQ,GAAI,GAAE,GAC5Dd,UAAS,GAAIkB,WAAW,CAACnF,MAAM;cACrC;YACF;YAEA,OAAO;cACL0C,IAAI,EAAE8B,UAAU,CAAC9B,IAAI;cACrB2C,KAAK,EAAEb,UAAU,CAAC7H,IAAG,IAAK6H,UAAU,CAACnE,IAAI;cACzCjB,YAAY,EAAE0E,IAAI,CAACC,KAAK,CAAC3E,YAAY,CAAC;cACtCiB,IAAI,EAAEmE,UAAU,CAACnE;YACnB,CAAC;UACH,CAAC,CAAC;UAEJgB,OAAO,CAACC,GAAG,CAAC,+BAA+BpE,YAAY,CAACyB,KAAI,IAAK,WAAW,KAAKW,IAAI,CAACX,KAAK,CAACoB,iBAAiB,CAACC,MAAM,UAAU,CAAC;;UAE/H;UACA;UACA,MAAMsF,kBAAiB,GAAI,CAAC,CAAC;;UAE7B;UACA,IAAIf,WAAW,CAACvE,MAAK,GAAI,CAAC,EAAE;YAC1BuE,WAAW,CAACzB,OAAO,CAAC0B,UAAS,IAAK;cAChC,IAAIA,UAAU,CAAC9C,OAAO,EAAE;gBACtB,IAAI,CAAC4D,kBAAkB,CAACd,UAAU,CAAC9C,OAAO,CAAC,EAAE;kBAC3C4D,kBAAkB,CAACd,UAAU,CAAC9C,OAAO,IAAI;oBACvCuC,UAAU,EAAE,CAAC;oBACbsB,UAAU,EAAE,CAAC;oBACbC,eAAe,EAAE,CAAC;oBAClBC,eAAe,EAAE;kBACnB,CAAC;gBACH;;gBAEA;gBACA,IAAIf,UAAS,GAAI,EAAE;gBACnB,IAAIF,UAAU,CAACC,MAAM,EAAE;kBACrB,IAAI5E,KAAK,CAACC,OAAO,CAAC0E,UAAU,CAACC,MAAM,CAAC,EAAE;oBACpCC,UAAS,GAAIF,UAAU,CAACC,MAAM;kBAChC,OAAO,IAAID,UAAU,CAACC,MAAK,YAAaE,GAAG,EAAE;oBAC3CD,UAAS,GAAI7E,KAAK,CAAC+E,IAAI,CAACJ,UAAU,CAACC,MAAM,CAACrE,MAAM,CAAC,CAAC,CAAC;kBACrD,OAAO,IAAI,OAAOoE,UAAU,CAACC,MAAK,KAAM,QAAQ,EAAE;oBAChDC,UAAS,GAAIvE,MAAM,CAACC,MAAM,CAACoE,UAAU,CAACC,MAAM,CAAC;kBAC/C;kBAEAC,UAAU,CAAC5B,OAAO,CAAC+B,KAAI,IAAK;oBAC1B,IAAI,OAAOA,KAAI,KAAM,QAAQ,EAAE;sBAC7B,MAAMC,UAAS,GAAIN,UAAU,CAACO,QAAO,GAAKF,KAAI,GAAIL,UAAU,CAACO,QAAQ,GAAI,GAAE,GAAIF,KAAK;sBACpFS,kBAAkB,CAACd,UAAU,CAAC9C,OAAO,CAAC,CAACuC,UAAS,IAAKa,UAAU;sBAC/DQ,kBAAkB,CAACd,UAAU,CAAC9C,OAAO,CAAC,CAAC6D,UAAU,EAAE;oBACrD;kBACF,CAAC,CAAC;gBACJ;cACF;YACF,CAAC,CAAC;;YAEF;YACA,IAAIpF,MAAM,CAAC6E,IAAI,CAACM,kBAAkB,CAAC,CAACtF,MAAK,GAAI,CAAC,EAAE;cAC9CV,IAAI,CAACX,KAAK,CAACjB,QAAO,GAAIyC,MAAM,CAAC6E,IAAI,CAACM,kBAAkB,CAAC,CAACvE,GAAG,CAACY,WAAU,IAAK;gBACvE,MAAMD,OAAM,GAAI4D,kBAAkB,CAAC3D,WAAW,CAAC;gBAC/C,MAAMvC,YAAW,GAAIsC,OAAO,CAAC6D,UAAS,GAAI,IACtC7D,OAAO,CAACuC,UAAS,GAAIvC,OAAO,CAAC6D,UAAS,GACtC,CAAC;gBAEL,OAAO;kBACL5I,IAAI,EAAEgF,WAAW;kBACjBvC,YAAY,EAAE0E,IAAI,CAACC,KAAK,CAAC3E,YAAY,CAAC;kBACtCsG,cAAc,EAAE,CAAC;kBAAE;kBACnBC,WAAW,EAAE7B,IAAI,CAACC,KAAK,CAAC3E,YAAY,EAAE;gBACxC,CAAC;cACH,CAAC,CAAC;YACJ;UACF;QACF;MACF,EAAE,OAAOmC,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;QACvD;QACAjC,IAAI,CAACX,KAAK,CAACuB,eAAc,GAAI,CAC3B;UAAEG,IAAI,EAAE,MAAM;UAAEjB,YAAY,EAAE,CAAC;UAAEkB,KAAK,EAAE;QAAE,CAAC,EAC3C;UAAED,IAAI,EAAE,UAAU;UAAEjB,YAAY,EAAE,CAAC;UAAEkB,KAAK,EAAE;QAAE,CAAC,EAC/C;UAAED,IAAI,EAAE,kBAAkB;UAAEjB,YAAY,EAAE,CAAC;UAAEkB,KAAK,EAAE;QAAE,EACvD;QACDhB,IAAI,CAACX,KAAK,CAACoB,iBAAgB,GAAI,EAAE;QACjCT,IAAI,CAACX,KAAK,CAACjB,QAAO,GAAI,EAAE;MAC1B;IACF,CAAC;IAED,MAAMyG,YAAW,GAAK7E,IAAI,IAAK;MAC7BsG,sBAAsB,CAACtG,IAAI,CAAC;MAC5BuG,yBAAyB,CAACvG,IAAI,CAAC;MAC/BwG,2BAA2B,CAACxG,IAAI,CAAC;MACjCyG,oCAAoC,CAACzG,IAAI,CAAC;IAC5C,CAAC;;IAED;IACA,MAAM0G,eAAc,GAAIA,CAAA,KAAM;MAC5B;MACA,MAAMC,MAAK,GAAI,CACbnJ,gBAAgB,CAAC6B,KAAK,EACtB5B,mBAAmB,CAAC4B,KAAK,EACzB3B,qBAAqB,CAAC2B,KAAK,EAC3B1B,8BAA8B,CAAC0B,KAAI,CACpC;;MAED;MACAsH,MAAM,CAACnD,OAAO,CAACoD,MAAK,IAAK;QACvB,IAAIA,MAAM,EAAE;UACV,MAAMC,GAAE,GAAID,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;UACnC,IAAID,GAAG,EAAE;YACP,MAAME,aAAY,GAAIhK,KAAK,CAACiK,QAAQ,CAACH,GAAG,CAAC;YACzC,IAAIE,aAAa,EAAE;cACjBA,aAAa,CAACE,OAAO,CAAC,CAAC;YACzB;UACF;QACF;MACF,CAAC,CAAC;;MAEF;MACA,MAAMC,SAAQ,GAAI;QAChBvH,aAAa,EAAE,CAAC;QAChBC,aAAa,EAAE,CAAC;QAChBG,cAAc,EAAE,CAAC;QACjBF,iBAAiB,EAAE,CAAC;QACpBC,YAAY,EAAE,CAAC;QACfI,sBAAsB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACjCU,eAAe,EAAE,CACf;UAAEG,IAAI,EAAE,MAAM;UAAEjB,YAAY,EAAE,CAAC;UAAEkB,KAAK,EAAE;QAAE,CAAC,EAC3C;UAAED,IAAI,EAAE,UAAU;UAAEjB,YAAY,EAAE,CAAC;UAAEkB,KAAK,EAAE;QAAE,CAAC,EAC/C;UAAED,IAAI,EAAE,kBAAkB;UAAEjB,YAAY,EAAE,CAAC;UAAEkB,KAAK,EAAE;QAAE,EACvD;QACDP,iBAAiB,EAAE,EAAE;QACrBrC,QAAQ,EAAE;MACZ,CAAC;;MAED;MACAyG,YAAY,CAACqC,SAAS,CAAC;IACzB,CAAC;;IAED;IACA,MAAMC,UAAS,GAAK/D,IAAI,IAAK;MAC3B,IAAI,CAACA,IAAI,EAAE,OAAO,EAAE;MACpB,OAAOnG,MAAM,CAACmG,IAAI,CAAC,CAAC5E,MAAM,CAAC,qBAAqB,CAAC;IACnD,CAAC;;IAED;IACA,MAAM4I,gBAAe,GAAI,MAAAA,CAAA,KAAY;MACnCrF,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEpE,YAAY,CAACyB,KAAK,CAAC;;MAEnD;MACAxB,eAAe,CAACwB,KAAI,GAAI,EAAE;;MAE1B;MACA,MAAMyC,6BAA6B,CAAC,CAAC;;MAErC;MACA,MAAMmC,kBAAkB,CAAC,CAAC;IAC5B,CAAC;;IAED;IACA,MAAMoD,mBAAkB,GAAI,MAAAA,CAAA,KAAY;MACtC;MACApD,kBAAkB,CAAC,CAAC;IACtB,CAAC;;IAED;IACA,MAAMqD,kBAAiB,GAAIA,CAAA,KAAM;MAC/BrD,kBAAkB,CAAC,CAAC;IACtB,CAAC;;IAED;IACA,MAAMsD,YAAW,GAAIA,CAAA,KAAM;MACzBxF,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;;MAEnC;MACApE,YAAY,CAACyB,KAAI,GAAI,EAAE;MACvBxB,eAAe,CAACwB,KAAI,GAAI,EAAE;MAC1BvB,iBAAiB,CAACuB,KAAI,GAAI,EAAE;MAC5BtB,eAAe,CAACsB,KAAI,GAAI,EAAE;;MAE1B;MACAjB,QAAQ,CAACiB,KAAI,GAAI,EAAE;;MAEnB;MACA8B,qBAAqB,CAAC,CAAC,CAACqG,IAAI,CAAC,MAAM;QACjCzF,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;QACnEiC,kBAAkB,CAAC,CAAC;MACtB,CAAC,CAAC;IACJ,CAAC;;IAED;IACA,MAAMwD,gBAAe,GAAIA,CAAA,KAAM;MAC7B,MAAMC,OAAM,GAAI,EAAC;MACjB,IAAI9J,YAAY,CAACyB,KAAK,EAAEqI,OAAO,CAACvE,IAAI,CAACvF,YAAY,CAACyB,KAAK;MACvD,IAAIxB,eAAe,CAACwB,KAAK,EAAEqI,OAAO,CAACvE,IAAI,CAACtF,eAAe,CAACwB,KAAK;;MAE7D;MACA,IAAIvB,iBAAiB,CAACuB,KAAI,IAAKtB,eAAe,CAACsB,KAAK,EAAE;QACpD,MAAMsI,cAAa,GAAI1K,MAAM,CAACa,iBAAiB,CAACuB,KAAK,CAAC,CAACb,MAAM,CAAC,OAAO;QACrE,MAAMoJ,YAAW,GAAI3K,MAAM,CAACc,eAAe,CAACsB,KAAK,CAAC,CAACb,MAAM,CAAC,aAAa;QACvEkJ,OAAO,CAACvE,IAAI,CAAC,GAAGwE,cAAc,MAAMC,YAAY,EAAE;MACpD,OAAO,IAAI9J,iBAAiB,CAACuB,KAAK,EAAE;QAClCqI,OAAO,CAACvE,IAAI,CAAC,QAAQlG,MAAM,CAACa,iBAAiB,CAACuB,KAAK,CAAC,CAACb,MAAM,CAAC,aAAa,CAAC,EAAE;MAC9E,OAAO,IAAIT,eAAe,CAACsB,KAAK,EAAE;QAChCqI,OAAO,CAACvE,IAAI,CAAC,SAASlG,MAAM,CAACc,eAAe,CAACsB,KAAK,CAAC,CAACb,MAAM,CAAC,aAAa,CAAC,EAAE;MAC7E;MAEA,OAAOkJ,OAAO,CAAChH,MAAK,GAAI,IAAIgH,OAAO,CAACG,IAAI,CAAC,KAAK,IAAI,aAAY;IAChE,CAAC;;IAED;IACA,MAAMvB,sBAAqB,GAAKtG,IAAI,IAAK;MACvC,IAAI,CAACxC,gBAAgB,CAAC6B,KAAK,EAAE;MAE7B,MAAMwH,GAAE,GAAIrJ,gBAAgB,CAAC6B,KAAK,CAACyH,UAAU,CAAC,IAAI,CAAC;MACnD,IAAI,CAACD,GAAG,EAAE;;MAEV;MACA,MAAME,aAAY,GAAIhK,KAAK,CAACiK,QAAQ,CAACH,GAAG,CAAC;MACzC,IAAIE,aAAa,EAAEA,aAAa,CAACE,OAAO,CAAC,CAAC;;MAE1C;MACA,MAAMa,gBAAe,GAAI,CAAC,SAAS,EAAE,MAAM,EAAE,QAAQ,CAAC;MACtD,IAAIC,cAAa,GAAI/H,IAAI,CAACE,sBAAqB,IAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;MAE7D;MACA,MAAM8H,oBAAmB,GAAID,cAAc,CAAC3D,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAA,GAAIC,CAAC,EAAE,CAAC,CAAC;MACtE,IAAI0D,oBAAmB,KAAM,CAAC,EAAE;QAC9B;QACAD,cAAa,GAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC5B;;MAEA;MACAhG,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAE+F,cAAc,CAAC;;MAElE;MACA,IAAIhL,KAAK,CAAC8J,GAAG,EAAE;QACb9F,IAAI,EAAE,UAAU;QAChBf,IAAI,EAAE;UACJiI,MAAM,EAAEH,gBAAgB;UACxBI,QAAQ,EAAE,CAAC;YACTlI,IAAI,EAAE+H,cAAc;YACpBI,eAAe,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC;YAClDC,WAAW,EAAE,CAAC;YACdC,WAAW,EAAE;UACf,CAAC;QACH,CAAC;QACDC,OAAO,EAAE;UACPC,UAAU,EAAE,IAAI;UAChBC,mBAAmB,EAAE,KAAK;UAC1BC,MAAM,EAAE,KAAK;UACXC,OAAO,EAAE;YACPC,MAAM,EAAE;cACRC,QAAQ,EAAE,QAAQ;cAChBX,MAAM,EAAE;gBACNY,aAAa,EAAE,IAAI;gBACrBC,OAAO,EAAE,EAAE;gBACTC,IAAI,EAAE;kBACJC,IAAI,EAAE;gBACR;cACF;YACF,CAAC;YACDC,OAAO,EAAE;cACPC,SAAS,EAAE;gBACTC,KAAK,EAAE,SAAAA,CAASC,OAAO,EAAE;kBACzB,MAAMD,KAAI,GAAIC,OAAO,CAACD,KAAI,IAAK,EAAE;kBACjC,MAAM9J,KAAI,GAAI+J,OAAO,CAACC,GAAE,IAAK,CAAC;kBAC9B,MAAMC,KAAI,GAAIF,OAAO,CAACG,KAAK,CAACvJ,IAAI,CAACkI,QAAQ,CAAC,CAAC,CAAC,CAAClI,IAAI,CAACoE,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAA,GAAIC,CAAC,EAAE,CAAC,CAAC;kBAC5E,MAAMkB,UAAS,GAAI8D,KAAI,GAAI,IAAI9E,IAAI,CAACC,KAAK,CAAEpF,KAAI,GAAIiK,KAAK,GAAI,GAAG,IAAI,CAAC;kBACpE,OAAO,GAAGH,KAAK,KAAK9J,KAAK,KAAKmG,UAAU,IAAI;gBAC5C;cACF;YACF;UACF;QACF;MACJ,CAAC,CAAC;IACJ,CAAC;IAED,MAAMe,yBAAwB,GAAKvG,IAAI,IAAK;MAC1C,IAAI,CAACvC,mBAAmB,CAAC4B,KAAK,EAAE;MAEhC,MAAMwH,GAAE,GAAIpJ,mBAAmB,CAAC4B,KAAK,CAACyH,UAAU,CAAC,IAAI,CAAC;MACtD,IAAI,CAACD,GAAG,EAAE;;MAEV;MACA,MAAME,aAAY,GAAIhK,KAAK,CAACiK,QAAQ,CAACH,GAAG,CAAC;MACzC,IAAIE,aAAa,EAAEA,aAAa,CAACE,OAAO,CAAC,CAAC;;MAE1C;MACA,MAAMuC,cAAa,GAAIxJ,IAAI,CAACY,eAAc,IAAK,EAAE;MACjD,MAAMqH,MAAK,GAAI,EAAE;MACjB,MAAMnH,MAAK,GAAI,EAAE;MACjB,MAAM2I,MAAK,GAAI,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC;MAEjF,IAAI;QACF;QACA,IAAIlJ,KAAK,CAACC,OAAO,CAACgJ,cAAc,CAAC,EAAE;UACjC;UACAA,cAAc,CAAChG,OAAO,CAAC,CAACkG,IAAI,EAAEC,KAAK,KAAK;YACtC,IAAID,IAAG,IAAK,OAAOA,IAAG,KAAM,QAAQ,EAAE;cACpCzB,MAAM,CAAC9E,IAAI,CAACuG,IAAI,CAAC3I,IAAG,IAAK,QAAQ4I,KAAI,GAAI,CAAC,EAAE,CAAC;cAC7C7I,MAAM,CAACqC,IAAI,CAACyG,UAAU,CAACF,IAAI,CAAC5J,YAAY,KAAK,CAAC,CAAC;YACjD;UACF,CAAC,CAAC;QACJ,OAAO,IAAI,OAAO0J,cAAa,KAAM,QAAO,IAAKA,cAAa,KAAM,IAAI,EAAE;UACxE;UACA3I,MAAM,CAACgJ,OAAO,CAACL,cAAc,CAAC,CAAChG,OAAO,CAAC,CAAC,CAACzC,IAAI,EAAEf,IAAI,CAAC,EAAE2J,KAAK,KAAK;YAC9D1B,MAAM,CAAC9E,IAAI,CAACpC,IAAI,CAAC;YACjBD,MAAM,CAACqC,IAAI,CAACyG,UAAU,CAAC5J,IAAI,CAACF,YAAY,KAAK,CAAC,CAAC;UACjD,CAAC,CAAC;QACJ;;QAEA;QACA,IAAImI,MAAM,CAACvH,MAAK,KAAM,CAAC,EAAE;UACvBuH,MAAM,CAAC9E,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,kBAAkB,CAAC;UACnDrC,MAAM,CAACqC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACtB;MACF,EAAE,OAAOlB,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;QACzD;QACAgG,MAAM,CAAC9E,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,kBAAkB,CAAC;QACnDrC,MAAM,CAACqC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACtB;;MAEA;MACA,IAAIpG,KAAK,CAAC8J,GAAG,EAAE;QACb9F,IAAI,EAAE,KAAK;QACTf,IAAI,EAAE;UACNiI,MAAM,EAAEA,MAAM;UACZC,QAAQ,EAAE,CAAC;YACXiB,KAAK,EAAE,mBAAmB;YAC1BnJ,IAAI,EAAEc,MAAM;YACZqH,eAAe,EAAEsB,MAAM,CAACK,KAAK,CAAC,CAAC,EAAE7B,MAAM,CAACvH,MAAM,CAAC;YAC/C0H,WAAW,EAAE,CAAC;YACd2B,YAAY,EAAE,CAAC;YACfC,eAAe,EAAE;UACjB,CAAC;QACH,CAAC;QACD1B,OAAO,EAAE;UACPC,UAAU,EAAE,IAAI;UAChBC,mBAAmB,EAAE,KAAK;UAC5BE,OAAO,EAAE;YACPC,MAAM,EAAE;cACJsB,OAAO,EAAE;YACb,CAAC;YACDhB,OAAO,EAAE;cACPC,SAAS,EAAE;gBACTC,KAAK,EAAE,SAAAA,CAASC,OAAO,EAAE;kBACvB,OAAO,kBAAkBA,OAAO,CAACC,GAAG,GAAG;gBACzC;cACF;YACA;UACF,CAAC;UACDa,MAAM,EAAE;YACNC,CAAC,EAAE;cACDC,WAAW,EAAE,IAAI;cACjBC,GAAG,EAAE,GAAG;cACRC,KAAK,EAAE;gBACLC,QAAQ,EAAE,SAAAA,CAASlL,KAAK,EAAE;kBACxB,OAAOA,KAAI,GAAI,GAAG;gBACpB;cACF;YACF;UACJ;QACF;MACF,CAAC,CAAC;IACJ,CAAC;IAED,MAAMmH,2BAA0B,GAAKxG,IAAI,IAAK;MAC5C,IAAI,CAACtC,qBAAqB,CAAC2B,KAAK,EAAE;MAElC,MAAMwH,GAAE,GAAInJ,qBAAqB,CAAC2B,KAAK,CAACyH,UAAU,CAAC,IAAI,CAAC;MACxD,IAAI,CAACD,GAAG,EAAE;;MAEV;MACA,MAAME,aAAY,GAAIhK,KAAK,CAACiK,QAAQ,CAACH,GAAG,CAAC;MACzC,IAAIE,aAAa,EAAEA,aAAa,CAACE,OAAO,CAAC,CAAC;MAE1C,IAAIuD,MAAK,GAAI,EAAE;MACf,IAAIxK,IAAI,CAACS,iBAAgB,IAAKF,KAAK,CAACC,OAAO,CAACR,IAAI,CAACS,iBAAiB,CAAC,EAAE;QACnE;QACA+J,MAAK,GAAIxK,IAAI,CAACS,iBAAgB,CAC3BmB,MAAM,CAAC6I,KAAI,IACVA,KAAK,CAACrH,IAAG,KACR,OAAOqH,KAAK,CAAC3K,YAAW,KAAM,QAAO,IAAK,OAAO2K,KAAK,CAAClF,KAAI,KAAM,QAAQ,CAC5E,EACC9D,GAAG,CAACgJ,KAAI,KAAM;UACbrH,IAAI,EAAE,IAAI0B,IAAI,CAAC2F,KAAK,CAACrH,IAAI,CAAC;UAC1B/D,KAAK,EAAEuK,UAAU,CAACa,KAAK,CAAC3K,YAAW,IAAK2K,KAAK,CAAClF,KAAK,KAAK,CAAC;UACzDlI,IAAI,EAAEoN,KAAK,CAAC1E,KAAI,IAAK0E,KAAK,CAACpN,IAAG,IAAK;QACrC,CAAC,CAAC,EACDwE,IAAI,CAAC,CAACwC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACjB,IAAG,GAAIkB,CAAC,CAAClB,IAAI,CAAC;MACpC;MAEArB,OAAO,CAACC,GAAG,CAAC,iCAAiCwI,MAAM,CAAC9J,MAAM,oBAAoB,CAAC;;MAE/E;MACA,MAAMgK,OAAM,GAAIF,MAAM,CAAC9J,MAAK,GAAI,KAAK8J,MAAM,CAACrK,IAAI,CAACwK,CAAA,IAAKA,CAAC,CAACtL,KAAI,GAAI,CAAC,CAAC;MAElE,IAAIqL,OAAO,EAAE;QACX;QACA,IAAI3N,KAAK,CAAC8J,GAAG,EAAE;UACb9F,IAAI,EAAE,MAAM;UACZf,IAAI,EAAE;YACJiI,MAAM,EAAEuC,MAAM,CAAC/I,GAAG,CAACgJ,KAAI,IAAKxN,MAAM,CAACwN,KAAK,CAACrH,IAAI,CAAC,CAAC5E,MAAM,CAAC,aAAa,CAAC,CAAC;YACrE0J,QAAQ,EAAE,CAAC;cACTiB,KAAK,EAAE,eAAe;cACtBnJ,IAAI,EAAEwK,MAAM,CAAC/I,GAAG,CAACgJ,KAAI,IAAKA,KAAK,CAACpL,KAAK,CAAC;cACtCuL,WAAW,EAAE,mBAAmB;cAChCzC,eAAe,EAAE,yBAAyB;cAC1CC,WAAW,EAAE,CAAC;cACdyC,OAAO,EAAE,GAAG;cACZC,IAAI,EAAE,IAAI;cACVC,WAAW,EAAE,CAAC;cACdC,oBAAoB,EAAE,mBAAmB;cACzCC,gBAAgB,EAAE;YACpB,CAAC;UACH,CAAC;UACD3C,OAAO,EAAE;YACPC,UAAU,EAAE,IAAI;YAChBC,mBAAmB,EAAE,KAAK;YAC1BE,OAAO,EAAE;cACPC,MAAM,EAAE;gBACNsB,OAAO,EAAE,IAAI;gBACbrB,QAAQ,EAAE;cACZ,CAAC;cACDK,OAAO,EAAE;gBACPC,SAAS,EAAE;kBACTnD,KAAK,EAAGmF,YAAY,IAAK;oBACvB,IAAI,CAACA,YAAY,CAACxK,MAAK,IAAK,CAAC8J,MAAM,CAACU,YAAY,CAAC,CAAC,CAAC,CAACC,SAAS,CAAC,EAAE,OAAO,EAAE;oBACzE,MAAMV,KAAI,GAAID,MAAM,CAACU,YAAY,CAAC,CAAC,CAAC,CAACC,SAAS,CAAC;oBAC/C,OAAO,GAAGlO,MAAM,CAACwN,KAAK,CAACrH,IAAI,CAAC,CAAC5E,MAAM,CAAC,aAAa,CAAC,MAAMiM,KAAK,CAACpN,IAAI,EAAE;kBACtE,CAAC;kBACD8L,KAAK,EAAGC,OAAO,IAAK;oBAClB,OAAO,UAAUA,OAAO,CAACC,GAAG,CAAC+B,OAAO,CAAC,CAAC,CAAC,GAAG;kBAC5C;gBACF;cACF;YACF,CAAC;YACDlB,MAAM,EAAE;cACNC,CAAC,EAAE;gBACDC,WAAW,EAAE,IAAI;gBACjBC,GAAG,EAAE,GAAG;gBACRtE,KAAK,EAAE;kBACLkE,OAAO,EAAE,IAAI;kBACboB,IAAI,EAAE;gBACR;cACF,CAAC;cACDC,CAAC,EAAE;gBACDhB,KAAK,EAAE;kBACLiB,WAAW,EAAE,EAAE;kBACfC,WAAW,EAAE;gBACf;cACF;YACF;UACF;QACF,CAAC,CAAC;MACJ,OAAO;QACL;QACA,IAAIzO,KAAK,CAAC8J,GAAG,EAAE;UACb9F,IAAI,EAAE,MAAM;UACZf,IAAI,EAAE;YACJiI,MAAM,EAAE,EAAE;YACVC,QAAQ,EAAE,CAAC;cACTiB,KAAK,EAAE,eAAe;cACtBnJ,IAAI,EAAE,EAAE;cACR4K,WAAW,EAAE,mBAAmB;cAChCzC,eAAe,EAAE,yBAAyB;cAC1CC,WAAW,EAAE;YACf,CAAC;UACH,CAAC;UACDE,OAAO,EAAE;YACPC,UAAU,EAAE,IAAI;YAChBC,mBAAmB,EAAE,KAAK;YAC1BE,OAAO,EAAE;cACPC,MAAM,EAAE;gBACNsB,OAAO,EAAE,IAAI;gBACbrB,QAAQ,EAAE;cACZ;YACF,CAAC;YACDsB,MAAM,EAAE;cACNC,CAAC,EAAE;gBACDC,WAAW,EAAE,IAAI;gBACjBC,GAAG,EAAE,GAAG;gBACRtE,KAAK,EAAE;kBACLkE,OAAO,EAAE,IAAI;kBACboB,IAAI,EAAE;gBACR;cACF;YACF;UACF;QACF,CAAC,CAAC;MACJ;IACF,CAAC;IAED,MAAM5E,oCAAmC,GAAKzG,IAAI,IAAK;MACrD,IAAI,CAACrC,8BAA8B,CAAC0B,KAAK,EAAE;MAE3C,MAAMwH,GAAE,GAAIlJ,8BAA8B,CAAC0B,KAAK,CAACyH,UAAU,CAAC,IAAI,CAAC;MACjE,IAAI,CAACD,GAAG,EAAE;MAEV,MAAME,aAAY,GAAIhK,KAAK,CAACiK,QAAQ,CAACH,GAAG,CAAC;MACzC,IAAIE,aAAa,EAAEA,aAAa,CAACE,OAAO,CAAC,CAAC;;MAE1C;MACA,MAAMwE,YAAW,GAAI;QACnBC,IAAI,EAAE,EAAE;QACRC,QAAQ,EAAE,EAAE;QACZ,kBAAkB,EAAE;MACtB,CAAC;;MAED;MACA,IAAIzH,YAAW,GAAI,KAAK;MACxB,IAAI3D,KAAK,CAACC,OAAO,CAACR,IAAI,CAACS,iBAAiB,CAAC,EAAE;QACzCT,IAAI,CAACS,iBAAiB,CAAC+C,OAAO,CAACiH,KAAI,IAAK;UACtC;UACA,IAAIA,KAAK,CAACrH,IAAG,KAAM,OAAOqH,KAAK,CAAC3K,YAAW,KAAM,QAAO,IAAK,OAAO2K,KAAK,CAAClF,KAAI,KAAM,QAAQ,CAAC,EAAE;YAC7F,MAAMxE,IAAG,GAAI0J,KAAK,CAAC1J,IAAG,IAAK0J,KAAK,CAAC1E,KAAI,IAAK,OAAO;YACjD,MAAMR,KAAI,GAAIqE,UAAU,CAACa,KAAK,CAAC3K,YAAW,IAAK2K,KAAK,CAAClF,KAAK,KAAK,CAAC;;YAEhE;YACA,IAAI,CAACkG,YAAY,CAAC1K,IAAI,CAAC,EAAE;cACvB0K,YAAY,CAAC1K,IAAI,IAAI,EAAE;YACzB;YAEA0K,YAAY,CAAC1K,IAAI,CAAC,CAACoC,IAAI,CAAC;cACtBC,IAAI,EAAE,IAAI0B,IAAI,CAAC2F,KAAK,CAACrH,IAAI,CAAC;cAC1BmC,KAAK,EAAEA;YACT,CAAC,CAAC;YAEF,IAAIA,KAAI,GAAI,CAAC,EAAE;cACbrB,YAAW,GAAI,IAAI;YACrB;UACF;QACF,CAAC,CAAC;MACJ;;MAEA;MACArD,MAAM,CAAC6E,IAAI,CAAC+F,YAAY,CAAC,CAACjI,OAAO,CAACzC,IAAG,IAAK;QACxC0K,YAAY,CAAC1K,IAAI,CAAC,CAACc,IAAI,CAAC,CAACwC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACjB,IAAG,GAAIkB,CAAC,CAAClB,IAAI,CAAC;MACpD,CAAC,CAAC;;MAEF;MACA,MAAMwI,QAAO,GAAI,CAAC,GAAG,IAAIpK,GAAG,CAC1BX,MAAM,CAACC,MAAM,CAAC2K,YAAY,EACvBI,IAAI,CAAC,EACLpK,GAAG,CAACiI,IAAG,IAAKA,IAAI,CAACtG,IAAI,CAC1B,CAAC,CAAC,CAACvB,IAAI,CAAC,CAACwC,CAAC,EAAEC,CAAC,KAAKD,CAAA,GAAIC,CAAC,CAAC;;MAExB;MACA,IAAIsH,QAAQ,CAAClL,MAAK,GAAI,KAAKwD,YAAY,EAAE;QACvCnC,OAAO,CAACC,GAAG,CAAC,sCAAsC4J,QAAQ,CAAClL,MAAM,kBAAkB,CAAC;;QAEpF;QACA,MAAMwH,QAAO,GAAIrH,MAAM,CAACgJ,OAAO,CAAC4B,YAAY,EACzC7J,MAAM,CAAC,CAAC,CAACkK,CAAC,EAAE9L,IAAI,CAAC,KAAKA,IAAI,CAACU,MAAK,GAAI,CAAC,EAAE;QAAA,CACvCe,GAAG,CAAC,CAAC,CAACV,IAAI,EAAEf,IAAI,CAAC,EAAE2J,KAAK,KAAK;UAC5B,MAAMF,MAAK,GAAI,CACb,mBAAmB;UAAI;UACvB,mBAAmB;UAAI;UACvB,mBAAkB,CAAK;UAAA,CACxB;UACD,MAAMsC,KAAI,GAAItC,MAAM,CAACE,KAAI,GAAIF,MAAM,CAAC/I,MAAM,CAAC;UAE3C,OAAO;YACLyI,KAAK,EAAEpI,IAAI;YACXf,IAAI,EAAE4L,QAAQ,CAACnK,GAAG,CAAC2B,IAAG,IAAK;cACzB,MAAM4I,KAAI,GAAIhM,IAAI,CAACiM,IAAI,CAACC,CAAA,IAAKA,CAAC,CAAC9I,IAAI,CAAC+I,OAAO,CAAC,MAAM/I,IAAI,CAAC+I,OAAO,CAAC,CAAC,CAAC;cACjE,OAAOH,KAAI,GAAIA,KAAK,CAACzG,KAAI,GAAI,IAAI;YACnC,CAAC,CAAC;YACFqF,WAAW,EAAEmB,KAAK;YAClB5D,eAAe,EAAE4D,KAAK,CAACK,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAACA,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC;YACpEtB,IAAI,EAAE,IAAI;YACVD,OAAO,EAAE,GAAG;YACZE,WAAW,EAAE,CAAC;YACdE,gBAAgB,EAAE,CAAC;YACnBoB,QAAQ,EAAE,IAAG,CAAE;UACjB,CAAC;QACH,CAAC,CAAC;QAEJ,IAAItP,KAAK,CAAC8J,GAAG,EAAE;UACb9F,IAAI,EAAE,MAAM;UACZf,IAAI,EAAE;YACJiI,MAAM,EAAE2D,QAAQ,CAACnK,GAAG,CAAC2B,IAAG,IAAKnG,MAAM,CAACmG,IAAI,CAAC,CAAC5E,MAAM,CAAC,aAAa,CAAC,CAAC;YAChE0J;UACF,CAAC;UACDI,OAAO,EAAE;YACPC,UAAU,EAAE,IAAI;YAChBC,mBAAmB,EAAE,KAAK;YAC1B8D,WAAW,EAAE;cACXC,SAAS,EAAE,KAAK;cAChBC,IAAI,EAAE;YACR,CAAC;YACD9D,OAAO,EAAE;cACPC,MAAM,EAAE;gBACNC,QAAQ,EAAE;cACZ,CAAC;cACDK,OAAO,EAAE;gBACPC,SAAS,EAAE;kBACTC,KAAK,EAAGC,OAAO,IAAK;oBAClB,MAAM/J,KAAI,GAAI+J,OAAO,CAACC,GAAE,KAAM,IAAG,GAAID,OAAO,CAACC,GAAG,CAAC+B,OAAO,CAAC,CAAC,IAAI,KAAK;oBACnE,OAAO,GAAGhC,OAAO,CAACqD,OAAO,CAACtD,KAAK,KAAK9J,KAAK,GAAG;kBAC9C;gBACF;cACF;YACF,CAAC;YACD6K,MAAM,EAAE;cACNC,CAAC,EAAE;gBACDC,WAAW,EAAE,IAAI;gBACjBC,GAAG,EAAE,GAAG;gBACRtE,KAAK,EAAE;kBACLkE,OAAO,EAAE,IAAI;kBACboB,IAAI,EAAE;gBACR;cACF,CAAC;cACDC,CAAC,EAAE;gBACDhB,KAAK,EAAE;kBACLiB,WAAW,EAAE,EAAE;kBACfC,WAAW,EAAE;gBACf;cACF;YACF;UACF;QACF,CAAC,CAAC;MACJ,OAAO;QACL;QACAzJ,OAAO,CAACC,GAAG,CAAC,gEAAgE,CAAC;QAC7E,IAAIjF,KAAK,CAAC8J,GAAG,EAAE;UACb9F,IAAI,EAAE,MAAM;UACZf,IAAI,EAAE;YACJiI,MAAM,EAAE,EAAE;YACVC,QAAQ,EAAE,CAAC;cACTiB,KAAK,EAAE,SAAS;cAChBnJ,IAAI,EAAE,EAAE;cACR4K,WAAW,EAAE,oBAAoB;cACjCzC,eAAe,EAAE;YACnB,CAAC;UACH,CAAC;UACDG,OAAO,EAAE;YACPC,UAAU,EAAE,IAAI;YAChBC,mBAAmB,EAAE,KAAK;YAC1BE,OAAO,EAAE;cACPC,MAAM,EAAE;gBACNC,QAAQ,EAAE;cACZ;YACF,CAAC;YACDsB,MAAM,EAAE;cACNC,CAAC,EAAE;gBACDC,WAAW,EAAE,IAAI;gBACjBC,GAAG,EAAE,GAAG;gBACRtE,KAAK,EAAE;kBACLkE,OAAO,EAAE,IAAI;kBACboB,IAAI,EAAE;gBACR;cACF;YACF;UACF;QACF,CAAC,CAAC;MACJ;IACF,CAAC;;IAED;IACA,MAAMqB,gBAAe,GAAI,MAAAA,CAAA,KAAY;MACnC,IAAI;QACFzO,SAAS,CAACoB,KAAI,GAAI,IAAI;;QAEtB;QACAqH,eAAe,CAAC,CAAC;;QAEjB;QACA,MAAM7J,QAAQ,CAAC,CAAC;;QAEhB;QACA,MAAMoH,kBAAkB,CAAC,CAAC;;QAE1B;QACA/F,UAAU,CAACmB,KAAI,GAAI,IAAIyF,IAAI,CAAC,CAAC;MAC/B,EAAE,OAAO7C,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACrD,UAAU;QACRhE,SAAS,CAACoB,KAAI,GAAI,KAAK;MACzB;IACF,CAAC;IAED,MAAMsN,eAAc,GAAKC,SAAS,IAAK;MACrC,MAAMxK,OAAM,GAAIyK,QAAQ,CAACC,cAAc,CAACF,SAAS,CAAC;MAClD,IAAIxK,OAAO,EAAE;QACXA,OAAO,CAAC2K,cAAc,CAAC;UAAEC,QAAQ,EAAE;QAAS,CAAC,CAAC;MAChD;IACF,CAAC;;IAED;IACAvQ,SAAS,CAAC,YAAY;MACpB,IAAI;QACF;QACA,MAAMI,QAAQ,CAAC,CAAC;QAEhBkF,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;;QAE9C;QACA0E,eAAe,CAAC,CAAC;;QAEjB;QACAxJ,GAAG,CAAC+P,YAAY,CAAC7L,QAAQ,CAAC8L,GAAG,CAC3B9L,QAAO,IAAKA,QAAQ,EACpBa,KAAI,IAAK;UACP,IAAIA,KAAK,CAACb,QAAO,IAAKa,KAAK,CAACb,QAAQ,CAACsC,MAAK,KAAM,GAAG,EAAE;YACnD3B,OAAO,CAACS,IAAI,CAAC,2BAA2BP,KAAK,CAACkL,MAAM,CAACC,GAAG,EAAE,CAAC;UAC7D;UACA,OAAO9J,OAAO,CAAC+J,MAAM,CAACpL,KAAK,CAAC;QAC9B,CACF,CAAC;;QAED;QACA,IAAI1E,KAAK,CAACqB,KAAK,CAACC,IAAI,CAACF,KAAK,EAAE;UAC1BzB,GAAG,CAACqC,QAAQ,CAACC,OAAO,CAACC,MAAM,CAAC,eAAe,IAAI,UAAUlC,KAAK,CAACqB,KAAK,CAACC,IAAI,CAACF,KAAK,EAAE;QACnF;;QAEA;QACA,MAAMwC,qBAAqB,CAAC,CAAC;;QAE7B;QACA,IAAI7C,cAAc,CAACe,KAAK,CAACqB,MAAK,KAAM,CAAC,EAAE;UACrCpC,cAAc,CAACe,KAAI,GAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QACrD;;QAEA;QACA,MAAM4E,kBAAkB,CAAC,CAAC;;QAE1B;QACA,IAAI9F,mBAAmB,CAACkB,KAAK,EAAE;UAC7BiO,aAAa,CAACnP,mBAAmB,CAACkB,KAAK,CAAC;QAC1C;;QAEA;QACAlB,mBAAmB,CAACkB,KAAI,GAAIkO,WAAW,CAAC,MAAM;UAC5C,IAAIV,QAAQ,CAACW,eAAc,KAAM,SAAS,EAAE;YAC1Cd,gBAAgB,CAAC,CAAC;UACpB;QACF,CAAC,EAAE,IAAI,EAAC,GAAI,IAAI,CAAC,EAAE;MACrB,EAAE,OAAOzK,KAAK,EAAE;QACdF,OAAO,CAACE,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;QACrD;QACA,MAAMpF,QAAQ,CAAC,CAAC;QAChB6J,eAAe,CAAC,CAAC;MACnB;IACF,CAAC,CAAC;;IAEF;IACA9J,WAAW,CAAC,MAAM;MAChB,IAAIuB,mBAAmB,CAACkB,KAAK,EAAE;QAC7BiO,aAAa,CAACnP,mBAAmB,CAACkB,KAAK,CAAC;MAC1C;IACF,CAAC,CAAC;;IAEF;IACA1C,KAAK,CAAC,CAACmB,iBAAiB,EAAEC,eAAe,CAAC,EAAE,MAAM;MAChD,IAAID,iBAAiB,CAACuB,KAAI,IAAKtB,eAAe,CAACsB,KAAK,EAAE;QACpD;QACA,MAAMoO,KAAI,GAAIxQ,MAAM,CAACa,iBAAiB,CAACuB,KAAK,CAAC;QAC7C,MAAMqO,GAAE,GAAIzQ,MAAM,CAACc,eAAe,CAACsB,KAAK,CAAC;QAEzC,IAAIqO,GAAG,CAACC,QAAQ,CAACF,KAAK,CAAC,EAAE;UACvB1P,eAAe,CAACsB,KAAI,GAAIvB,iBAAiB,CAACuB,KAAK;QACjD;MACF;IACF,CAAC,CAAC;IAEF,OAAO;MACL7B,gBAAgB;MAChBC,mBAAmB;MACnBC,qBAAqB;MACrBC,8BAA8B;MAC9BC,YAAY;MACZC,eAAe;MACfO,QAAQ;MACRC,QAAQ;MACRC,cAAc;MACdG,SAAS;MACTK,QAAQ;MACRK,gBAAgB;MAChBQ,aAAa;MACbC,aAAa;MACbC,iBAAiB;MACjBC,YAAY;MACZC,cAAc;MACdE,iBAAiB;MACjBI,YAAY;MACZC,kBAAkB;MAClBK,iBAAiB;MACjBO,cAAc;MACdlD,kBAAkB;MAClBC,SAAS;MACTC,UAAU;MACViJ,UAAU;MACVwF,eAAe;MACfvF,gBAAgB;MAChBC,mBAAmB;MACnBE,YAAY;MACZE,gBAAgB;MAChBiF,gBAAgB;MAChBvL,qBAAqB;MACrBrD,iBAAiB;MACjBC,eAAe;MACfQ;IACF;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}