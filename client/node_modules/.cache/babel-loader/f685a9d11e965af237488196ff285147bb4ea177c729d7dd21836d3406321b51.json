{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { ref, onMounted, computed } from 'vue';\nimport { useStore } from 'vuex';\nimport axios from 'axios';\nimport Chart from 'chart.js/auto';\nimport moment from 'moment';\nexport default {\n  __name: 'AllSurveyStat',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const store = useStore();\n    const loading = ref(true);\n    const noData = ref(false);\n    const problemTypesChart = ref(null);\n    const severityLevelsChart = ref(null);\n    const responseRatesChart = ref(null);\n    const surveys = ref([]);\n    const problemCounts = ref({});\n    const severityCounts = ref({\n      high: 0,\n      medium: 0,\n      low: 0,\n      minimal: 0\n    });\n\n    // Get severity level based on score\n    const getSeverityLevel = score => {\n      if (score >= 7) return 'high';\n      if (score >= 5) return 'medium';\n      if (score >= 3) return 'low';\n      return 'minimal';\n    };\n\n    // Fetch all submitted surveys and process for statistics\n    const fetchSurveyData = async () => {\n      try {\n        loading.value = true;\n        const token = store.state.auth.token;\n\n        // Get all completed surveys from the survey collection\n        const response = await axios.get('http://localhost:8000/api/survey/submitted', {\n          headers: {\n            'Authorization': `Bearer ${token}`\n          }\n        });\n        if (response.data && Array.isArray(response.data) && response.data.length > 0) {\n          surveys.value = response.data;\n          noData.value = false;\n          processSurveyData();\n        } else {\n          noData.value = true;\n        }\n      } catch (error) {\n        console.error('Error fetching survey data:', error);\n        noData.value = true;\n      } finally {\n        loading.value = false;\n      }\n    };\n\n    // Process survey data to generate statistics\n    const processSurveyData = () => {\n      // Reset counts\n      problemCounts.value = {};\n      severityCounts.value = {\n        high: 0,\n        medium: 0,\n        low: 0,\n        minimal: 0\n      };\n\n      // Process each survey\n      surveys.value.forEach(survey => {\n        // Count problem types and their severity\n        if (survey.surveyStats && Array.isArray(survey.surveyStats)) {\n          survey.surveyStats.forEach(stat => {\n            // Count problem types\n            if (stat.type) {\n              if (!problemCounts.value[stat.type]) {\n                problemCounts.value[stat.type] = 0;\n              }\n              problemCounts.value[stat.type]++;\n            }\n\n            // Count severity levels\n            const severityLevel = getSeverityLevel(stat.average || 0);\n            severityCounts.value[severityLevel]++;\n          });\n        }\n      });\n\n      // Create charts after processing data\n      renderProblemTypesChart();\n      renderSeverityLevelsChart();\n      renderResponseRatesChart();\n    };\n\n    // Create problem types distribution chart\n    const renderProblemTypesChart = () => {\n      if (!problemTypesChart.value) return;\n      const ctx = problemTypesChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      const problemTypes = Object.keys(problemCounts.value);\n      const problemData = Object.values(problemCounts.value);\n\n      // Chart colors\n      const colors = ['rgba(54, 162, 235, 0.7)', 'rgba(255, 99, 132, 0.7)', 'rgba(255, 206, 86, 0.7)', 'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)'];\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'pie',\n        data: {\n          labels: problemTypes,\n          datasets: [{\n            data: problemData,\n            backgroundColor: colors.slice(0, problemTypes.length),\n            borderWidth: 1\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              position: 'right',\n              labels: {\n                boxWidth: 12,\n                padding: 15\n              }\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const value = context.raw || 0;\n                  const total = problemData.reduce((a, b) => a + b, 0);\n                  const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;\n                  return `${context.label}: ${value} (${percentage}%)`;\n                }\n              }\n            }\n          }\n        }\n      });\n    };\n\n    // Create severity levels distribution chart\n    const renderSeverityLevelsChart = () => {\n      if (!severityLevelsChart.value) return;\n      const ctx = severityLevelsChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      const labels = ['High', 'Medium', 'Low', 'Minimal'];\n      const data = [severityCounts.value.high, severityCounts.value.medium, severityCounts.value.low, severityCounts.value.minimal];\n\n      // Chart colors\n      const colors = ['rgba(220, 53, 69, 0.7)',\n      // High (red)\n      'rgba(255, 193, 7, 0.7)',\n      // Medium (yellow)\n      'rgba(13, 110, 253, 0.7)',\n      // Low (blue)\n      'rgba(25, 135, 84, 0.7)' // Minimal (green)\n      ];\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n          labels: labels,\n          datasets: [{\n            data: data,\n            backgroundColor: colors,\n            borderWidth: 1\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              position: 'right',\n              labels: {\n                boxWidth: 12,\n                padding: 15\n              }\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const value = context.raw || 0;\n                  const total = data.reduce((a, b) => a + b, 0);\n                  const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;\n                  return `${context.label}: ${value} (${percentage}%)`;\n                }\n              }\n            }\n          }\n        }\n      });\n    };\n\n    // Create response rates chart (by month)\n    const renderResponseRatesChart = () => {\n      if (!responseRatesChart.value) return;\n      const ctx = responseRatesChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Group surveys by month\n      const monthlyData = {};\n      surveys.value.forEach(survey => {\n        const date = moment(survey.createdAt || survey.updatedAt);\n        const monthKey = date.format('MMM YYYY');\n        if (!monthlyData[monthKey]) {\n          monthlyData[monthKey] = 0;\n        }\n        monthlyData[monthKey]++;\n      });\n\n      // Sort months chronologically\n      const sortedMonths = Object.keys(monthlyData).sort((a, b) => {\n        return moment(a, 'MMM YYYY').diff(moment(b, 'MMM YYYY'));\n      });\n      const responseData = sortedMonths.map(month => monthlyData[month]);\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: sortedMonths,\n          datasets: [{\n            label: 'Survey Responses',\n            data: responseData,\n            backgroundColor: 'rgba(75, 192, 192, 0.7)',\n            borderColor: 'rgba(75, 192, 192, 1)',\n            borderWidth: 1,\n            borderRadius: 5\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: context => `${context.raw} survey${context.raw !== 1 ? 's' : ''}`\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              ticks: {\n                stepSize: 1,\n                precision: 0\n              },\n              title: {\n                display: true,\n                text: 'Number of Responses'\n              }\n            }\n          }\n        }\n      });\n    };\n\n    // Initialize component\n    onMounted(() => {\n      fetchSurveyData();\n    });\n    const __returned__ = {\n      store,\n      loading,\n      noData,\n      problemTypesChart,\n      severityLevelsChart,\n      responseRatesChart,\n      surveys,\n      problemCounts,\n      severityCounts,\n      getSeverityLevel,\n      fetchSurveyData,\n      processSurveyData,\n      renderProblemTypesChart,\n      renderSeverityLevelsChart,\n      renderResponseRatesChart,\n      ref,\n      onMounted,\n      computed,\n      get useStore() {\n        return useStore;\n      },\n      get axios() {\n        return axios;\n      },\n      get Chart() {\n        return Chart;\n      },\n      get moment() {\n        return moment;\n      }\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","onMounted","computed","useStore","axios","Chart","moment","store","loading","noData","problemTypesChart","severityLevelsChart","responseRatesChart","surveys","problemCounts","severityCounts","high","medium","low","minimal","getSeverityLevel","score","fetchSurveyData","value","token","state","auth","response","get","headers","data","Array","isArray","length","processSurveyData","error","console","forEach","survey","surveyStats","stat","type","severityLevel","average","renderProblemTypesChart","renderSeverityLevelsChart","renderResponseRatesChart","ctx","getContext","existingChart","getChart","destroy","problemTypes","Object","keys","problemData","values","colors","labels","datasets","backgroundColor","slice","borderWidth","options","responsive","maintainAspectRatio","plugins","legend","position","boxWidth","padding","tooltip","callbacks","label","context","raw","total","reduce","a","b","percentage","toFixed","monthlyData","date","createdAt","updatedAt","monthKey","format","sortedMonths","sort","diff","responseData","map","month","borderColor","borderRadius","display","scales","y","beginAtZero","ticks","stepSize","precision","title","text"],"sources":["D:/au_dev/client/src/components/AllSurveyStat.vue"],"sourcesContent":["<template>\r\n  <div class=\"all-survey-stat\">\r\n    <div v-if=\"loading\" class=\"text-center py-4\">\r\n      <div class=\"spinner-border text-primary\" role=\"status\">\r\n        <span class=\"visually-hidden\">Loading...</span>\r\n      </div>\r\n      <p class=\"mt-2\">Loading survey statistics...</p>\r\n    </div>\r\n    \r\n    <div v-else-if=\"noData\" class=\"text-center py-4\">\r\n      <i class=\"fas fa-chart-pie fa-3x text-muted mb-3\"></i>\r\n      <h5>No Survey Data Available</h5>\r\n      <p class=\"text-muted\">No survey responses have been submitted yet.</p>\r\n    </div>\r\n    \r\n    <div v-else class=\"survey-charts row g-4\">\r\n      <!-- Problem Types Distribution -->\r\n      <div class=\"col-md-6\">\r\n        <div class=\"chart-container\">\r\n          <h6 class=\"chart-title\">Problem Types Distribution</h6>\r\n          <canvas ref=\"problemTypesChart\"></canvas>\r\n        </div>\r\n      </div>\r\n      \r\n      <!-- Severity Levels -->\r\n      <div class=\"col-md-6\">\r\n        <div class=\"chart-container\">\r\n          <h6 class=\"chart-title\">Severity Levels Distribution</h6>\r\n          <canvas ref=\"severityLevelsChart\"></canvas>\r\n        </div>\r\n      </div>\r\n      \r\n      <!-- Response Rates Chart -->\r\n      <div class=\"col-md-12\">\r\n        <div class=\"chart-container\">\r\n          <h6 class=\"chart-title\">Survey Response Rates</h6>\r\n          <canvas ref=\"responseRatesChart\"></canvas>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup>\r\nimport { ref, onMounted, computed } from 'vue'\r\nimport { useStore } from 'vuex'\r\nimport axios from 'axios'\r\nimport Chart from 'chart.js/auto'\r\nimport moment from 'moment'\r\n\r\nconst store = useStore()\r\nconst loading = ref(true)\r\nconst noData = ref(false)\r\nconst problemTypesChart = ref(null)\r\nconst severityLevelsChart = ref(null)\r\nconst responseRatesChart = ref(null)\r\nconst surveys = ref([])\r\nconst problemCounts = ref({})\r\nconst severityCounts = ref({\r\n  high: 0,\r\n  medium: 0,\r\n  low: 0,\r\n  minimal: 0\r\n})\r\n\r\n// Get severity level based on score\r\nconst getSeverityLevel = (score) => {\r\n  if (score >= 7) return 'high';\r\n  if (score >= 5) return 'medium';\r\n  if (score >= 3) return 'low';\r\n  return 'minimal';\r\n}\r\n\r\n// Fetch all submitted surveys and process for statistics\r\nconst fetchSurveyData = async () => {\r\n  try {\r\n    loading.value = true\r\n    const token = store.state.auth.token\r\n    \r\n    // Get all completed surveys from the survey collection\r\n    const response = await axios.get('http://localhost:8000/api/survey/submitted', {\r\n      headers: { 'Authorization': `Bearer ${token}` }\r\n    })\r\n    \r\n    if (response.data && Array.isArray(response.data) && response.data.length > 0) {\r\n      surveys.value = response.data\r\n      noData.value = false\r\n      processSurveyData()\r\n    } else {\r\n      noData.value = true\r\n    }\r\n  } catch (error) {\r\n    console.error('Error fetching survey data:', error)\r\n    noData.value = true\r\n  } finally {\r\n    loading.value = false\r\n  }\r\n}\r\n\r\n// Process survey data to generate statistics\r\nconst processSurveyData = () => {\r\n  // Reset counts\r\n  problemCounts.value = {}\r\n  severityCounts.value = {\r\n    high: 0,\r\n    medium: 0,\r\n    low: 0,\r\n    minimal: 0\r\n  }\r\n  \r\n  // Process each survey\r\n  surveys.value.forEach(survey => {\r\n    // Count problem types and their severity\r\n    if (survey.surveyStats && Array.isArray(survey.surveyStats)) {\r\n      survey.surveyStats.forEach(stat => {\r\n        // Count problem types\r\n        if (stat.type) {\r\n          if (!problemCounts.value[stat.type]) {\r\n            problemCounts.value[stat.type] = 0\r\n          }\r\n          problemCounts.value[stat.type]++\r\n        }\r\n        \r\n        // Count severity levels\r\n        const severityLevel = getSeverityLevel(stat.average || 0)\r\n        severityCounts.value[severityLevel]++\r\n      })\r\n    }\r\n  })\r\n  \r\n  // Create charts after processing data\r\n  renderProblemTypesChart()\r\n  renderSeverityLevelsChart()\r\n  renderResponseRatesChart()\r\n}\r\n\r\n// Create problem types distribution chart\r\nconst renderProblemTypesChart = () => {\r\n  if (!problemTypesChart.value) return\r\n  \r\n  const ctx = problemTypesChart.value.getContext('2d')\r\n  if (!ctx) return\r\n  \r\n  const existingChart = Chart.getChart(ctx)\r\n  if (existingChart) existingChart.destroy()\r\n  \r\n  const problemTypes = Object.keys(problemCounts.value)\r\n  const problemData = Object.values(problemCounts.value)\r\n  \r\n  // Chart colors\r\n  const colors = [\r\n    'rgba(54, 162, 235, 0.7)',\r\n    'rgba(255, 99, 132, 0.7)',\r\n    'rgba(255, 206, 86, 0.7)',\r\n    'rgba(75, 192, 192, 0.7)',\r\n    'rgba(153, 102, 255, 0.7)',\r\n    'rgba(255, 159, 64, 0.7)'\r\n  ]\r\n  \r\n  // Create chart\r\n  new Chart(ctx, {\r\n    type: 'pie',\r\n    data: {\r\n      labels: problemTypes,\r\n      datasets: [{\r\n        data: problemData,\r\n        backgroundColor: colors.slice(0, problemTypes.length),\r\n        borderWidth: 1\r\n      }]\r\n    },\r\n    options: {\r\n      responsive: true,\r\n      maintainAspectRatio: false,\r\n      plugins: {\r\n        legend: {\r\n          position: 'right',\r\n          labels: {\r\n            boxWidth: 12,\r\n            padding: 15\r\n          }\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            label: (context) => {\r\n              const value = context.raw || 0\r\n              const total = problemData.reduce((a, b) => a + b, 0)\r\n              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0\r\n              return `${context.label}: ${value} (${percentage}%)`\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\n// Create severity levels distribution chart\r\nconst renderSeverityLevelsChart = () => {\r\n  if (!severityLevelsChart.value) return\r\n  \r\n  const ctx = severityLevelsChart.value.getContext('2d')\r\n  if (!ctx) return\r\n  \r\n  const existingChart = Chart.getChart(ctx)\r\n  if (existingChart) existingChart.destroy()\r\n  \r\n  const labels = ['High', 'Medium', 'Low', 'Minimal']\r\n  const data = [\r\n    severityCounts.value.high,\r\n    severityCounts.value.medium,\r\n    severityCounts.value.low,\r\n    severityCounts.value.minimal\r\n  ]\r\n  \r\n  // Chart colors\r\n  const colors = [\r\n    'rgba(220, 53, 69, 0.7)',   // High (red)\r\n    'rgba(255, 193, 7, 0.7)',   // Medium (yellow)\r\n    'rgba(13, 110, 253, 0.7)',  // Low (blue)\r\n    'rgba(25, 135, 84, 0.7)'    // Minimal (green)\r\n  ]\r\n  \r\n  // Create chart\r\n  new Chart(ctx, {\r\n    type: 'doughnut',\r\n    data: {\r\n      labels: labels,\r\n      datasets: [{\r\n        data: data,\r\n        backgroundColor: colors,\r\n        borderWidth: 1\r\n      }]\r\n    },\r\n    options: {\r\n      responsive: true,\r\n      maintainAspectRatio: false,\r\n      plugins: {\r\n        legend: {\r\n          position: 'right',\r\n          labels: {\r\n            boxWidth: 12,\r\n            padding: 15\r\n          }\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            label: (context) => {\r\n              const value = context.raw || 0\r\n              const total = data.reduce((a, b) => a + b, 0)\r\n              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0\r\n              return `${context.label}: ${value} (${percentage}%)`\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\n// Create response rates chart (by month)\r\nconst renderResponseRatesChart = () => {\r\n  if (!responseRatesChart.value) return\r\n  \r\n  const ctx = responseRatesChart.value.getContext('2d')\r\n  if (!ctx) return\r\n  \r\n  const existingChart = Chart.getChart(ctx)\r\n  if (existingChart) existingChart.destroy()\r\n  \r\n  // Group surveys by month\r\n  const monthlyData = {}\r\n  \r\n  surveys.value.forEach(survey => {\r\n    const date = moment(survey.createdAt || survey.updatedAt)\r\n    const monthKey = date.format('MMM YYYY')\r\n    \r\n    if (!monthlyData[monthKey]) {\r\n      monthlyData[monthKey] = 0\r\n    }\r\n    \r\n    monthlyData[monthKey]++\r\n  })\r\n  \r\n  // Sort months chronologically\r\n  const sortedMonths = Object.keys(monthlyData).sort((a, b) => {\r\n    return moment(a, 'MMM YYYY').diff(moment(b, 'MMM YYYY'))\r\n  })\r\n  \r\n  const responseData = sortedMonths.map(month => monthlyData[month])\r\n  \r\n  // Create chart\r\n  new Chart(ctx, {\r\n    type: 'bar',\r\n    data: {\r\n      labels: sortedMonths,\r\n      datasets: [{\r\n        label: 'Survey Responses',\r\n        data: responseData,\r\n        backgroundColor: 'rgba(75, 192, 192, 0.7)',\r\n        borderColor: 'rgba(75, 192, 192, 1)',\r\n        borderWidth: 1,\r\n        borderRadius: 5\r\n      }]\r\n    },\r\n    options: {\r\n      responsive: true,\r\n      maintainAspectRatio: false,\r\n      plugins: {\r\n        legend: {\r\n          display: false\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            label: (context) => `${context.raw} survey${context.raw !== 1 ? 's' : ''}`\r\n          }\r\n        }\r\n      },\r\n      scales: {\r\n        y: {\r\n          beginAtZero: true,\r\n          ticks: {\r\n            stepSize: 1,\r\n            precision: 0\r\n          },\r\n          title: {\r\n            display: true,\r\n            text: 'Number of Responses'\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\n// Initialize component\r\nonMounted(() => {\r\n  fetchSurveyData()\r\n})\r\n</script>\r\n\r\n<style scoped>\r\n.all-survey-stat {\r\n  padding: 1rem;\r\n}\r\n\r\n.chart-container {\r\n  background-color: #fff;\r\n  border-radius: 8px;\r\n  padding: 1.5rem;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\r\n  height: 300px;\r\n  position: relative;\r\n}\r\n\r\n.chart-title {\r\n  font-size: 1rem;\r\n  font-weight: 600;\r\n  color: #2d3748;\r\n  margin-bottom: 1rem;\r\n  text-align: center;\r\n}\r\n\r\ncanvas {\r\n  max-height: 100%;\r\n}\r\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}