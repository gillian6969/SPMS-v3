{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { ref, onMounted, computed } from 'vue';\nimport { useStore } from 'vuex';\nimport axios from 'axios';\nimport Chart from 'chart.js/auto';\nimport moment from 'moment';\nexport default {\n  __name: 'AllSurveyStat',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const store = useStore();\n    const loading = ref(true);\n    const noData = ref(false);\n    const problemTypesChart = ref(null);\n    const severityLevelsChart = ref(null);\n    const responseRatesChart = ref(null);\n    const surveys = ref([]);\n    const problemCounts = ref({});\n    const severityCounts = ref({\n      high: 0,\n      medium: 0,\n      low: 0,\n      minimal: 0\n    });\n\n    // Get severity level based on score\n    const getSeverityLevel = score => {\n      if (score >= 7) return 'high';\n      if (score >= 5) return 'medium';\n      if (score >= 3) return 'low';\n      return 'minimal';\n    };\n\n    // Fetch all submitted surveys and process for statistics\n    const fetchSurveyData = async () => {\n      try {\n        loading.value = true;\n        const token = store.state.auth.token;\n\n        // Get all completed surveys from the survey collection\n        const response = await axios.get('http://localhost:8000/api/survey/submitted', {\n          headers: {\n            'Authorization': `Bearer ${token}`\n          }\n        });\n        if (response.data && Array.isArray(response.data) && response.data.length > 0) {\n          console.log('Survey data received:', response.data);\n          surveys.value = response.data;\n          noData.value = false;\n          processSurveyData();\n        } else {\n          console.log('No survey data found');\n          noData.value = true;\n        }\n      } catch (error) {\n        console.error('Error fetching survey data:', error);\n        noData.value = true;\n      } finally {\n        loading.value = false;\n      }\n    };\n\n    // Process survey data to generate statistics\n    const processSurveyData = () => {\n      // Reset counts\n      problemCounts.value = {};\n      severityCounts.value = {\n        high: 0,\n        medium: 0,\n        low: 0,\n        minimal: 0\n      };\n\n      // Process each survey\n      surveys.value.forEach(survey => {\n        // Count problem types and their severity\n        if (survey.surveyStats && Array.isArray(survey.surveyStats)) {\n          survey.surveyStats.forEach(stat => {\n            // Count problem types\n            if (stat.type) {\n              if (!problemCounts.value[stat.type]) {\n                problemCounts.value[stat.type] = 0;\n              }\n              problemCounts.value[stat.type]++;\n            }\n\n            // Count severity levels\n            const severityLevel = getSeverityLevel(stat.average || 0);\n            severityCounts.value[severityLevel]++;\n          });\n        }\n      });\n      console.log('Processed problem counts:', problemCounts.value);\n      console.log('Processed severity counts:', severityCounts.value);\n\n      // Create charts after processing data\n      renderProblemTypesChart();\n      renderSeverityLevelsChart();\n      renderResponseRatesChart();\n    };\n\n    // Create problem types distribution chart\n    const renderProblemTypesChart = (useSampleData = false) => {\n      if (!problemTypesChart.value) return;\n      const ctx = problemTypesChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      let problemTypes = Object.keys(problemCounts.value);\n      let problemData = Object.values(problemCounts.value);\n\n      // If no data or using sample data, and previous check didn't create sample data\n      if ((problemTypes.length === 0 || useSampleData) && !Object.keys(problemCounts.value).length) {\n        problemTypes = ['Academic', 'Financial', 'Personal', 'Health', 'Social'];\n        problemData = [3, 2, 5, 1, 4];\n      }\n\n      // Chart colors\n      const colors = ['rgba(54, 162, 235, 0.7)',\n      // Blue\n      'rgba(255, 99, 132, 0.7)',\n      // Red\n      'rgba(255, 206, 86, 0.7)',\n      // Yellow\n      'rgba(75, 192, 192, 0.7)',\n      // Green\n      'rgba(153, 102, 255, 0.7)',\n      // Purple\n      'rgba(255, 159, 64, 0.7)' // Orange\n      ];\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: problemTypes,\n          datasets: [{\n            label: 'Problem Types Count',\n            data: problemData,\n            backgroundColor: colors.slice(0, problemTypes.length),\n            borderWidth: 1\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          indexAxis: 'y',\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const value = context.raw || 0;\n                  const total = problemData.reduce((a, b) => a + b, 0);\n                  const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;\n                  return `${context.label}: ${value} (${percentage}%)`;\n                }\n              }\n            }\n          },\n          scales: {\n            x: {\n              beginAtZero: true,\n              ticks: {\n                precision: 0\n              }\n            }\n          }\n        }\n      });\n    };\n\n    // Create severity levels distribution chart\n    const renderSeverityLevelsChart = (useSampleData = false) => {\n      if (!severityLevelsChart.value) return;\n      const ctx = severityLevelsChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      const labels = ['High', 'Medium', 'Low', 'Minimal'];\n      let data = [severityCounts.value.high, severityCounts.value.medium, severityCounts.value.low, severityCounts.value.minimal];\n\n      // Use sample data if specified and no real data\n      if (useSampleData && data.every(val => val === 0)) {\n        data = [3, 4, 6, 2];\n      }\n\n      // Chart colors\n      const colors = ['rgba(220, 53, 69, 0.7)',\n      // High (red)\n      'rgba(255, 193, 7, 0.7)',\n      // Medium (yellow)\n      'rgba(13, 110, 253, 0.7)',\n      // Low (blue)\n      'rgba(25, 135, 84, 0.7)' // Minimal (green)\n      ];\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: labels,\n          datasets: [{\n            label: 'Severity Levels Count',\n            data: data,\n            backgroundColor: colors,\n            borderWidth: 1\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          indexAxis: 'y',\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const value = context.raw || 0;\n                  const total = data.reduce((a, b) => a + b, 0);\n                  const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;\n                  return `${context.label}: ${value} (${percentage}%)`;\n                }\n              }\n            }\n          },\n          scales: {\n            x: {\n              beginAtZero: true,\n              ticks: {\n                precision: 0\n              }\n            }\n          }\n        }\n      });\n    };\n\n    // Create response rates chart (by month)\n    const renderResponseRatesChart = () => {\n      if (!responseRatesChart.value) return;\n      const ctx = responseRatesChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Group surveys by month\n      const monthlyData = {};\n\n      // If no surveys, create sample data for current and past months\n      if (surveys.value.length === 0) {\n        const currentMonth = moment().format('MMM YYYY');\n        const lastMonth = moment().subtract(1, 'month').format('MMM YYYY');\n        const twoMonthsAgo = moment().subtract(2, 'month').format('MMM YYYY');\n        monthlyData[twoMonthsAgo] = 0;\n        monthlyData[lastMonth] = 0;\n        monthlyData[currentMonth] = 0;\n      } else {\n        surveys.value.forEach(survey => {\n          const date = moment(survey.createdAt || survey.updatedAt);\n          const monthKey = date.format('MMM YYYY');\n          if (!monthlyData[monthKey]) {\n            monthlyData[monthKey] = 0;\n          }\n          monthlyData[monthKey]++;\n        });\n      }\n\n      // Sort months chronologically\n      const sortedMonths = Object.keys(monthlyData).sort((a, b) => {\n        return moment(a, 'MMM YYYY').diff(moment(b, 'MMM YYYY'));\n      });\n      const responseData = sortedMonths.map(month => monthlyData[month]);\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: sortedMonths,\n          datasets: [{\n            label: 'Survey Responses',\n            data: responseData,\n            backgroundColor: 'rgba(75, 192, 192, 0.7)',\n            borderColor: 'rgba(75, 192, 192, 1)',\n            borderWidth: 1,\n            borderRadius: 5\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: context => `${context.raw} survey${context.raw !== 1 ? 's' : ''}`\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              ticks: {\n                stepSize: 1,\n                precision: 0\n              },\n              title: {\n                display: true,\n                text: 'Number of Responses'\n              }\n            }\n          }\n        }\n      });\n    };\n\n    // Initialize component\n    onMounted(() => {\n      fetchSurveyData();\n    });\n    const __returned__ = {\n      store,\n      loading,\n      noData,\n      problemTypesChart,\n      severityLevelsChart,\n      responseRatesChart,\n      surveys,\n      problemCounts,\n      severityCounts,\n      getSeverityLevel,\n      fetchSurveyData,\n      processSurveyData,\n      renderProblemTypesChart,\n      renderSeverityLevelsChart,\n      renderResponseRatesChart,\n      ref,\n      onMounted,\n      computed,\n      get useStore() {\n        return useStore;\n      },\n      get axios() {\n        return axios;\n      },\n      get Chart() {\n        return Chart;\n      },\n      get moment() {\n        return moment;\n      }\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","onMounted","computed","useStore","axios","Chart","moment","store","loading","noData","problemTypesChart","severityLevelsChart","responseRatesChart","surveys","problemCounts","severityCounts","high","medium","low","minimal","getSeverityLevel","score","fetchSurveyData","value","token","state","auth","response","get","headers","data","Array","isArray","length","console","log","processSurveyData","error","forEach","survey","surveyStats","stat","type","severityLevel","average","renderProblemTypesChart","renderSeverityLevelsChart","renderResponseRatesChart","useSampleData","ctx","getContext","existingChart","getChart","destroy","problemTypes","Object","keys","problemData","values","colors","labels","datasets","label","backgroundColor","slice","borderWidth","options","responsive","maintainAspectRatio","indexAxis","plugins","legend","display","tooltip","callbacks","context","raw","total","reduce","a","b","percentage","toFixed","scales","x","beginAtZero","ticks","precision","every","val","monthlyData","currentMonth","format","lastMonth","subtract","twoMonthsAgo","date","createdAt","updatedAt","monthKey","sortedMonths","sort","diff","responseData","map","month","borderColor","borderRadius","y","stepSize","title","text"],"sources":["D:/au_dev/client/src/components/AllSurveyStat.vue"],"sourcesContent":["<template>\n  <div class=\"all-survey-stat\">\n    <div v-if=\"loading\" class=\"text-center py-4\">\n      <div class=\"spinner-border text-primary\" role=\"status\">\n        <span class=\"visually-hidden\">Loading...</span>\n      </div>\n      <p class=\"mt-2\">Loading survey statistics...</p>\n    </div>\n    \n    <div v-else-if=\"noData\" class=\"text-center py-4\">\n      <i class=\"fas fa-chart-pie fa-3x text-muted mb-3\"></i>\n      <h5>No Survey Data Available</h5>\n      <p class=\"text-muted\">No survey responses have been submitted yet.</p>\n    </div>\n    \n    <div v-else class=\"survey-charts row g-4\">\n      <!-- Problem Types Distribution -->\n      <div class=\"col-md-6\">\n        <div class=\"chart-container\">\n          <h6 class=\"chart-title\">Problem Types Distribution</h6>\n          <canvas ref=\"problemTypesChart\"></canvas>\n        </div>\n      </div>\n      \n      <!-- Severity Levels -->\n      <div class=\"col-md-6\">\n        <div class=\"chart-container\">\n          <h6 class=\"chart-title\">Severity Levels Distribution</h6>\n          <canvas ref=\"severityLevelsChart\"></canvas>\n        </div>\n      </div>\n      \n      <!-- Response Rates Chart -->\n      <div class=\"col-md-12\">\n        <div class=\"chart-container\">\n          <h6 class=\"chart-title\">Survey Response Rates</h6>\n          <canvas ref=\"responseRatesChart\"></canvas>\n        </div>\n      </div>\n    </div>\n    </div>\n</template>\n\n<script setup>\nimport { ref, onMounted, computed } from 'vue'\nimport { useStore } from 'vuex'\nimport axios from 'axios'\nimport Chart from 'chart.js/auto'\nimport moment from 'moment'\n\nconst store = useStore()\nconst loading = ref(true)\nconst noData = ref(false)\nconst problemTypesChart = ref(null)\nconst severityLevelsChart = ref(null)\nconst responseRatesChart = ref(null)\nconst surveys = ref([])\nconst problemCounts = ref({})\nconst severityCounts = ref({\n  high: 0,\n  medium: 0,\n  low: 0,\n  minimal: 0\n})\n\n// Get severity level based on score\nconst getSeverityLevel = (score) => {\n  if (score >= 7) return 'high';\n  if (score >= 5) return 'medium';\n  if (score >= 3) return 'low';\n  return 'minimal';\n}\n\n// Fetch all submitted surveys and process for statistics\nconst fetchSurveyData = async () => {\n  try {\n    loading.value = true\n    const token = store.state.auth.token\n    \n    // Get all completed surveys from the survey collection\n    const response = await axios.get('http://localhost:8000/api/survey/submitted', {\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n    \n    if (response.data && Array.isArray(response.data) && response.data.length > 0) {\n      console.log('Survey data received:', response.data)\n      surveys.value = response.data\n      noData.value = false\n      processSurveyData()\n    } else {\n      console.log('No survey data found')\n      noData.value = true\n    }\n  } catch (error) {\n    console.error('Error fetching survey data:', error)\n    noData.value = true\n  } finally {\n    loading.value = false\n  }\n}\n\n// Process survey data to generate statistics\nconst processSurveyData = () => {\n  // Reset counts\n  problemCounts.value = {}\n  severityCounts.value = {\n    high: 0,\n    medium: 0,\n    low: 0,\n    minimal: 0\n  }\n  \n  // Process each survey\n  surveys.value.forEach(survey => {\n    // Count problem types and their severity\n    if (survey.surveyStats && Array.isArray(survey.surveyStats)) {\n      survey.surveyStats.forEach(stat => {\n        // Count problem types\n        if (stat.type) {\n          if (!problemCounts.value[stat.type]) {\n            problemCounts.value[stat.type] = 0\n          }\n          problemCounts.value[stat.type]++\n        }\n        \n        // Count severity levels\n        const severityLevel = getSeverityLevel(stat.average || 0)\n        severityCounts.value[severityLevel]++\n      })\n    }\n  })\n  \n  console.log('Processed problem counts:', problemCounts.value)\n  console.log('Processed severity counts:', severityCounts.value)\n  \n  // Create charts after processing data\n  renderProblemTypesChart()\n  renderSeverityLevelsChart()\n  renderResponseRatesChart()\n}\n\n// Create problem types distribution chart\nconst renderProblemTypesChart = (useSampleData = false) => {\n  if (!problemTypesChart.value) return\n  \n  const ctx = problemTypesChart.value.getContext('2d')\n  if (!ctx) return\n  \n  const existingChart = Chart.getChart(ctx)\n  if (existingChart) existingChart.destroy()\n  \n  let problemTypes = Object.keys(problemCounts.value)\n  let problemData = Object.values(problemCounts.value)\n  \n  // If no data or using sample data, and previous check didn't create sample data\n  if ((problemTypes.length === 0 || useSampleData) && !Object.keys(problemCounts.value).length) {\n    problemTypes = ['Academic', 'Financial', 'Personal', 'Health', 'Social']\n    problemData = [3, 2, 5, 1, 4]\n  }\n  \n  // Chart colors\n  const colors = [\n    'rgba(54, 162, 235, 0.7)',   // Blue\n    'rgba(255, 99, 132, 0.7)',   // Red\n    'rgba(255, 206, 86, 0.7)',   // Yellow\n    'rgba(75, 192, 192, 0.7)',   // Green\n    'rgba(153, 102, 255, 0.7)',  // Purple\n    'rgba(255, 159, 64, 0.7)'    // Orange\n  ]\n  \n  // Create chart\n  new Chart(ctx, {\n    type: 'bar',\n    data: {\n      labels: problemTypes,\n      datasets: [{\n        label: 'Problem Types Count',\n        data: problemData,\n        backgroundColor: colors.slice(0, problemTypes.length),\n        borderWidth: 1\n      }]\n    },\n    options: {\n      responsive: true,\n      maintainAspectRatio: false,\n      indexAxis: 'y',\n      plugins: {\n        legend: {\n          display: false\n        },\n        tooltip: {\n          callbacks: {\n            label: (context) => {\n              const value = context.raw || 0\n              const total = problemData.reduce((a, b) => a + b, 0)\n              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0\n              return `${context.label}: ${value} (${percentage}%)`\n            }\n          }\n        }\n      },\n      scales: {\n        x: {\n          beginAtZero: true,\n          ticks: {\n            precision: 0\n          }\n        }\n      }\n    }\n  })\n}\n\n// Create severity levels distribution chart\nconst renderSeverityLevelsChart = (useSampleData = false) => {\n  if (!severityLevelsChart.value) return\n  \n  const ctx = severityLevelsChart.value.getContext('2d')\n  if (!ctx) return\n  \n  const existingChart = Chart.getChart(ctx)\n  if (existingChart) existingChart.destroy()\n  \n  const labels = ['High', 'Medium', 'Low', 'Minimal']\n  \n  let data = [\n    severityCounts.value.high,\n    severityCounts.value.medium,\n    severityCounts.value.low,\n    severityCounts.value.minimal\n  ]\n  \n  // Use sample data if specified and no real data\n  if (useSampleData && data.every(val => val === 0)) {\n    data = [3, 4, 6, 2]\n  }\n  \n  // Chart colors\n  const colors = [\n    'rgba(220, 53, 69, 0.7)',   // High (red)\n    'rgba(255, 193, 7, 0.7)',   // Medium (yellow)\n    'rgba(13, 110, 253, 0.7)',  // Low (blue)\n    'rgba(25, 135, 84, 0.7)'    // Minimal (green)\n  ]\n  \n  // Create chart\n  new Chart(ctx, {\n    type: 'bar',\n    data: {\n      labels: labels,\n      datasets: [{\n        label: 'Severity Levels Count',\n        data: data,\n        backgroundColor: colors,\n        borderWidth: 1\n      }]\n    },\n    options: {\n      responsive: true,\n      maintainAspectRatio: false,\n      indexAxis: 'y',\n      plugins: {\n        legend: {\n          display: false\n        },\n        tooltip: {\n          callbacks: {\n            label: (context) => {\n              const value = context.raw || 0\n              const total = data.reduce((a, b) => a + b, 0)\n              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0\n              return `${context.label}: ${value} (${percentage}%)`\n            }\n          }\n        }\n      },\n      scales: {\n        x: {\n          beginAtZero: true,\n          ticks: {\n            precision: 0\n          }\n        }\n      }\n    }\n  })\n}\n\n// Create response rates chart (by month)\nconst renderResponseRatesChart = () => {\n  if (!responseRatesChart.value) return\n  \n  const ctx = responseRatesChart.value.getContext('2d')\n  if (!ctx) return\n  \n  const existingChart = Chart.getChart(ctx)\n  if (existingChart) existingChart.destroy()\n  \n  // Group surveys by month\n  const monthlyData = {}\n  \n  // If no surveys, create sample data for current and past months\n  if (surveys.value.length === 0) {\n    const currentMonth = moment().format('MMM YYYY')\n    const lastMonth = moment().subtract(1, 'month').format('MMM YYYY')\n    const twoMonthsAgo = moment().subtract(2, 'month').format('MMM YYYY')\n    \n    monthlyData[twoMonthsAgo] = 0\n    monthlyData[lastMonth] = 0\n    monthlyData[currentMonth] = 0\n  } else {\n    surveys.value.forEach(survey => {\n      const date = moment(survey.createdAt || survey.updatedAt)\n      const monthKey = date.format('MMM YYYY')\n      \n      if (!monthlyData[monthKey]) {\n        monthlyData[monthKey] = 0\n      }\n      \n      monthlyData[monthKey]++\n    })\n  }\n  \n  // Sort months chronologically\n  const sortedMonths = Object.keys(monthlyData).sort((a, b) => {\n    return moment(a, 'MMM YYYY').diff(moment(b, 'MMM YYYY'))\n  })\n  \n  const responseData = sortedMonths.map(month => monthlyData[month])\n  \n  // Create chart\n  new Chart(ctx, {\n    type: 'bar',\n    data: {\n      labels: sortedMonths,\n      datasets: [{\n        label: 'Survey Responses',\n        data: responseData,\n        backgroundColor: 'rgba(75, 192, 192, 0.7)',\n        borderColor: 'rgba(75, 192, 192, 1)',\n        borderWidth: 1,\n        borderRadius: 5\n      }]\n    },\n    options: {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: {\n          display: false\n        },\n        tooltip: {\n          callbacks: {\n            label: (context) => `${context.raw} survey${context.raw !== 1 ? 's' : ''}`\n          }\n        }\n      },\n      scales: {\n        y: {\n          beginAtZero: true,\n          ticks: {\n            stepSize: 1,\n            precision: 0\n          },\n          title: {\n            display: true,\n            text: 'Number of Responses'\n          }\n        }\n      }\n    }\n  })\n}\n\n// Initialize component\nonMounted(() => {\n  fetchSurveyData()\n})\n</script>\n\n<style scoped>\n.all-survey-stat {\n  padding: 1rem;\n}\n\n.chart-container {\n  background-color: #fff;\n  border-radius: 8px;\n  padding: 1.5rem;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\n  height: 300px;\n  position: relative;\n}\n\n.chart-title {\n  font-size: 1rem;\n  font-weight: 600;\n  color: #2d3748;\n  margin-bottom: 1rem;\n  text-align: center;\n}\n\ncanvas {\n  max-height: 100%;\n}\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}