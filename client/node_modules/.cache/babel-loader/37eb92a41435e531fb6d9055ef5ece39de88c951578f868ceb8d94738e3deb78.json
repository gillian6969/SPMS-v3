{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { ref, onMounted, computed, watch, nextTick } from 'vue';\nimport { useStore } from 'vuex';\nimport Chart from 'chart.js/auto';\nimport axios from 'axios';\nimport moment from 'moment';\nimport { saveAs } from 'file-saver';\nimport * as XLSX from 'xlsx';\nimport jsPDF from 'jspdf';\nimport 'jspdf-autotable';\nimport html2canvas from 'html2canvas';\nexport default {\n  name: 'TeacherDashboard',\n  setup() {\n    const store = useStore();\n    const performanceChart = ref(null);\n    const attendanceChart = ref(null);\n    const assessmentTypeChart = ref(null);\n    const performanceTrendChart = ref(null);\n    const assessmentTypePerformanceChart = ref(null);\n\n    // Data refs\n    const totalStudents = ref(0);\n    const totalSections = ref(0);\n    const totalSubjects = ref(0);\n    const averageScore = ref(0);\n    const recentActivities = ref([]);\n    const sections = ref([]);\n    const subjects = ref([]);\n\n    // Filter refs\n    const selectedYear = ref(localStorage.getItem('selectedYear') || '');\n    const selectedSection = ref(localStorage.getItem('selectedSection') || '');\n    const selectedSubject = ref(localStorage.getItem('selectedSubject') || '');\n    const selectedStartDate = ref('');\n    const selectedEndDate = ref('');\n    const today = computed(() => moment().format('YYYY-MM-DD'));\n\n    // Chart date filter state - initialize early to avoid undefined errors\n    const chartFilters = ref({\n      attendance: {\n        period: 'month'\n      },\n      assessmentType: {\n        period: 'month'\n      },\n      performanceTrend: {\n        period: 'month'\n      },\n      assessmentTypePerformance: {\n        period: 'month'\n      }\n    });\n\n    // Chart raw data for export\n    const chartData = ref({\n      attendance: [],\n      assessmentType: [],\n      performanceTrend: [],\n      assessmentTypePerformance: []\n    });\n\n    // We'll maintain available years that come from the API\n    const availableYears = ref([]);\n\n    // Get teacher ID from store\n    const getTeacherId = () => {\n      const user = store.state.auth.user;\n      if (!user || !user._id) {\n        console.error('No teacher ID found in store');\n        return null;\n      }\n      return user._id;\n    };\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      try {\n        if (data.value && data.value.attendanceDistribution) {\n          // Check if we have an array and if any value is > 0\n          const distribution = data.value.attendanceDistribution;\n          if (Array.isArray(distribution) && distribution.length > 0) {\n            return distribution.some(val => {\n              const numVal = Number(val);\n              return !isNaN(numVal) && numVal > 0;\n            });\n          }\n        }\n\n        // Also check chartData as a fallback\n        if (chartData.value && chartData.value.attendance) {\n          const attendance = chartData.value.attendance;\n          return !!(Number(attendance.present) > 0 || Number(attendance.late) > 0 || Number(attendance.absent) > 0);\n        }\n        return false;\n      } catch (err) {\n        console.error('Error in hasAttendanceData:', err);\n        return false;\n      }\n    });\n    const hasPerformanceData = computed(() => {\n      // Check if we have any assessment or performance data\n      if (data.value) {\n        // Check for averageScore > 0\n        if (typeof data.value.averageScore === 'number' && data.value.averageScore > 0) {\n          return true;\n        }\n\n        // Check for performance trends\n        if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n          return true;\n        }\n\n        // Check for assessment types with data\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n      }\n      return false;\n    });\n    const hasAssessmentData = computed(() => {\n      if (data.value) {\n        // Check directly in assessmentTypes\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n\n        // Fallback to assessmentTypeDistribution\n        if (data.value.assessmentTypeDistribution) {\n          return true;\n        }\n      }\n      return false;\n    });\n    const hasActivity = computed(() => recentActivities.value.length > 0);\n\n    // Store all dashboard data in a ref for easier access\n    const data = ref({\n      attendanceDistribution: [0, 0, 0],\n      assessmentTypes: {},\n      performanceTrends: []\n    });\n\n    // In setup function, add loading state\n    const loading = ref(false);\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Teacher' : 'Teacher';\n    });\n    const fetchTeacherSectionsAndSubjects = async (year = '') => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n        const token = store.state.auth.token;\n        console.log('Fetching sections and subjects for:', {\n          teacherId,\n          year\n        });\n\n        // First get all class records to extract sections and years\n        const recordsResponse = await axios.get('http://localhost:8000/api/teacher-class-records', {\n          params: {\n            teacherId\n          },\n          headers: {\n            'Authorization': `Bearer ${token}`\n          }\n        });\n        if (recordsResponse.data && Array.isArray(recordsResponse.data)) {\n          // Extract unique years, sections and subjects\n          const uniqueYears = [...new Set(recordsResponse.data.map(record => record.year))].filter(Boolean);\n          console.log('All unique years found:', uniqueYears);\n\n          // Save available years\n          availableYears.value = uniqueYears.sort();\n\n          // Filter sections and subjects based on year if provided\n          if (year) {\n            const filteredRecords = recordsResponse.data.filter(record => record.year === year);\n            sections.value = [...new Set(filteredRecords.map(record => record.section))].filter(Boolean).sort();\n            subjects.value = [...new Set(filteredRecords.map(record => record.subject))].filter(Boolean).sort();\n          } else {\n            const uniqueSections = [...new Set(recordsResponse.data.map(record => record.section))].filter(Boolean);\n            const uniqueSubjects = [...new Set(recordsResponse.data.map(record => record.subject))].filter(Boolean);\n            sections.value = uniqueSections.sort();\n            subjects.value = uniqueSubjects.sort();\n          }\n\n          // If no selectedYear but we have years\n          if (!selectedYear.value && uniqueYears.length > 0) {\n            selectedYear.value = uniqueYears[0];\n\n            // Also update sections and subjects for this year\n            const filteredRecords = recordsResponse.data.filter(record => record.year === uniqueYears[0]);\n            sections.value = [...new Set(filteredRecords.map(record => record.section))].filter(Boolean).sort();\n            subjects.value = [...new Set(filteredRecords.map(record => record.subject))].filter(Boolean).sort();\n          }\n          console.log('Loaded sections and subjects:', {\n            availableYears: availableYears.value,\n            sections: sections.value,\n            subjects: subjects.value\n          });\n        } else {\n          console.warn('No class records found or unexpected response format');\n          // Reset all filters and arrays\n          availableYears.value = [];\n          sections.value = [];\n          subjects.value = [];\n        }\n      } catch (error) {\n        console.error('Error fetching teacher sections and subjects:', error);\n        sections.value = [];\n        subjects.value = [];\n      }\n    };\n    const handleYearChange = async () => {\n      // Reset section and subject when year changes\n      selectedSection.value = '';\n      selectedSubject.value = '';\n\n      // If a year is selected, fetch sections and subjects for that year\n      if (selectedYear.value) {\n        await fetchTeacherSectionsAndSubjects(selectedYear.value);\n      } else {\n        // If no year selected, get all available sections and subjects\n        await fetchTeacherSectionsAndSubjects();\n      }\n\n      // Update dashboard data with new year selection\n      await fetchDashboardData();\n    };\n    const getFilterDisplay = () => {\n      const filters = [];\n      if (selectedYear.value) filters.push(selectedYear.value + ' Year');\n      if (selectedSection.value) filters.push(selectedSection.value);\n      if (selectedSubject.value) filters.push(selectedSubject.value);\n      return filters.length > 0 ? filters.join(' - ') : 'Filter View';\n    };\n\n    // Initialize empty data for charts when no data is available\n    const initEmptyCharts = () => {\n      updatePerformanceChart({\n        attendanceDistribution: [0, 0, 0]\n      });\n      updateAssessmentTypeChart({\n        assessmentData: []\n      });\n      updatePerformanceTrendChart([]);\n      updateAssessmentTypePerformanceChart({\n        performanceTrends: []\n      });\n    };\n\n    // Function to apply date filter for a specific chart\n    const applyChartDateFilter = async (chartType, period) => {\n      console.log(`Applying ${period} filter to ${chartType} chart`);\n\n      // Update the filter period\n      chartFilters.value[chartType].period = period;\n\n      // Calculate date range based on period\n      const endDate = moment().format('YYYY-MM-DD');\n      let startDate;\n      switch (period) {\n        case 'day':\n          startDate = moment().subtract(1, 'days').format('YYYY-MM-DD');\n          break;\n        case 'week':\n          startDate = moment().subtract(7, 'days').format('YYYY-MM-DD');\n          break;\n        case 'month':\n        default:\n          startDate = moment().subtract(30, 'days').format('YYYY-MM-DD');\n          break;\n      }\n\n      // Fetch and update the specific chart\n      await fetchChartData(chartType, startDate, endDate);\n    };\n\n    // Function to fetch data for a specific chart\n    const fetchChartData = async (chartType, startDate, endDate) => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n\n        // Prepare query parameters with URLSearchParams to ensure proper encoding\n        const params = new URLSearchParams();\n        params.append('teacherId', teacherId);\n        params.append('startDate', startDate);\n        params.append('endDate', endDate);\n\n        // Add filters if selected\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedSubject.value) params.append('subject', selectedSubject.value);\n        console.log(`Fetching ${chartType} data with params:`, Object.fromEntries(params));\n        let endpoint;\n        let url;\n        switch (chartType) {\n          case 'attendance':\n            endpoint = 'attendance/stats';\n            break;\n          case 'assessmentType':\n          case 'performanceTrend':\n          case 'assessmentTypePerformance':\n            endpoint = 'assessments/stats';\n            break;\n          default:\n            throw new Error(`Unknown chart type: ${chartType}`);\n        }\n        url = `http://localhost:8000/api/${endpoint}?${params.toString()}`;\n        console.log(`Requesting URL: ${url}`);\n        const response = await axios.get(url, {\n          headers: {\n            'Authorization': `Bearer ${store.state.auth.token}`\n          }\n        });\n        console.log(`${chartType} data received:`, response.data);\n\n        // Store raw data for export\n        chartData.value[chartType] = response.data;\n\n        // Update the specific chart\n        switch (chartType) {\n          case 'attendance':\n            if (response.data) {\n              // Format the attendance data for our chart\n              const attendanceStats = response.data;\n\n              // Ensure we have numbers for the chart\n              const present = parseInt(attendanceStats.present) || 0;\n              const late = parseInt(attendanceStats.late) || 0;\n              const absent = parseInt(attendanceStats.absent) || 0;\n              console.log('Attendance stats for chart:', {\n                present,\n                late,\n                absent\n              });\n              const formattedData = {\n                attendanceDistribution: [present, late, absent]\n              };\n\n              // Update the attendance data in our main data store too\n              if (data.value) {\n                data.value.attendanceDistribution = formattedData.attendanceDistribution;\n              }\n              updatePerformanceChart(formattedData);\n            }\n            break;\n          case 'assessmentType':\n            if (response.data && response.data.assessmentTypes) {\n              const assessmentData = [];\n              Object.keys(response.data.assessmentTypes).forEach(type => {\n                const typeData = response.data.assessmentTypes[type];\n                if (typeData) {\n                  let avgScore = 0;\n                  if (typeData.scoreCount && typeData.scoreCount > 0) {\n                    avgScore = (typeData.totalScore / typeData.scoreCount).toFixed(1);\n                  }\n                  assessmentData.push({\n                    type: type,\n                    averageScore: avgScore,\n                    count: typeData.count || 0\n                  });\n                }\n              });\n              updateAssessmentTypeChart({\n                assessmentData\n              });\n            }\n            break;\n          case 'performanceTrend':\n            if (response.data) {\n              // Create performance trends data\n              const performanceTrends = Array.isArray(response.data) ? response.data.filter(a => a.date) // Only include assessments with dates\n              .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n              .map(assessment => {\n                // Calculate average score for this assessment\n                let averageScore = 0;\n                let scoreArray = [];\n                if (assessment.scores) {\n                  if (Array.isArray(assessment.scores)) {\n                    scoreArray = assessment.scores;\n                  } else if (typeof assessment.scores === 'object') {\n                    scoreArray = Object.values(assessment.scores);\n                  }\n                  const validScores = scoreArray.filter(score => typeof score === 'number');\n                  if (validScores.length > 0) {\n                    const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                    averageScore = totalScore / validScores.length;\n                  }\n                }\n                return {\n                  date: assessment.date,\n                  score: averageScore,\n                  name: assessment.name || assessment.title || assessment.type,\n                  type: assessment.type\n                };\n              }) : [];\n              updatePerformanceTrendChart(performanceTrends);\n            }\n            break;\n          case 'assessmentTypePerformance':\n            if (response.data) {\n              // Create performance trends data for assessment type performance\n              const performanceTrends = Array.isArray(response.data) ? response.data.filter(a => a.date) // Only include assessments with dates\n              .map(assessment => ({\n                date: assessment.date,\n                score: assessment.averageScore || 0,\n                name: assessment.name || assessment.title || assessment.type,\n                type: assessment.type\n              })) : [];\n              updateAssessmentTypePerformanceChart({\n                performanceTrends\n              });\n            }\n            break;\n        }\n      } catch (error) {\n        console.error(`Error fetching ${chartType} data:`, error);\n        // If the chart type is attendance, ensure we update with empty data\n        if (chartType === 'attendance') {\n          updatePerformanceChart({\n            attendanceDistribution: [0, 0, 0]\n          });\n        }\n      }\n    };\n\n    // Function to generate and download chart data\n    const generateFallbackPDF = (chartType, dataToExport, fileName) => {\n      try {\n        console.log('Using fallback PDF generation method');\n\n        // Create simple PDF with minimal formatting\n        const doc = new jsPDF();\n\n        // Add title\n        doc.setFontSize(16);\n        doc.text(`${chartType.toUpperCase()} REPORT`, 105, 20, {\n          align: 'center'\n        });\n\n        // Add date\n        doc.setFontSize(10);\n        doc.text(`Generated: ${new Date().toLocaleString()}`, 105, 30, {\n          align: 'center'\n        });\n\n        // Create simple table with just the data\n        const tableColumn = Object.keys(dataToExport[0]);\n        const tableRows = dataToExport.map(item => {\n          return Object.values(item).map(val => String(val || ''));\n        });\n\n        // Add basic table\n        doc.autoTable({\n          startY: 40,\n          head: [tableColumn],\n          body: tableRows,\n          theme: 'plain'\n        });\n\n        // Save\n        doc.save(`${fileName}_simple.pdf`);\n        console.log('Fallback PDF generated successfully');\n        return true;\n      } catch (error) {\n        console.error('Even fallback PDF generation failed:', error);\n        return false;\n      }\n    };\n\n    // Updated generateChartData function with fallback handling\n    const generateChartData = async (chartType, format = 'excel') => {\n      try {\n        console.log(`Generating ${format} for ${chartType} chart`);\n\n        // Get raw data for the chart\n        let dataToExport = [];\n        let fileName = '';\n        switch (chartType) {\n          case 'attendance':\n            fileName = `attendance_data_${moment().format('YYYY-MM-DD')}`;\n\n            // Improved attendance data extraction with explicit type conversion\n            let present = 0,\n              late = 0,\n              absent = 0;\n\n            // Try multiple data sources\n            if (chartData.value[chartType]) {\n              present = Number(chartData.value[chartType].present || 0);\n              late = Number(chartData.value[chartType].late || 0);\n              absent = Number(chartData.value[chartType].absent || 0);\n            } else if (data.value?.attendanceDistribution && Array.isArray(data.value.attendanceDistribution)) {\n              present = Number(data.value.attendanceDistribution[0] || 0);\n              late = Number(data.value.attendanceDistribution[1] || 0);\n              absent = Number(data.value.attendanceDistribution[2] || 0);\n            }\n            console.log('Attendance data for export (processed):', {\n              present,\n              late,\n              absent\n            });\n\n            // Create export data with explicit typing\n            dataToExport = [{\n              'Status': 'Present',\n              'Count': present\n            }, {\n              'Status': 'Late',\n              'Count': late\n            }, {\n              'Status': 'Absent',\n              'Count': absent\n            }];\n            break;\n          case 'assessmentType':\n            fileName = `assessment_types_${moment().format('YYYY-MM-DD')}`;\n\n            // Format assessment type data for export - improve data extraction\n            if (chartData.value[chartType]?.assessmentTypes) {\n              // Use chartData instead of data\n              const assessmentTypes = chartData.value[chartType].assessmentTypes;\n              Object.keys(assessmentTypes).forEach(type => {\n                const typeData = assessmentTypes[type];\n                if (typeData) {\n                  const avgScore = typeData.averageScore || (typeData.scoreCount > 0 ? (typeData.totalScore / typeData.scoreCount).toFixed(1) : 0);\n                  dataToExport.push({\n                    'Assessment Type': type,\n                    'Average Score': avgScore,\n                    'Count': typeData.count || 0\n                  });\n                }\n              });\n            } else if (data.value?.assessmentTypes) {\n              // Fallback to data.value if needed\n              Object.keys(data.value.assessmentTypes).forEach(type => {\n                const typeData = data.value.assessmentTypes[type];\n                if (typeData) {\n                  let avgScore = 0;\n                  if (typeData.scoreCount && typeData.scoreCount > 0) {\n                    avgScore = (typeData.totalScore / typeData.scoreCount).toFixed(1);\n                  } else if (typeData.averageScore) {\n                    avgScore = typeData.averageScore;\n                  }\n                  dataToExport.push({\n                    'Assessment Type': type,\n                    'Average Score': avgScore,\n                    'Count': typeData.count || 0\n                  });\n                }\n              });\n            }\n\n            // If still no data, look at chart data directly\n            if (dataToExport.length === 0) {\n              try {\n                const chart = Chart.getChart(assessmentTypeChart.value);\n                if (chart && chart.data?.datasets?.[0]?.data) {\n                  const labels = chart.data.labels || [];\n                  const scores = chart.data.datasets[0].data || [];\n                  labels.forEach((type, index) => {\n                    if (type && scores[index] !== undefined) {\n                      dataToExport.push({\n                        'Assessment Type': type,\n                        'Average Score': scores[index] || 0,\n                        'Count': 'N/A' // We don't have this information from the chart\n                      });\n                    }\n                  });\n                }\n              } catch (chartErr) {\n                console.error('Error extracting chart data:', chartErr);\n              }\n            }\n            break;\n          case 'performanceTrend':\n            fileName = `performance_trends_${moment().format('YYYY-MM-DD')}`;\n\n            // Format performance trend data for export - improve data extraction\n            if (Array.isArray(chartData.value[chartType])) {\n              // Use raw assessment data\n              dataToExport = chartData.value[chartType].filter(assessment => assessment.date).map(assessment => ({\n                'Date': moment(assessment.date).format('YYYY-MM-DD'),\n                'Assessment': assessment.name || assessment.title || '',\n                'Type': assessment.type || '',\n                'Average Score': assessment.averageScore || assessment.score || 0\n              }));\n            } else if (data.value?.performanceTrends) {\n              // Fallback to data.value\n              dataToExport = data.value.performanceTrends.map(trend => ({\n                'Date': moment(trend.date).format('YYYY-MM-DD'),\n                'Assessment': trend.name || trend.title || '',\n                'Average Score': trend.score || trend.averageScore || 0\n              }));\n            }\n\n            // If still no data, extract from chart\n            if (dataToExport.length === 0) {\n              try {\n                const chart = Chart.getChart(performanceTrendChart.value);\n                if (chart && chart.data?.datasets?.[0]?.data) {\n                  const labels = chart.data.labels || [];\n                  const scores = chart.data.datasets[0].data || [];\n                  labels.forEach((date, index) => {\n                    if (date && scores[index] !== undefined) {\n                      dataToExport.push({\n                        'Date': date,\n                        'Assessment': 'Assessment ' + (index + 1),\n                        'Average Score': scores[index] || 0\n                      });\n                    }\n                  });\n                }\n              } catch (chartErr) {\n                console.error('Error extracting chart data:', chartErr);\n              }\n            }\n            break;\n          case 'assessmentTypePerformance':\n            fileName = `assessment_performance_${moment().format('YYYY-MM-DD')}`;\n\n            // Format assessment type performance data for export - improve data extraction\n            if (Array.isArray(chartData.value[chartType])) {\n              // Use chartData's raw assessment data\n              dataToExport = chartData.value[chartType].filter(assessment => assessment.date && assessment.type).map(assessment => ({\n                'Date': moment(assessment.date).format('YYYY-MM-DD'),\n                'Assessment Type': assessment.type || '',\n                'Assessment Name': assessment.name || assessment.title || '',\n                'Average Score': assessment.averageScore || assessment.score || 0\n              }));\n            } else if (data.value?.performanceTrends) {\n              // Fallback to data.value\n              dataToExport = data.value.performanceTrends.filter(trend => trend.type).map(trend => ({\n                'Date': moment(trend.date).format('YYYY-MM-DD'),\n                'Assessment Type': trend.type || '',\n                'Assessment Name': trend.name || trend.title || '',\n                'Average Score': trend.score || trend.averageScore || 0\n              }));\n            }\n\n            // If still no data, extract from chart\n            if (dataToExport.length === 0) {\n              try {\n                const chart = Chart.getChart(assessmentTypePerformanceChart.value);\n                if (chart && chart.data?.datasets) {\n                  const labels = chart.data.labels || [];\n                  const datasets = chart.data.datasets || [];\n                  datasets.forEach(dataset => {\n                    const type = dataset.label || 'Unknown';\n                    const data = dataset.data || [];\n                    labels.forEach((date, index) => {\n                      if (date && data[index] !== null && data[index] !== undefined) {\n                        dataToExport.push({\n                          'Date': date,\n                          'Assessment Type': type,\n                          'Assessment Name': 'Assessment ' + (index + 1),\n                          'Average Score': data[index] || 0\n                        });\n                      }\n                    });\n                  });\n                }\n              } catch (chartErr) {\n                console.error('Error extracting chart data:', chartErr);\n              }\n            }\n            break;\n          default:\n            throw new Error(`Unknown chart type: ${chartType}`);\n        }\n\n        // Check if we have data to export\n        if (dataToExport.length === 0) {\n          console.warn(`No data to export for ${chartType}`);\n          alert('No data available to generate report');\n          return;\n        }\n\n        // Log the exact structure of data being exported\n        console.log('Data being exported:', JSON.stringify(dataToExport));\n        if (format === 'excel') {\n          // Create and download Excel file\n          const worksheet = XLSX.utils.json_to_sheet(dataToExport);\n          const workbook = XLSX.utils.book_new();\n          XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');\n          const excelBuffer = XLSX.write(workbook, {\n            bookType: 'xlsx',\n            type: 'array'\n          });\n          const excelData = new Blob([excelBuffer], {\n            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n          });\n          saveAs(excelData, `${fileName}.xlsx`);\n        } else if (format === 'pdf') {\n          let pdfGenerated = false;\n          try {\n            // Create PDF document with specified orientation\n            const doc = new jsPDF({\n              orientation: 'portrait',\n              unit: 'mm',\n              format: 'a4'\n            });\n\n            // Add document title\n            let title = '';\n            switch (chartType) {\n              case 'attendance':\n                title = 'Attendance Distribution Report';\n                break;\n              case 'assessmentType':\n                title = 'Assessment Types Performance Report';\n                break;\n              case 'performanceTrend':\n                title = 'Performance Trends Report';\n                break;\n              case 'assessmentTypePerformance':\n                title = 'Performance by Assessment Type Report';\n                break;\n            }\n\n            // Add header with styling\n            doc.setFont('helvetica', 'bold');\n            doc.setFontSize(16);\n            doc.setTextColor(0, 51, 102); // Dark blue\n            doc.text(title, doc.internal.pageSize.getWidth() / 2, 20, {\n              align: 'center'\n            });\n\n            // Add date and filters info\n            doc.setFont('helvetica', 'normal');\n            doc.setFontSize(10);\n            doc.setTextColor(70, 70, 70);\n            const dateText = `Generated on: ${moment().format('MMMM D, YYYY')}`;\n            doc.text(dateText, 15, 30);\n\n            // Add filter info if available\n            let filterText = '';\n            if (selectedYear.value) filterText += `Year: ${selectedYear.value} `;\n            if (selectedSection.value) filterText += `Section: ${selectedSection.value} `;\n            if (selectedSubject.value) filterText += `Subject: ${selectedSubject.value} `;\n            if (filterText) {\n              doc.text(`Filters: ${filterText}`, 15, 35);\n            }\n\n            // Filter settings\n            const periodText = `Period: ${chartFilters.value[chartType]?.period || 'month'}`;\n            doc.text(periodText, 15, 40);\n\n            // Convert data to table format\n            const tableColumn = Object.keys(dataToExport[0]);\n            const tableRows = dataToExport.map(item => {\n              return Object.values(item).map(val => {\n                // Ensure all values are properly formatted\n                if (val === undefined || val === null) return '';\n                return val.toString();\n              });\n            });\n\n            // Add table with safer settings\n            try {\n              doc.autoTable({\n                startY: 45,\n                head: [tableColumn],\n                body: tableRows,\n                theme: 'grid',\n                headStyles: {\n                  fillColor: [0, 51, 102],\n                  textColor: [255, 255, 255],\n                  fontStyle: 'bold',\n                  halign: 'center'\n                },\n                styles: {\n                  fontSize: 10,\n                  cellPadding: 3,\n                  overflow: 'linebreak'\n                },\n                margin: {\n                  top: 45,\n                  right: 15,\n                  bottom: 25,\n                  left: 15\n                }\n              });\n            } catch (tableError) {\n              console.error('Error creating table:', tableError);\n              throw new Error('Failed to create PDF table: ' + tableError.message);\n            }\n\n            // Special handling for attendance data - add summary with percentages\n            if (chartType === 'attendance') {\n              try {\n                const present = dataToExport.find(i => i.Status === 'Present')?.Count || 0;\n                const late = dataToExport.find(i => i.Status === 'Late')?.Count || 0;\n                const absent = dataToExport.find(i => i.Status === 'Absent')?.Count || 0;\n                const total = Number(present) + Number(late) + Number(absent);\n                if (total > 0) {\n                  // Calculate percentages\n                  const presentPercent = (Number(present) / total * 100).toFixed(1);\n                  const latePercent = (Number(late) / total * 100).toFixed(1);\n                  const absentPercent = (Number(absent) / total * 100).toFixed(1);\n\n                  // Get Y position after table\n                  const finalY = doc.lastAutoTable?.finalY || 150;\n\n                  // Add summary section\n                  doc.setFont('helvetica', 'bold');\n                  doc.setFontSize(12);\n                  doc.setTextColor(0, 51, 102);\n                  doc.text('Attendance Summary:', 15, finalY + 15);\n                  doc.setFont('helvetica', 'normal');\n                  doc.setFontSize(10);\n                  doc.setTextColor(70, 70, 70);\n                  doc.text(`Total Records: ${total}`, 15, finalY + 25);\n                  doc.text(`Present: ${present} (${presentPercent}%)`, 15, finalY + 32);\n                  doc.text(`Late: ${late} (${latePercent}%)`, 15, finalY + 39);\n                  doc.text(`Absent: ${absent} (${absentPercent}%)`, 15, finalY + 46);\n\n                  // Try to add simple chart visual (colored bars)\n                  const barWidth = 120; // width of full bar in mm\n                  const barHeight = 8;\n                  const startX = 15;\n                  const startY = finalY + 55;\n\n                  // Present bar (green)\n                  const presentWidth = barWidth * (Number(present) / total);\n                  doc.setFillColor(52, 211, 153); // Green\n                  doc.rect(startX, startY, presentWidth, barHeight, 'F');\n\n                  // Late bar (yellow)\n                  const lateWidth = barWidth * (Number(late) / total);\n                  doc.setFillColor(251, 191, 36); // Yellow\n                  doc.rect(startX + presentWidth, startY, lateWidth, barHeight, 'F');\n\n                  // Absent bar (red)\n                  const absentWidth = barWidth * (Number(absent) / total);\n                  doc.setFillColor(239, 68, 68); // Red\n                  doc.rect(startX + presentWidth + lateWidth, startY, absentWidth, barHeight, 'F');\n\n                  // Add legend\n                  const legendY = startY + barHeight + 10;\n                  // Present legend\n                  doc.setFillColor(52, 211, 153);\n                  doc.rect(startX, legendY, 5, 5, 'F');\n                  doc.text('Present', startX + 10, legendY + 4);\n\n                  // Late legend\n                  doc.setFillColor(251, 191, 36);\n                  doc.rect(startX + 50, legendY, 5, 5, 'F');\n                  doc.text('Late', startX + 60, legendY + 4);\n\n                  // Absent legend\n                  doc.setFillColor(239, 68, 68);\n                  doc.rect(startX + 100, legendY, 5, 5, 'F');\n                  doc.text('Absent', startX + 110, legendY + 4);\n                }\n              } catch (summaryError) {\n                console.error('Error adding attendance summary:', summaryError);\n                // Continue without summary if there's an error\n              }\n            }\n\n            // Add footer with teacher's name and page numbers\n            const pageCount = doc.internal.getNumberOfPages();\n            doc.setFont('helvetica', 'normal');\n            doc.setFontSize(9);\n            doc.setTextColor(100, 100, 100);\n            const teacherName = store.state.auth.user ? `${store.state.auth.user.firstName || ''} ${store.state.auth.user.lastName || ''}`.trim() : 'Teacher';\n            for (let i = 1; i <= pageCount; i++) {\n              doc.setPage(i);\n              // Safe footer placement\n              const pageHeight = doc.internal.pageSize.getHeight();\n              doc.text(`Generated by: ${teacherName} | Page ${i} of ${pageCount}`, doc.internal.pageSize.getWidth() / 2, pageHeight - 10, {\n                align: 'center'\n              });\n            }\n\n            // Save the PDF\n            try {\n              doc.save(`${fileName}.pdf`);\n              console.log(`PDF generated successfully for ${chartType}`);\n              pdfGenerated = true;\n            } catch (saveError) {\n              console.error('Error saving PDF:', saveError);\n              throw new Error('Error saving the PDF: ' + saveError.message);\n            }\n          } catch (pdfError) {\n            console.error('Error in primary PDF generation method:', pdfError);\n\n            // Try fallback method if primary fails\n            if (!pdfGenerated) {\n              const fallbackSuccess = generateFallbackPDF(chartType, dataToExport, fileName);\n              if (fallbackSuccess) {\n                alert('Generated a simplified PDF report due to formatting issues.');\n              } else {\n                alert(`Failed to generate PDF report: ${pdfError.message || 'Unknown error'}. Please try Excel format instead.`);\n              }\n            }\n          }\n        }\n        console.log(`Data export completed for ${chartType} as ${format}`);\n      } catch (error) {\n        console.error(`Error generating ${chartType} data:`, error);\n        alert(`Error generating report: ${error.message || 'Unknown error'}\\nPlease try Excel format instead.`);\n      }\n    };\n\n    // Enhanced fetchDashboardData function\n    const fetchDashboardData = async () => {\n      try {\n        loading.value = true;\n        const teacherId = store.state.auth.user._id;\n        if (!teacherId) {\n          console.error('Teacher ID not available');\n          loading.value = false;\n          return;\n        }\n\n        // Prepare query parameters with URLSearchParams for consistency\n        const params = new URLSearchParams();\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedSubject.value) params.append('subject', selectedSubject.value);\n        if (selectedStartDate.value) params.append('startDate', selectedStartDate.value);\n        if (selectedEndDate.value) params.append('endDate', selectedEndDate.value);\n        console.log('Fetching dashboard data with params:', Object.fromEntries(params));\n\n        // Fetch dashboard stats\n        const url = `http://localhost:8000/api/dashboard/teacher/${teacherId}/stats?${params.toString()}`;\n        console.log('Requesting URL:', url);\n        const response = await axios.get(url, {\n          headers: {\n            'Authorization': `Bearer ${store.state.auth.token}`\n          }\n        });\n        console.log('Dashboard data received:', response.data);\n\n        // Store complete data for reference\n        data.value = response.data;\n\n        // Check if we received any meaningful data (indicating valid filters)\n        const hasValidData = response.data.totalStudents > 0 || response.data.totalSections > 0 || Array.isArray(response.data.attendanceDistribution) && response.data.attendanceDistribution.some(val => val > 0) || Array.isArray(response.data.performanceTrends) && response.data.performanceTrends.length > 0;\n\n        // If no valid data, it means the filter combination doesn't match any records\n        if (!hasValidData && (selectedYear.value || selectedSection.value || selectedSubject.value)) {\n          console.warn('No data found for the selected filters');\n        }\n\n        // Update stats - only when we have valid data or no filters applied\n        totalStudents.value = response.data.totalStudents || 0;\n        totalSections.value = response.data.totalSections || 0;\n        totalSubjects.value = response.data.totalSubjects || 0;\n\n        // Debug the class average score from API response\n        console.log('Average score from API:', response.data.averageScore);\n        console.log('Average score type:', typeof response.data.averageScore);\n\n        // Update class average score from the response\n        if (response.data.hasOwnProperty('averageScore')) {\n          const scoreValue = parseFloat(response.data.averageScore);\n          console.log('Parsed score value:', scoreValue);\n          averageScore.value = isNaN(scoreValue) ? '0.0' : scoreValue.toFixed(1);\n          console.log('Final average score value:', averageScore.value);\n        } else {\n          averageScore.value = '0.0';\n        }\n\n        // Update activities\n        recentActivities.value = response.data.recentActivities || [];\n\n        // ALWAYS fetch attendance data separately to ensure we have the latest\n        await fetchAttendanceData();\n\n        // Fetch assessment data separately\n        await fetchAssessmentData();\n\n        // After updating the charts, apply the default filter (month) to each chart\n        // This ensures the charts' data is consistent with the filter state\n        const endDate = moment().format('YYYY-MM-DD');\n        const startDate = moment().subtract(30, 'days').format('YYYY-MM-DD');\n        await Promise.all([fetchChartData('attendance', startDate, endDate), fetchChartData('assessmentType', startDate, endDate), fetchChartData('performanceTrend', startDate, endDate), fetchChartData('assessmentTypePerformance', startDate, endDate)]);\n        loading.value = false;\n      } catch (error) {\n        console.error('Error fetching dashboard data:', error);\n        // Initialize charts with empty data\n        initEmptyCharts();\n        loading.value = false;\n      }\n    };\n\n    // Add a dedicated function to fetch attendance data\n    const fetchAttendanceData = async () => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n\n        // Prepare attendance parameters\n        const params = new URLSearchParams();\n        params.append('teacherId', teacherId);\n\n        // Add date range - default to last 30 days if not specified\n        params.append('startDate', selectedStartDate.value || moment().subtract(30, 'days').format('YYYY-MM-DD'));\n        params.append('endDate', selectedEndDate.value || moment().format('YYYY-MM-DD'));\n\n        // Add filters if selected\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedSubject.value) params.append('subject', selectedSubject.value);\n        console.log('Fetching attendance data with params:', Object.fromEntries(params));\n        const url = `http://localhost:8000/api/attendance/stats?${params.toString()}`;\n        console.log('Requesting URL:', url);\n        const response = await axios.get(url, {\n          headers: {\n            'Authorization': `Bearer ${store.state.auth.token}`\n          }\n        });\n        console.log('Attendance data received:', response.data);\n        if (response.data) {\n          // Store in chartData for export\n          chartData.value.attendance = response.data;\n\n          // Parse attendance counts\n          const present = parseInt(response.data.present) || 0;\n          const late = parseInt(response.data.late) || 0;\n          const absent = parseInt(response.data.absent) || 0;\n\n          // Update main data store\n          if (data.value) {\n            data.value.attendanceDistribution = [present, late, absent];\n          }\n\n          // Update attendance chart\n          updatePerformanceChart({\n            attendanceDistribution: [present, late, absent]\n          });\n          console.log('Attendance distribution updated:', [present, late, absent]);\n          return true;\n        }\n        return false;\n      } catch (error) {\n        console.error('Error fetching attendance data:', error);\n\n        // Initialize with empty data on error\n        if (data.value) {\n          data.value.attendanceDistribution = [0, 0, 0];\n        }\n        updatePerformanceChart({\n          attendanceDistribution: [0, 0, 0]\n        });\n        return false;\n      }\n    };\n    const updatePerformanceChart = data => {\n      if (!performanceChart.value) return;\n      const ctx = performanceChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process attendance distribution data\n      // Expected data format: [present, late, absent]\n      const attendanceData = Array.isArray(data.attendanceDistribution) ? data.attendanceDistribution.slice(0, 3) : [0, 0, 0];\n      console.log('Attendance distribution data:', attendanceData);\n\n      // Calculate total attendance records\n      const totalAttendance = attendanceData.reduce((a, b) => a + (b || 0), 0);\n\n      // Create attendance distribution chart\n      new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n          labels: ['Present', 'Late', 'Absent'],\n          datasets: [{\n            data: attendanceData,\n            backgroundColor: ['rgba(52, 211, 153, 0.8)',\n            // Green for present\n            'rgba(251, 191, 36, 0.8)',\n            // Yellow for late\n            'rgba(239, 68, 68, 0.8)' // Red for absent\n            ],\n            borderColor: ['rgb(15, 140, 80)',\n            // Darker borders for contrast\n            'rgb(220, 160, 20)', 'rgb(220, 50, 50)'],\n            borderWidth: 1,\n            hoverOffset: 15\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          cutout: '60%',\n          plugins: {\n            legend: {\n              display: true,\n              position: 'bottom',\n              labels: {\n                padding: 20,\n                font: {\n                  size: 12\n                }\n              }\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const value = context.raw || 0;\n                  const total = attendanceData.reduce((a, b) => a + (b || 0), 0);\n                  const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;\n                  return `${context.label}: ${value} (${percentage}%)`;\n                }\n              },\n              titleFont: {\n                weight: 'bold',\n                size: 14\n              },\n              bodyFont: {\n                size: 13\n              },\n              backgroundColor: 'rgba(0, 0, 0, 0.8)',\n              padding: 12,\n              cornerRadius: 8\n            }\n          },\n          layout: {\n            padding: {\n              top: 10,\n              right: 20,\n              bottom: 10,\n              left: 20\n            }\n          }\n        }\n      });\n    };\n    const updateAssessmentTypeChart = data => {\n      if (!assessmentTypeChart.value) return;\n      const ctx = assessmentTypeChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process incoming data to restructure it\n      const assessmentTypes = ['Quiz', 'Activity', 'Performance Task'];\n\n      // Check if we have valid data\n      if (!data.assessmentData || !Array.isArray(data.assessmentData) || data.assessmentData.length === 0) {\n        // If no assessment data, just return without creating a chart\n        // The \"No data available\" message will be shown by the template\n        console.log('No assessment data available, skipping chart creation');\n        return;\n      }\n\n      // Process actual data\n      const processedData = {\n        types: [],\n        scores: [],\n        counts: []\n      };\n\n      // Filter out assessment types with data\n      const availableTypes = [...new Set(data.assessmentData.map(item => item.type))];\n\n      // For each available type, get the score and count\n      availableTypes.forEach(type => {\n        const typeData = data.assessmentData.find(a => a.type === type);\n        if (typeData) {\n          processedData.types.push(type);\n          processedData.scores.push(parseFloat(typeData.averageScore) || 0);\n          processedData.counts.push(typeData.count || 0);\n        }\n      });\n      console.log('Processed assessment chart data:', processedData);\n\n      // Create a simple bar chart showing average scores\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: processedData.types,\n          datasets: [{\n            label: 'Average Score (%)',\n            data: processedData.scores,\n            backgroundColor: ['rgba(52, 211, 153, 0.8)',\n            // Green for Quiz\n            'rgba(59, 130, 246, 0.8)',\n            // Blue for Activity\n            'rgba(251, 191, 36, 0.8)' // Yellow for Performance Task\n            ].slice(0, processedData.types.length),\n            borderColor: ['rgb(15, 140, 80)', 'rgb(45, 110, 220)', 'rgb(220, 160, 20)'].slice(0, processedData.types.length),\n            borderWidth: 1,\n            borderRadius: 6,\n            barPercentage: 0.6\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              grid: {\n                color: 'rgba(0, 0, 0, 0.05)'\n              },\n              title: {\n                display: true,\n                text: 'Average Score (%)',\n                font: {\n                  size: 14,\n                  weight: 'bold'\n                }\n              },\n              ticks: {\n                font: {\n                  size: 12\n                }\n              }\n            },\n            x: {\n              grid: {\n                display: false\n              }\n            }\n          },\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const label = context.dataset.label || '';\n                  const value = context.raw || 0;\n                  return `${label}: ${value}%`;\n                },\n                afterLabel: context => {\n                  const type = processedData.types[context.dataIndex];\n                  const count = processedData.counts[context.dataIndex] || 0;\n                  return `Total ${type}s: ${count}`;\n                }\n              },\n              titleFont: {\n                size: 14,\n                weight: 'bold'\n              },\n              bodyFont: {\n                size: 13\n              },\n              padding: 12\n            }\n          }\n        }\n      });\n    };\n    const updatePerformanceTrendChart = data => {\n      if (!performanceTrendChart.value) {\n        console.warn('Performance trend chart reference not found');\n        return;\n      }\n      const ctx = performanceTrendChart.value.getContext('2d');\n      if (!ctx) {\n        console.warn('Could not get 2d context for performance trend chart');\n        return;\n      }\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) {\n        existingChart.destroy();\n      }\n\n      // Ensure data is valid\n      const validData = Array.isArray(data) ? data : [];\n      console.log('Creating performance trend chart with data:', validData);\n      new Chart(ctx, {\n        type: 'line',\n        data: {\n          labels: validData.map(d => moment(d.date).format('MMM D, YYYY')),\n          datasets: [{\n            label: 'Average Score',\n            data: validData.map(d => Number(d.score) || 0),\n            borderColor: '#4CAF50',\n            backgroundColor: 'rgba(76, 175, 80, 0.1)',\n            tension: 0.4,\n            fill: true,\n            pointRadius: 4,\n            pointHoverRadius: 6\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const dataPoint = validData[context.dataIndex];\n                  return `${dataPoint.name}: ${(context.raw || 0).toFixed(1)}%`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              ticks: {\n                stepSize: 20,\n                font: {\n                  size: 12\n                }\n              },\n              title: {\n                display: true,\n                text: 'Average Score (%)',\n                font: {\n                  size: 14,\n                  weight: 'bold'\n                }\n              }\n            },\n            x: {\n              ticks: {\n                font: {\n                  size: 12\n                },\n                maxRotation: 45,\n                minRotation: 45\n              }\n            }\n          }\n        }\n      });\n    };\n    const updateAssessmentTypePerformanceChart = data => {\n      if (!assessmentTypePerformanceChart.value) return;\n      const ctx = assessmentTypePerformanceChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process the performance trends data by assessment type\n      const trendsByType = {\n        Quiz: [],\n        Activity: [],\n        'Performance Task': []\n      };\n\n      // Process performance trends data\n      if (Array.isArray(data.performanceTrends)) {\n        data.performanceTrends.forEach(trend => {\n          const type = trend.type || trend.name;\n          if (type in trendsByType) {\n            trendsByType[type].push({\n              date: new Date(trend.date),\n              score: parseFloat(trend.score) || 0\n            });\n          }\n        });\n      }\n\n      // Sort data points by date for each type\n      Object.keys(trendsByType).forEach(type => {\n        trendsByType[type].sort((a, b) => a.date - b.date);\n      });\n\n      // Get unique dates across all types\n      const allDates = [...new Set(Object.values(trendsByType).flat().map(item => item.date))].sort((a, b) => a - b);\n\n      // Create datasets\n      const datasets = Object.entries(trendsByType).map(([type, data], index) => {\n        const colors = ['rgb(52, 211, 153)',\n        // Green for Quiz\n        'rgb(59, 130, 246)',\n        // Blue for Activity\n        'rgb(251, 191, 36)' // Yellow for Performance Task\n        ];\n        const color = colors[index];\n        return {\n          label: type,\n          data: allDates.map(date => {\n            const point = data.find(d => d.date.getTime() === date.getTime());\n            return point ? point.score : null;\n          }),\n          borderColor: color,\n          backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),\n          fill: true,\n          tension: 0.4,\n          pointRadius: 4,\n          pointHoverRadius: 6,\n          spanGaps: true // This will connect points even if there are null values\n        };\n      });\n      new Chart(ctx, {\n        type: 'line',\n        data: {\n          labels: allDates.map(date => moment(date).format('MMM D, YYYY')),\n          datasets\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          interaction: {\n            intersect: false,\n            mode: 'index'\n          },\n          plugins: {\n            legend: {\n              position: 'top'\n            },\n            tooltip: {\n              callbacks: {\n                label: context => {\n                  const value = context.raw !== null ? context.raw.toFixed(1) : 'N/A';\n                  return `${context.dataset.label}: ${value}%`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              title: {\n                display: true,\n                text: 'Score (%)'\n              }\n            },\n            x: {\n              ticks: {\n                maxRotation: 45,\n                minRotation: 45\n              }\n            }\n          }\n        }\n      });\n    };\n    const formatDate = date => {\n      return moment(date).format('MMM D, YYYY');\n    };\n    const applyFilters = async () => {\n      // Save selected values to localStorage\n      if (selectedYear.value) {\n        localStorage.setItem('selectedYear', selectedYear.value);\n      } else {\n        localStorage.removeItem('selectedYear');\n      }\n      if (selectedSection.value) {\n        localStorage.setItem('selectedSection', selectedSection.value);\n      } else {\n        localStorage.removeItem('selectedSection');\n      }\n      if (selectedSubject.value) {\n        localStorage.setItem('selectedSubject', selectedSubject.value);\n      } else {\n        localStorage.removeItem('selectedSubject');\n      }\n      await fetchDashboardData();\n    };\n\n    // Watch for filter changes\n    watch(selectedYear, handleYearChange);\n    watch([selectedSection, selectedSubject], applyFilters);\n    watch([selectedStartDate, selectedEndDate], () => {\n      if (selectedStartDate.value && selectedEndDate.value) {\n        // Validate date range\n        const start = moment(selectedStartDate.value);\n        const end = moment(selectedEndDate.value);\n        if (end.isBefore(start)) {\n          selectedEndDate.value = selectedStartDate.value;\n        }\n        fetchDashboardData();\n      }\n    });\n    const fetchAssessmentData = async () => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n\n        // Prepare query parameters\n        const params = {\n          teacherId,\n          year: selectedYear.value || '',\n          section: selectedSection.value || '',\n          subject: selectedSubject.value || ''\n        };\n        if (selectedStartDate.value) params.startDate = selectedStartDate.value;\n        if (selectedEndDate.value) params.endDate = selectedEndDate.value;\n        console.log('Fetching assessment data with params:', params);\n\n        // Try the assessments/stats endpoint first\n        try {\n          const assessmentResponse = await axios.get('http://localhost:8000/api/assessments/stats', {\n            params,\n            headers: {\n              'Authorization': `Bearer ${store.state.auth.token}`\n            }\n          });\n          processAssessmentResponse(assessmentResponse.data);\n        } catch (error) {\n          // If the first endpoint fails, try the fallback endpoint\n          console.log('Falling back to /assessments endpoint');\n          const assessmentResponse = await axios.get('http://localhost:8000/api/assessments', {\n            params,\n            headers: {\n              'Authorization': `Bearer ${store.state.auth.token}`\n            }\n          });\n          processAssessmentResponse(assessmentResponse.data);\n        }\n      } catch (error) {\n        console.error('Error fetching assessment data:', error);\n        // Initialize assessment charts with empty data\n        updateAssessmentTypeChart({\n          assessmentData: []\n        });\n        updatePerformanceTrendChart([]);\n        updateAssessmentTypePerformanceChart({\n          performanceTrends: []\n        });\n      }\n    };\n\n    // Helper function to process assessment response data\n    const processAssessmentResponse = data => {\n      if (data) {\n        console.log('Assessment data received:', data);\n\n        // Update assessment type charts with this data\n        if (data.assessmentTypes) {\n          const assessmentData = [];\n          Object.keys(data.assessmentTypes).forEach(type => {\n            const typeData = data.assessmentTypes[type];\n            if (typeData) {\n              let avgScore = 0;\n              if (typeData.scoreCount && typeData.scoreCount > 0) {\n                avgScore = (typeData.totalScore / typeData.scoreCount).toFixed(1);\n              }\n              assessmentData.push({\n                type: type,\n                averageScore: avgScore,\n                count: typeData.count || 0\n              });\n            }\n          });\n          updateAssessmentTypeChart({\n            assessmentData\n          });\n        } else if (Array.isArray(data)) {\n          // If data is an array of assessments, process it into the format we need\n          const assessmentTypes = {\n            'Quiz': {\n              count: 0,\n              totalScore: 0,\n              scoreCount: 0\n            },\n            'Activity': {\n              count: 0,\n              totalScore: 0,\n              scoreCount: 0\n            },\n            'Performance Task': {\n              count: 0,\n              totalScore: 0,\n              scoreCount: 0\n            }\n          };\n\n          // Process raw assessment data\n          data.forEach(assessment => {\n            const type = assessment.type || 'Other';\n            if (assessmentTypes[type]) {\n              assessmentTypes[type].count++;\n\n              // Process scores if available\n              if (assessment.scores) {\n                // Handle both array and object formats\n                let scoreArray = [];\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (typeof assessment.scores === 'object') {\n                  scoreArray = Object.values(assessment.scores);\n                }\n                scoreArray.forEach(score => {\n                  if (typeof score === 'number') {\n                    assessmentTypes[type].totalScore += score;\n                    assessmentTypes[type].scoreCount++;\n                  }\n                });\n              }\n            }\n          });\n\n          // Convert to format for chart\n          const assessmentData = Object.keys(assessmentTypes).map(type => {\n            const typeData = assessmentTypes[type];\n            const averageScore = typeData.scoreCount > 0 ? (typeData.totalScore / typeData.scoreCount).toFixed(1) : 0;\n            return {\n              type,\n              averageScore,\n              count: typeData.count\n            };\n          });\n          updateAssessmentTypeChart({\n            assessmentData\n          });\n\n          // Create performance trends data\n          const performanceTrends = data.filter(a => a.date) // Only include assessments with dates\n          .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n          .map(assessment => {\n            // Calculate average score for this assessment\n            let averageScore = 0;\n            let scoreArray = [];\n            if (assessment.scores) {\n              if (Array.isArray(assessment.scores)) {\n                scoreArray = assessment.scores;\n              } else if (typeof assessment.scores === 'object') {\n                scoreArray = Object.values(assessment.scores);\n              }\n              const validScores = scoreArray.filter(score => typeof score === 'number');\n              if (validScores.length > 0) {\n                const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                averageScore = totalScore / validScores.length;\n              }\n            }\n            return {\n              date: assessment.date,\n              score: averageScore,\n              name: assessment.name || assessment.title || assessment.type,\n              type: assessment.type\n            };\n          });\n          updatePerformanceTrendChart(performanceTrends);\n          updateAssessmentTypePerformanceChart({\n            performanceTrends\n          });\n        }\n      }\n    };\n    onMounted(async () => {\n      if (store.state.auth.user?._id && store.state.auth.token) {\n        console.log('Component mounted, initializing...');\n\n        // Wait for the next tick to ensure DOM elements are rendered\n        await nextTick();\n        try {\n          // Initialize empty charts first\n          console.log('Initializing empty charts...');\n          initEmptyCharts();\n          console.log('Empty charts initialized');\n\n          // Fetch sections and subjects\n          await fetchTeacherSectionsAndSubjects(selectedYear.value);\n          console.log('Sections and subjects fetched');\n\n          // Fetch actual dashboard data\n          await fetchDashboardData();\n          console.log('Initial data fetch completed');\n        } catch (error) {\n          console.error('Error during initialization:', error);\n        }\n      } else {\n        console.error('No user ID or token found');\n      }\n\n      // Add default chart filter periods\n      Object.keys(chartFilters.value).forEach(chartType => {\n        chartFilters.value[chartType].period = 'month';\n      });\n    });\n    return {\n      totalStudents,\n      totalSections,\n      totalSubjects,\n      averageScore,\n      performanceChart,\n      recentActivities,\n      sections,\n      subjects,\n      selectedYear,\n      selectedSection,\n      selectedSubject,\n      hasAttendanceData,\n      hasPerformanceData,\n      hasAssessmentData,\n      hasActivity,\n      formatDate,\n      getFilterDisplay,\n      handleYearChange,\n      applyFilters,\n      assessmentTypeChart,\n      performanceTrendChart,\n      assessmentTypePerformanceChart,\n      selectedStartDate,\n      selectedEndDate,\n      today,\n      loading,\n      availableYears,\n      userName,\n      chartFilters,\n      applyChartDateFilter,\n      generateChartData\n    };\n  }\n};","map":{"version":3,"names":["ref","onMounted","computed","watch","nextTick","useStore","Chart","axios","moment","saveAs","XLSX","jsPDF","html2canvas","name","setup","store","performanceChart","attendanceChart","assessmentTypeChart","performanceTrendChart","assessmentTypePerformanceChart","totalStudents","totalSections","totalSubjects","averageScore","recentActivities","sections","subjects","selectedYear","localStorage","getItem","selectedSection","selectedSubject","selectedStartDate","selectedEndDate","today","format","chartFilters","attendance","period","assessmentType","performanceTrend","assessmentTypePerformance","chartData","availableYears","getTeacherId","user","state","auth","_id","console","error","hasAttendanceData","data","value","attendanceDistribution","distribution","Array","isArray","length","some","val","numVal","Number","isNaN","present","late","absent","err","hasPerformanceData","performanceTrends","assessmentTypes","Object","values","type","count","hasAssessmentData","assessmentTypeDistribution","hasActivity","loading","userName","firstName","lastName","trim","fetchTeacherSectionsAndSubjects","year","teacherId","token","log","recordsResponse","get","params","headers","uniqueYears","Set","map","record","filter","Boolean","sort","filteredRecords","section","subject","uniqueSections","uniqueSubjects","warn","handleYearChange","fetchDashboardData","getFilterDisplay","filters","push","join","initEmptyCharts","updatePerformanceChart","updateAssessmentTypeChart","assessmentData","updatePerformanceTrendChart","updateAssessmentTypePerformanceChart","applyChartDateFilter","chartType","endDate","startDate","subtract","fetchChartData","URLSearchParams","append","fromEntries","endpoint","url","Error","toString","response","attendanceStats","parseInt","formattedData","keys","forEach","typeData","avgScore","scoreCount","totalScore","toFixed","a","date","b","Date","assessment","scoreArray","scores","validScores","score","reduce","sum","title","generateFallbackPDF","dataToExport","fileName","doc","setFontSize","text","toUpperCase","align","toLocaleString","tableColumn","tableRows","item","String","autoTable","startY","head","body","theme","save","generateChartData","chart","getChart","datasets","labels","index","undefined","chartErr","trend","dataset","label","alert","JSON","stringify","worksheet","utils","json_to_sheet","workbook","book_new","book_append_sheet","excelBuffer","write","bookType","excelData","Blob","pdfGenerated","orientation","unit","setFont","setTextColor","internal","pageSize","getWidth","dateText","filterText","periodText","headStyles","fillColor","textColor","fontStyle","halign","styles","fontSize","cellPadding","overflow","margin","top","right","bottom","left","tableError","message","find","i","Status","Count","total","presentPercent","latePercent","absentPercent","finalY","lastAutoTable","barWidth","barHeight","startX","presentWidth","setFillColor","rect","lateWidth","absentWidth","legendY","summaryError","pageCount","getNumberOfPages","teacherName","setPage","pageHeight","getHeight","saveError","pdfError","fallbackSuccess","hasValidData","hasOwnProperty","scoreValue","parseFloat","fetchAttendanceData","fetchAssessmentData","Promise","all","ctx","getContext","existingChart","destroy","attendanceData","slice","totalAttendance","backgroundColor","borderColor","borderWidth","hoverOffset","options","responsive","maintainAspectRatio","cutout","plugins","legend","display","position","padding","font","size","tooltip","callbacks","context","raw","percentage","titleFont","weight","bodyFont","cornerRadius","layout","processedData","types","counts","availableTypes","borderRadius","barPercentage","scales","y","beginAtZero","max","grid","color","ticks","x","afterLabel","dataIndex","validData","d","tension","fill","pointRadius","pointHoverRadius","dataPoint","stepSize","maxRotation","minRotation","trendsByType","Quiz","Activity","allDates","flat","entries","colors","point","getTime","replace","spanGaps","interaction","intersect","mode","formatDate","applyFilters","setItem","removeItem","start","end","isBefore","assessmentResponse","processAssessmentResponse"],"sources":["D:\\au_dev\\client\\src\\views\\TeacherDashboard.vue"],"sourcesContent":["<template>\n  <div class=\"dashboard\">\n    <!-- Greeting Section -->\n    <div class=\"greeting-section mb-4\">\n      <h2 class=\"greeting\">Welcome, {{ userName }}</h2>\n      <p class=\"greeting-subtitle\">Here's your dashboard overview</p>\n    </div>\n    \n    <div class=\"d-flex justify-content-between align-items-center mb-4\">\n      <h2 class=\"dashboard-title\"></h2>\n      \n      <!-- Combined Filter Dropdown -->\n      <div class=\"dropdown\">\n        <button class=\"btn btn-filter dropdown-toggle\" type=\"button\" id=\"filterDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n          <i class=\"fas fa-filter me-2\"></i>\n          {{ getFilterDisplay() }}\n        </button>\n        <div class=\"dropdown-menu filter-menu p-3\" aria-labelledby=\"filterDropdown\">\n          <h6 class=\"dropdown-header\">Filter Options</h6>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Academic Year</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedYear\" @change=\"handleYearChange\">\n              <option value=\"\">All Years</option>\n              <option v-for=\"year in availableYears\" :key=\"year\" :value=\"year\">{{ year }}</option>\n            </select>\n          </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Section</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedSection\" :disabled=\"!selectedYear\">\n              <option value=\"\">All Sections</option>\n              <option v-for=\"section in sections\" :key=\"section\" :value=\"section\">{{ section }}</option>\n            </select>\n          </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Subject</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedSubject\" :disabled=\"!selectedYear\">\n              <option value=\"\">All Subjects</option>\n              <option v-for=\"subject in subjects\" :key=\"subject\" :value=\"subject\">{{ subject }}</option>\n            </select>\n          </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Date Range</label>\n            <div class=\"d-flex gap-2\">\n              <div class=\"flex-grow-1\">\n                <label class=\"small text-muted\">From</label>\n                <input \n                  type=\"date\" \n                  class=\"form-control form-control-sm\" \n                  v-model=\"selectedStartDate\"\n                  :max=\"today\"\n                >\n              </div>\n              <div class=\"flex-grow-1\">\n                <label class=\"small text-muted\">To</label>\n                <input \n                  type=\"date\" \n                  class=\"form-control form-control-sm\" \n                  v-model=\"selectedEndDate\"\n                  :max=\"today\"\n                >\n              </div>\n            </div>\n          </div>\n          <div class=\"dropdown-divider\"></div>\n          <button class=\"btn btn-primary w-100\" @click=\"applyFilters\" :disabled=\"loading\">\n            <span v-if=\"loading\"><i class=\"fas fa-spinner fa-spin me-2\"></i>Loading...</span>\n            <span v-else>Apply Filters</span>\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <!-- Analytics Cards -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Total Students Card -->\n      <div class=\"col-md-3\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n            <i class=\"fas fa-user-graduate\"></i>\n          </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Students</h3>\n            <div class=\"stat-value\" v-if=\"!loading\">{{ totalStudents }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Total Sections Card -->\n      <div class=\"col-md-3\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n            <i class=\"fas fa-chalkboard\"></i>\n          </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Active Sections</h3>\n            <div class=\"stat-value\" v-if=\"!loading\">{{ totalSections }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Total Subjects Card -->\n      <div class=\"col-md-3\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n            <i class=\"fas fa-book\"></i>\n          </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">My Subjects</h3>\n            <div class=\"stat-value\" v-if=\"!loading\">{{ totalSubjects }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Average Score Card -->\n      <div class=\"col-md-3\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n            <i class=\"fas fa-chart-line\"></i>\n          </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Class Average</h3>\n            <div class=\"stat-value\" v-if=\"!loading && hasPerformanceData\">{{ averageScore }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"loading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Charts Row -->\n    <div class=\"row mb-4\">\n      <!-- Attendance Distribution Chart (previously Performance Distribution) -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-calendar-check me-2\"></i>\n              Attendance Distribution\n            </h5>\n            <p class=\"chart-description\">Breakdown of student attendance patterns</p>\n            <div class=\"chart-filters mb-3\">\n              <div class=\"btn-group date-filter-group\">\n                <button @click=\"applyChartDateFilter('attendance', 'day')\" :class=\"['btn', 'btn-sm', chartFilters?.attendance?.period === 'day' ? 'btn-primary' : 'btn-outline-primary']\">Day</button>\n                <button @click=\"applyChartDateFilter('attendance', 'week')\" :class=\"['btn', 'btn-sm', chartFilters?.attendance?.period === 'week' ? 'btn-primary' : 'btn-outline-primary']\">Week</button>\n                <button @click=\"applyChartDateFilter('attendance', 'month')\" :class=\"['btn', 'btn-sm', chartFilters?.attendance?.period === 'month' ? 'btn-primary' : 'btn-outline-primary']\">Month</button>\n              </div>\n            </div>\n            <div class=\"chart-container\">\n              <div v-if=\"loading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"performanceChart\"></canvas>\n              <p v-if=\"!hasAttendanceData && !loading\" class=\"no-data-message\">No attendance data available</p>\n            </div>\n            <div class=\"text-end mt-3\">\n              <div class=\"dropdown d-inline-block\">\n                <button class=\"btn btn-sm btn-outline-success dropdown-toggle\" type=\"button\" id=\"generateAttendanceDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\" :disabled=\"!hasAttendanceData || loading\">\n                  <i class=\"fas fa-download me-1\"></i> Generate\n                </button>\n                <ul class=\"dropdown-menu dropdown-menu-end\" aria-labelledby=\"generateAttendanceDropdown\">\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('attendance', 'excel')\"><i class=\"fas fa-file-excel me-2\"></i>Excel</a></li>\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('attendance', 'pdf')\"><i class=\"fas fa-file-pdf me-2\"></i>PDF</a></li>\n                </ul>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Assessment Type Distribution -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-tasks me-2\"></i>\n              Assessment Performance Analysis\n            </h5>\n            <p class=\"chart-description\">Average scores by assessment type</p>\n            <div class=\"chart-filters mb-3\">\n              <div class=\"btn-group date-filter-group\">\n                <button @click=\"applyChartDateFilter('assessmentType', 'day')\" :class=\"['btn', 'btn-sm', chartFilters?.assessmentType?.period === 'day' ? 'btn-primary' : 'btn-outline-primary']\">Day</button>\n                <button @click=\"applyChartDateFilter('assessmentType', 'week')\" :class=\"['btn', 'btn-sm', chartFilters?.assessmentType?.period === 'week' ? 'btn-primary' : 'btn-outline-primary']\">Week</button>\n                <button @click=\"applyChartDateFilter('assessmentType', 'month')\" :class=\"['btn', 'btn-sm', chartFilters?.assessmentType?.period === 'month' ? 'btn-primary' : 'btn-outline-primary']\">Month</button>\n              </div>\n            </div>\n            <div class=\"chart-container\">\n              <div v-if=\"loading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"assessmentTypeChart\"></canvas>\n              <p v-if=\"!hasAssessmentData && !loading\" class=\"no-data-message\">No assessment data available</p>\n            </div>\n            <div class=\"text-end mt-3\">\n              <div class=\"dropdown d-inline-block\">\n                <button class=\"btn btn-sm btn-outline-success dropdown-toggle\" type=\"button\" id=\"generateAssessmentTypeDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\" :disabled=\"!hasAssessmentData || loading\">\n                  <i class=\"fas fa-download me-1\"></i> Generate\n                </button>\n                <ul class=\"dropdown-menu dropdown-menu-end\" aria-labelledby=\"generateAssessmentTypeDropdown\">\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('assessmentType', 'excel')\"><i class=\"fas fa-file-excel me-2\"></i>Excel</a></li>\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('assessmentType', 'pdf')\"><i class=\"fas fa-file-pdf me-2\"></i>PDF</a></li>\n                </ul>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Performance Trend Chart -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-chart-line me-2\"></i>\n              Performance Trends Over Time\n            </h5>\n            <p class=\"chart-description\">Class average scores across recent assessments</p>\n            <div class=\"chart-filters mb-3\">\n              <div class=\"btn-group date-filter-group\">\n                <button @click=\"applyChartDateFilter('performanceTrend', 'day')\" :class=\"['btn', 'btn-sm', chartFilters?.performanceTrend?.period === 'day' ? 'btn-primary' : 'btn-outline-primary']\">Day</button>\n                <button @click=\"applyChartDateFilter('performanceTrend', 'week')\" :class=\"['btn', 'btn-sm', chartFilters?.performanceTrend?.period === 'week' ? 'btn-primary' : 'btn-outline-primary']\">Week</button>\n                <button @click=\"applyChartDateFilter('performanceTrend', 'month')\" :class=\"['btn', 'btn-sm', chartFilters?.performanceTrend?.period === 'month' ? 'btn-primary' : 'btn-outline-primary']\">Month</button>\n              </div>\n            </div>\n            <div class=\"chart-container\">\n              <div v-if=\"loading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"performanceTrendChart\"></canvas>\n              <p v-if=\"!hasPerformanceData && !loading\" class=\"no-data-message\">No performance data available</p>\n            </div>\n            <div class=\"text-end mt-3\">\n              <div class=\"dropdown d-inline-block\">\n                <button class=\"btn btn-sm btn-outline-success dropdown-toggle\" type=\"button\" id=\"generatePerformanceTrendDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\" :disabled=\"!hasPerformanceData || loading\">\n                  <i class=\"fas fa-download me-1\"></i> Generate\n                </button>\n                <ul class=\"dropdown-menu dropdown-menu-end\" aria-labelledby=\"generatePerformanceTrendDropdown\">\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('performanceTrend', 'excel')\"><i class=\"fas fa-file-excel me-2\"></i>Excel</a></li>\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('performanceTrend', 'pdf')\"><i class=\"fas fa-file-pdf me-2\"></i>PDF</a></li>\n                </ul>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Assessment Type Performance -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-graduation-cap me-2\"></i>\n              Performance by Assessment Type\n            </h5>\n            <p class=\"chart-description\">Visualizes how students perform across different assessment types</p>\n            <div class=\"chart-filters mb-3\">\n              <div class=\"btn-group date-filter-group\">\n                <button @click=\"applyChartDateFilter('assessmentTypePerformance', 'day')\" :class=\"['btn', 'btn-sm', chartFilters?.assessmentTypePerformance?.period === 'day' ? 'btn-primary' : 'btn-outline-primary']\">Day</button>\n                <button @click=\"applyChartDateFilter('assessmentTypePerformance', 'week')\" :class=\"['btn', 'btn-sm', chartFilters?.assessmentTypePerformance?.period === 'week' ? 'btn-primary' : 'btn-outline-primary']\">Week</button>\n                <button @click=\"applyChartDateFilter('assessmentTypePerformance', 'month')\" :class=\"['btn', 'btn-sm', chartFilters?.assessmentTypePerformance?.period === 'month' ? 'btn-primary' : 'btn-outline-primary']\">Month</button>\n              </div>\n            </div>\n            <div class=\"chart-container\">\n              <div v-if=\"loading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"assessmentTypePerformanceChart\"></canvas>\n              <p v-if=\"!hasPerformanceData && !loading\" class=\"no-data-message\">No performance data available</p>\n            </div>\n            <div class=\"text-end mt-3\">\n              <div class=\"dropdown d-inline-block\">\n                <button class=\"btn btn-sm btn-outline-success dropdown-toggle\" type=\"button\" id=\"generateAssessmentTypePerformanceDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\" :disabled=\"!hasPerformanceData || loading\">\n                  <i class=\"fas fa-download me-1\"></i> Generate\n                </button>\n                <ul class=\"dropdown-menu dropdown-menu-end\" aria-labelledby=\"generateAssessmentTypePerformanceDropdown\">\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('assessmentTypePerformance', 'excel')\"><i class=\"fas fa-file-excel me-2\"></i>Excel</a></li>\n                  <li><a class=\"dropdown-item\" href=\"#\" @click.prevent=\"generateChartData('assessmentTypePerformance', 'pdf')\"><i class=\"fas fa-file-pdf me-2\"></i>PDF</a></li>\n                </ul>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Recent Activity -->\n    <div class=\"card mb-4\">\n      <div class=\"card-body\">\n        <h5 class=\"card-title\">Recent Activity</h5>\n        <div class=\"table-responsive\">\n          <table class=\"table\">\n            <thead>\n              <tr>\n                <th>Date</th>\n                <th>Activity</th>\n                <th>Details</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr v-if=\"loading\">\n                <td colspan=\"3\" class=\"text-center\">\n                  <i class=\"fas fa-spinner fa-spin me-2\"></i>Loading activities...\n                </td>\n              </tr>\n              <tr v-else-if=\"!hasActivity\">\n                <td colspan=\"3\" class=\"text-center\">No recent activity</td>\n              </tr>\n              <tr v-else v-for=\"activity in recentActivities\" :key=\"activity.id\">\n                <td>{{ formatDate(activity.date) }}</td>\n                <td>{{ activity.type }}</td>\n                <td>{{ activity.details }}</td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted, computed, watch, nextTick } from 'vue'\nimport { useStore } from 'vuex'\nimport Chart from 'chart.js/auto'\nimport axios from 'axios'\nimport moment from 'moment'\nimport { saveAs } from 'file-saver'\nimport * as XLSX from 'xlsx'\nimport jsPDF from 'jspdf'\nimport 'jspdf-autotable'\nimport html2canvas from 'html2canvas'\n\nexport default {\n  name: 'TeacherDashboard',\n  setup() {\n    const store = useStore()\n    const performanceChart = ref(null)\n    const attendanceChart = ref(null)\n    const assessmentTypeChart = ref(null)\n    const performanceTrendChart = ref(null)\n    const assessmentTypePerformanceChart = ref(null)\n\n    // Data refs\n    const totalStudents = ref(0)\n    const totalSections = ref(0)\n    const totalSubjects = ref(0)\n    const averageScore = ref(0)\n    const recentActivities = ref([])\n    const sections = ref([])\n    const subjects = ref([])\n    \n    // Filter refs\n    const selectedYear = ref(localStorage.getItem('selectedYear') || '')\n    const selectedSection = ref(localStorage.getItem('selectedSection') || '')\n    const selectedSubject = ref(localStorage.getItem('selectedSubject') || '')\n    const selectedStartDate = ref('')\n    const selectedEndDate = ref('')\n    const today = computed(() => moment().format('YYYY-MM-DD'))\n\n    // Chart date filter state - initialize early to avoid undefined errors\n    const chartFilters = ref({\n      attendance: { period: 'month' },\n      assessmentType: { period: 'month' },\n      performanceTrend: { period: 'month' },\n      assessmentTypePerformance: { period: 'month' }\n    });\n    \n    // Chart raw data for export\n    const chartData = ref({\n      attendance: [],\n      assessmentType: [],\n      performanceTrend: [],\n      assessmentTypePerformance: []\n    });\n\n    // We'll maintain available years that come from the API\n    const availableYears = ref([]);\n\n    // Get teacher ID from store\n    const getTeacherId = () => {\n      const user = store.state.auth.user\n      if (!user || !user._id) {\n        console.error('No teacher ID found in store')\n        return null\n      }\n      return user._id\n    }\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      try {\n        if (data.value && data.value.attendanceDistribution) {\n          // Check if we have an array and if any value is > 0\n          const distribution = data.value.attendanceDistribution;\n          if (Array.isArray(distribution) && distribution.length > 0) {\n            return distribution.some(val => {\n              const numVal = Number(val);\n              return !isNaN(numVal) && numVal > 0;\n            });\n          }\n        }\n        \n        // Also check chartData as a fallback\n        if (chartData.value && chartData.value.attendance) {\n          const attendance = chartData.value.attendance;\n          return !!(\n            (Number(attendance.present) > 0) || \n            (Number(attendance.late) > 0) || \n            (Number(attendance.absent) > 0)\n          );\n        }\n        \n        return false;\n      } catch (err) {\n        console.error('Error in hasAttendanceData:', err);\n        return false;\n      }\n    });\n\n    const hasPerformanceData = computed(() => {\n      // Check if we have any assessment or performance data\n      if (data.value) {\n        // Check for averageScore > 0\n        if (typeof data.value.averageScore === 'number' && data.value.averageScore > 0) {\n          return true;\n        }\n        \n        // Check for performance trends\n        if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n          return true;\n        }\n        \n        // Check for assessment types with data\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n      }\n      return false;\n    });\n\n    const hasAssessmentData = computed(() => {\n      if (data.value) {\n        // Check directly in assessmentTypes\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n        \n        // Fallback to assessmentTypeDistribution\n        if (data.value.assessmentTypeDistribution) {\n          return true;\n        }\n      }\n      return false;\n    });\n\n    const hasActivity = computed(() => recentActivities.value.length > 0)\n\n    // Store all dashboard data in a ref for easier access\n    const data = ref({\n      attendanceDistribution: [0, 0, 0],\n      assessmentTypes: {},\n      performanceTrends: []\n    });\n\n    // In setup function, add loading state\n    const loading = ref(false);\n\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Teacher' : 'Teacher';\n    });\n\n    const fetchTeacherSectionsAndSubjects = async (year = '') => {\n      try {\n        const teacherId = getTeacherId()\n        if (!teacherId) return\n\n        const token = store.state.auth.token\n        console.log('Fetching sections and subjects for:', { teacherId, year })\n\n        // First get all class records to extract sections and years\n        const recordsResponse = await axios.get('http://localhost:8000/api/teacher-class-records', {\n          params: { \n            teacherId\n          },\n          headers: { 'Authorization': `Bearer ${token}` }\n        })\n\n        if (recordsResponse.data && Array.isArray(recordsResponse.data)) {\n          // Extract unique years, sections and subjects\n          const uniqueYears = [...new Set(recordsResponse.data.map(record => record.year))].filter(Boolean);\n          console.log('All unique years found:', uniqueYears);\n          \n          // Save available years\n          availableYears.value = uniqueYears.sort();\n          \n          // Filter sections and subjects based on year if provided\n          if (year) {\n            const filteredRecords = recordsResponse.data.filter(record => record.year === year);\n            sections.value = [...new Set(filteredRecords.map(record => record.section))].filter(Boolean).sort();\n            subjects.value = [...new Set(filteredRecords.map(record => record.subject))].filter(Boolean).sort();\n          } else {\n            const uniqueSections = [...new Set(recordsResponse.data.map(record => record.section))].filter(Boolean);\n            const uniqueSubjects = [...new Set(recordsResponse.data.map(record => record.subject))].filter(Boolean);\n            sections.value = uniqueSections.sort();\n            subjects.value = uniqueSubjects.sort();\n          }\n          \n          // If no selectedYear but we have years\n          if (!selectedYear.value && uniqueYears.length > 0) {\n            selectedYear.value = uniqueYears[0];\n            \n            // Also update sections and subjects for this year\n            const filteredRecords = recordsResponse.data.filter(record => record.year === uniqueYears[0]);\n            sections.value = [...new Set(filteredRecords.map(record => record.section))].filter(Boolean).sort();\n            subjects.value = [...new Set(filteredRecords.map(record => record.subject))].filter(Boolean).sort();\n          }\n          \n          console.log('Loaded sections and subjects:', {\n            availableYears: availableYears.value,\n            sections: sections.value,\n            subjects: subjects.value\n          });\n        } else {\n          console.warn('No class records found or unexpected response format');\n          // Reset all filters and arrays\n          availableYears.value = [];\n          sections.value = [];\n          subjects.value = [];\n        }\n      } catch (error) {\n        console.error('Error fetching teacher sections and subjects:', error)\n        sections.value = []\n        subjects.value = []\n      }\n    }\n\n    const handleYearChange = async () => {\n      // Reset section and subject when year changes\n      selectedSection.value = '';\n      selectedSubject.value = '';\n      \n      // If a year is selected, fetch sections and subjects for that year\n      if (selectedYear.value) {\n        await fetchTeacherSectionsAndSubjects(selectedYear.value);\n      } else {\n        // If no year selected, get all available sections and subjects\n        await fetchTeacherSectionsAndSubjects();\n      }\n      \n      // Update dashboard data with new year selection\n      await fetchDashboardData();\n    }\n\n    const getFilterDisplay = () => {\n      const filters = []\n      if (selectedYear.value) filters.push(selectedYear.value + ' Year')\n      if (selectedSection.value) filters.push(selectedSection.value)\n      if (selectedSubject.value) filters.push(selectedSubject.value)\n      return filters.length > 0 ? filters.join(' - ') : 'Filter View'\n    }\n\n    // Initialize empty data for charts when no data is available\n    const initEmptyCharts = () => {\n      updatePerformanceChart({\n        attendanceDistribution: [0, 0, 0]\n      });\n      \n      updateAssessmentTypeChart({\n        assessmentData: []\n      });\n      \n      updatePerformanceTrendChart([]);\n      \n      updateAssessmentTypePerformanceChart({\n        performanceTrends: []\n      });\n    };\n\n    // Function to apply date filter for a specific chart\n    const applyChartDateFilter = async (chartType, period) => {\n      console.log(`Applying ${period} filter to ${chartType} chart`);\n      \n      // Update the filter period\n      chartFilters.value[chartType].period = period;\n      \n      // Calculate date range based on period\n      const endDate = moment().format('YYYY-MM-DD');\n      let startDate;\n      \n      switch (period) {\n        case 'day':\n          startDate = moment().subtract(1, 'days').format('YYYY-MM-DD');\n          break;\n        case 'week':\n          startDate = moment().subtract(7, 'days').format('YYYY-MM-DD');\n          break;\n        case 'month':\n        default:\n          startDate = moment().subtract(30, 'days').format('YYYY-MM-DD');\n          break;\n      }\n      \n      // Fetch and update the specific chart\n      await fetchChartData(chartType, startDate, endDate);\n    };\n    \n    // Function to fetch data for a specific chart\n    const fetchChartData = async (chartType, startDate, endDate) => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n        \n        // Prepare query parameters with URLSearchParams to ensure proper encoding\n        const params = new URLSearchParams();\n        params.append('teacherId', teacherId);\n        params.append('startDate', startDate);\n        params.append('endDate', endDate);\n        \n        // Add filters if selected\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedSubject.value) params.append('subject', selectedSubject.value);\n        \n        console.log(`Fetching ${chartType} data with params:`, Object.fromEntries(params));\n        \n        let endpoint;\n        let url;\n        \n        switch (chartType) {\n          case 'attendance':\n            endpoint = 'attendance/stats';\n            break;\n          case 'assessmentType':\n          case 'performanceTrend':\n          case 'assessmentTypePerformance':\n            endpoint = 'assessments/stats';\n            break;\n          default:\n            throw new Error(`Unknown chart type: ${chartType}`);\n        }\n        \n        url = `http://localhost:8000/api/${endpoint}?${params.toString()}`;\n        console.log(`Requesting URL: ${url}`);\n        \n        const response = await axios.get(url, {\n          headers: {\n            'Authorization': `Bearer ${store.state.auth.token}`\n          }\n        });\n        \n        console.log(`${chartType} data received:`, response.data);\n        \n        // Store raw data for export\n        chartData.value[chartType] = response.data;\n        \n        // Update the specific chart\n        switch (chartType) {\n          case 'attendance':\n            if (response.data) {\n              // Format the attendance data for our chart\n              const attendanceStats = response.data;\n              \n              // Ensure we have numbers for the chart\n              const present = parseInt(attendanceStats.present) || 0;\n              const late = parseInt(attendanceStats.late) || 0;\n              const absent = parseInt(attendanceStats.absent) || 0;\n              \n              console.log('Attendance stats for chart:', { present, late, absent });\n              \n              const formattedData = {\n                attendanceDistribution: [present, late, absent]\n              };\n              \n              // Update the attendance data in our main data store too\n              if (data.value) {\n                data.value.attendanceDistribution = formattedData.attendanceDistribution;\n              }\n              \n              updatePerformanceChart(formattedData);\n            }\n            break;\n          case 'assessmentType':\n            if (response.data && response.data.assessmentTypes) {\n              const assessmentData = [];\n              \n              Object.keys(response.data.assessmentTypes).forEach(type => {\n                const typeData = response.data.assessmentTypes[type];\n                if (typeData) {\n                  let avgScore = 0;\n                  if (typeData.scoreCount && typeData.scoreCount > 0) {\n                    avgScore = (typeData.totalScore / typeData.scoreCount).toFixed(1);\n                  }\n                  \n                  assessmentData.push({\n                    type: type,\n                    averageScore: avgScore,\n                    count: typeData.count || 0\n                  });\n                }\n              });\n              \n              updateAssessmentTypeChart({ assessmentData });\n            }\n            break;\n          case 'performanceTrend':\n            if (response.data) {\n              // Create performance trends data\n              const performanceTrends = Array.isArray(response.data) ? response.data\n                .filter(a => a.date) // Only include assessments with dates\n                .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n                .map(assessment => {\n                  // Calculate average score for this assessment\n                  let averageScore = 0;\n                  let scoreArray = [];\n                  \n                  if (assessment.scores) {\n                    if (Array.isArray(assessment.scores)) {\n                      scoreArray = assessment.scores;\n                    } else if (typeof assessment.scores === 'object') {\n                      scoreArray = Object.values(assessment.scores);\n                    }\n                    \n                    const validScores = scoreArray.filter(score => typeof score === 'number');\n                    if (validScores.length > 0) {\n                      const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                      averageScore = totalScore / validScores.length;\n                    }\n                  }\n                  \n                  return {\n                    date: assessment.date,\n                    score: averageScore,\n                    name: assessment.name || assessment.title || assessment.type,\n                    type: assessment.type\n                  };\n                }) : [];\n              \n              updatePerformanceTrendChart(performanceTrends);\n            }\n            break;\n          case 'assessmentTypePerformance':\n            if (response.data) {\n              // Create performance trends data for assessment type performance\n              const performanceTrends = Array.isArray(response.data) ? response.data\n                .filter(a => a.date) // Only include assessments with dates\n                .map(assessment => ({\n                  date: assessment.date,\n                  score: assessment.averageScore || 0,\n                  name: assessment.name || assessment.title || assessment.type,\n                  type: assessment.type\n                })) : [];\n              \n              updateAssessmentTypePerformanceChart({\n                performanceTrends\n              });\n            }\n            break;\n        }\n      } catch (error) {\n        console.error(`Error fetching ${chartType} data:`, error);\n        // If the chart type is attendance, ensure we update with empty data\n        if (chartType === 'attendance') {\n          updatePerformanceChart({\n            attendanceDistribution: [0, 0, 0]\n          });\n        }\n      }\n    };\n    \n    // Function to generate and download chart data\n    const generateFallbackPDF = (chartType, dataToExport, fileName) => {\n      try {\n        console.log('Using fallback PDF generation method');\n        \n        // Create simple PDF with minimal formatting\n        const doc = new jsPDF();\n        \n        // Add title\n        doc.setFontSize(16);\n        doc.text(`${chartType.toUpperCase()} REPORT`, 105, 20, { align: 'center' });\n        \n        // Add date\n        doc.setFontSize(10);\n        doc.text(`Generated: ${new Date().toLocaleString()}`, 105, 30, { align: 'center' });\n        \n        // Create simple table with just the data\n        const tableColumn = Object.keys(dataToExport[0]);\n        const tableRows = dataToExport.map(item => {\n          return Object.values(item).map(val => String(val || ''));\n        });\n        \n        // Add basic table\n        doc.autoTable({\n          startY: 40,\n          head: [tableColumn],\n          body: tableRows,\n          theme: 'plain'\n        });\n        \n        // Save\n        doc.save(`${fileName}_simple.pdf`);\n        console.log('Fallback PDF generated successfully');\n        return true;\n      } catch (error) {\n        console.error('Even fallback PDF generation failed:', error);\n        return false;\n      }\n    };\n\n    // Updated generateChartData function with fallback handling\n    const generateChartData = async (chartType, format = 'excel') => {\n      try {\n        console.log(`Generating ${format} for ${chartType} chart`);\n        \n        // Get raw data for the chart\n        let dataToExport = [];\n        let fileName = '';\n        \n        switch (chartType) {\n          case 'attendance':\n            fileName = `attendance_data_${moment().format('YYYY-MM-DD')}`;\n            \n            // Improved attendance data extraction with explicit type conversion\n            let present = 0, late = 0, absent = 0;\n            \n            // Try multiple data sources\n            if (chartData.value[chartType]) {\n              present = Number(chartData.value[chartType].present || 0);\n              late = Number(chartData.value[chartType].late || 0);\n              absent = Number(chartData.value[chartType].absent || 0);\n            } else if (data.value?.attendanceDistribution && Array.isArray(data.value.attendanceDistribution)) {\n              present = Number(data.value.attendanceDistribution[0] || 0);\n              late = Number(data.value.attendanceDistribution[1] || 0);\n              absent = Number(data.value.attendanceDistribution[2] || 0);\n            }\n            \n            console.log('Attendance data for export (processed):', { present, late, absent });\n            \n            // Create export data with explicit typing\n            dataToExport = [\n              {\n                'Status': 'Present',\n                'Count': present\n              },\n              {\n                'Status': 'Late',\n                'Count': late\n              },\n              {\n                'Status': 'Absent',\n                'Count': absent\n              }\n            ];\n            break;\n            \n          case 'assessmentType':\n            fileName = `assessment_types_${moment().format('YYYY-MM-DD')}`;\n            \n            // Format assessment type data for export - improve data extraction\n            if (chartData.value[chartType]?.assessmentTypes) {\n              // Use chartData instead of data\n              const assessmentTypes = chartData.value[chartType].assessmentTypes;\n              Object.keys(assessmentTypes).forEach(type => {\n                const typeData = assessmentTypes[type];\n                if (typeData) {\n                  const avgScore = typeData.averageScore || \n                                  (typeData.scoreCount > 0 ? \n                                    (typeData.totalScore / typeData.scoreCount).toFixed(1) : 0);\n                            \n                  dataToExport.push({\n                    'Assessment Type': type,\n                    'Average Score': avgScore,\n                    'Count': typeData.count || 0\n                  });\n                }\n              });\n            } else if (data.value?.assessmentTypes) {\n              // Fallback to data.value if needed\n              Object.keys(data.value.assessmentTypes).forEach(type => {\n                const typeData = data.value.assessmentTypes[type];\n                if (typeData) {\n                  let avgScore = 0;\n                  if (typeData.scoreCount && typeData.scoreCount > 0) {\n                    avgScore = (typeData.totalScore / typeData.scoreCount).toFixed(1);\n                  } else if (typeData.averageScore) {\n                    avgScore = typeData.averageScore;\n                  }\n                  \n                  dataToExport.push({\n                    'Assessment Type': type,\n                    'Average Score': avgScore,\n                    'Count': typeData.count || 0\n                  });\n                }\n              });\n            }\n            \n            // If still no data, look at chart data directly\n            if (dataToExport.length === 0) {\n              try {\n                const chart = Chart.getChart(assessmentTypeChart.value);\n                if (chart && chart.data?.datasets?.[0]?.data) {\n                  const labels = chart.data.labels || [];\n                  const scores = chart.data.datasets[0].data || [];\n                  \n                  labels.forEach((type, index) => {\n                    if (type && scores[index] !== undefined) {\n                      dataToExport.push({\n                        'Assessment Type': type,\n                        'Average Score': scores[index] || 0,\n                        'Count': 'N/A' // We don't have this information from the chart\n                      });\n                    }\n                  });\n                }\n              } catch (chartErr) {\n                console.error('Error extracting chart data:', chartErr);\n              }\n            }\n            break;\n            \n          case 'performanceTrend':\n            fileName = `performance_trends_${moment().format('YYYY-MM-DD')}`;\n            \n            // Format performance trend data for export - improve data extraction\n            if (Array.isArray(chartData.value[chartType])) {\n              // Use raw assessment data\n              dataToExport = chartData.value[chartType]\n                .filter(assessment => assessment.date)\n                .map(assessment => ({\n                  'Date': moment(assessment.date).format('YYYY-MM-DD'),\n                  'Assessment': assessment.name || assessment.title || '',\n                  'Type': assessment.type || '',\n                  'Average Score': assessment.averageScore || assessment.score || 0\n                }));\n            } else if (data.value?.performanceTrends) {\n              // Fallback to data.value\n              dataToExport = data.value.performanceTrends.map(trend => ({\n                'Date': moment(trend.date).format('YYYY-MM-DD'),\n                'Assessment': trend.name || trend.title || '',\n                'Average Score': trend.score || trend.averageScore || 0\n              }));\n            }\n            \n            // If still no data, extract from chart\n            if (dataToExport.length === 0) {\n              try {\n                const chart = Chart.getChart(performanceTrendChart.value);\n                if (chart && chart.data?.datasets?.[0]?.data) {\n                  const labels = chart.data.labels || [];\n                  const scores = chart.data.datasets[0].data || [];\n                  \n                  labels.forEach((date, index) => {\n                    if (date && scores[index] !== undefined) {\n                      dataToExport.push({\n                        'Date': date,\n                        'Assessment': 'Assessment ' + (index + 1),\n                        'Average Score': scores[index] || 0\n                      });\n                    }\n                  });\n                }\n              } catch (chartErr) {\n                console.error('Error extracting chart data:', chartErr);\n              }\n            }\n            break;\n            \n          case 'assessmentTypePerformance':\n            fileName = `assessment_performance_${moment().format('YYYY-MM-DD')}`;\n            \n            // Format assessment type performance data for export - improve data extraction\n            if (Array.isArray(chartData.value[chartType])) {\n              // Use chartData's raw assessment data\n              dataToExport = chartData.value[chartType]\n                .filter(assessment => assessment.date && assessment.type)\n                .map(assessment => ({\n                  'Date': moment(assessment.date).format('YYYY-MM-DD'),\n                  'Assessment Type': assessment.type || '',\n                  'Assessment Name': assessment.name || assessment.title || '',\n                  'Average Score': assessment.averageScore || assessment.score || 0\n                }));\n            } else if (data.value?.performanceTrends) {\n              // Fallback to data.value\n              dataToExport = data.value.performanceTrends\n                .filter(trend => trend.type)\n                .map(trend => ({\n                  'Date': moment(trend.date).format('YYYY-MM-DD'),\n                  'Assessment Type': trend.type || '',\n                  'Assessment Name': trend.name || trend.title || '',\n                  'Average Score': trend.score || trend.averageScore || 0\n                }));\n            }\n            \n            // If still no data, extract from chart\n            if (dataToExport.length === 0) {\n              try {\n                const chart = Chart.getChart(assessmentTypePerformanceChart.value);\n                if (chart && chart.data?.datasets) {\n                  const labels = chart.data.labels || [];\n                  const datasets = chart.data.datasets || [];\n                  \n                  datasets.forEach(dataset => {\n                    const type = dataset.label || 'Unknown';\n                    const data = dataset.data || [];\n                    \n                    labels.forEach((date, index) => {\n                      if (date && data[index] !== null && data[index] !== undefined) {\n                        dataToExport.push({\n                          'Date': date,\n                          'Assessment Type': type,\n                          'Assessment Name': 'Assessment ' + (index + 1),\n                          'Average Score': data[index] || 0\n                        });\n                      }\n                    });\n                  });\n                }\n              } catch (chartErr) {\n                console.error('Error extracting chart data:', chartErr);\n              }\n            }\n            break;\n            \n          default:\n            throw new Error(`Unknown chart type: ${chartType}`);\n        }\n        \n        // Check if we have data to export\n        if (dataToExport.length === 0) {\n          console.warn(`No data to export for ${chartType}`);\n          alert('No data available to generate report');\n          return;\n        }\n        \n        // Log the exact structure of data being exported\n        console.log('Data being exported:', JSON.stringify(dataToExport));\n        \n        if (format === 'excel') {\n          // Create and download Excel file\n          const worksheet = XLSX.utils.json_to_sheet(dataToExport);\n          const workbook = XLSX.utils.book_new();\n          XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');\n          const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n          const excelData = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });\n          saveAs(excelData, `${fileName}.xlsx`);\n        } else if (format === 'pdf') {\n          let pdfGenerated = false;\n          \n          try {\n            // Create PDF document with specified orientation\n            const doc = new jsPDF({\n              orientation: 'portrait',\n              unit: 'mm',\n              format: 'a4'\n            });\n            \n            // Add document title\n            let title = '';\n            switch (chartType) {\n              case 'attendance': \n                title = 'Attendance Distribution Report';\n                break;\n              case 'assessmentType':\n                title = 'Assessment Types Performance Report';\n                break;\n              case 'performanceTrend':\n                title = 'Performance Trends Report';\n                break;\n              case 'assessmentTypePerformance':\n                title = 'Performance by Assessment Type Report';\n                break;\n            }\n            \n            // Add header with styling\n            doc.setFont('helvetica', 'bold');\n            doc.setFontSize(16);\n            doc.setTextColor(0, 51, 102); // Dark blue\n            doc.text(title, doc.internal.pageSize.getWidth() / 2, 20, { align: 'center' });\n            \n            // Add date and filters info\n            doc.setFont('helvetica', 'normal');\n            doc.setFontSize(10);\n            doc.setTextColor(70, 70, 70);\n            \n            const dateText = `Generated on: ${moment().format('MMMM D, YYYY')}`;\n            doc.text(dateText, 15, 30);\n            \n            // Add filter info if available\n            let filterText = '';\n            if (selectedYear.value) filterText += `Year: ${selectedYear.value} `;\n            if (selectedSection.value) filterText += `Section: ${selectedSection.value} `;\n            if (selectedSubject.value) filterText += `Subject: ${selectedSubject.value} `;\n            \n            if (filterText) {\n              doc.text(`Filters: ${filterText}`, 15, 35);\n            }\n            \n            // Filter settings\n            const periodText = `Period: ${chartFilters.value[chartType]?.period || 'month'}`;\n            doc.text(periodText, 15, 40);\n            \n            // Convert data to table format\n            const tableColumn = Object.keys(dataToExport[0]);\n            const tableRows = dataToExport.map(item => {\n              return Object.values(item).map(val => {\n                // Ensure all values are properly formatted\n                if (val === undefined || val === null) return '';\n                return val.toString();\n              });\n            });\n            \n            // Add table with safer settings\n            try {\n              doc.autoTable({\n                startY: 45,\n                head: [tableColumn],\n                body: tableRows,\n                theme: 'grid',\n                headStyles: {\n                  fillColor: [0, 51, 102],\n                  textColor: [255, 255, 255],\n                  fontStyle: 'bold',\n                  halign: 'center'\n                },\n                styles: {\n                  fontSize: 10,\n                  cellPadding: 3,\n                  overflow: 'linebreak'\n                },\n                margin: { top: 45, right: 15, bottom: 25, left: 15 }\n              });\n            } catch (tableError) {\n              console.error('Error creating table:', tableError);\n              throw new Error('Failed to create PDF table: ' + tableError.message);\n            }\n            \n            // Special handling for attendance data - add summary with percentages\n            if (chartType === 'attendance') {\n              try {\n                const present = dataToExport.find(i => i.Status === 'Present')?.Count || 0;\n                const late = dataToExport.find(i => i.Status === 'Late')?.Count || 0;\n                const absent = dataToExport.find(i => i.Status === 'Absent')?.Count || 0;\n                const total = Number(present) + Number(late) + Number(absent);\n                \n                if (total > 0) {\n                  // Calculate percentages\n                  const presentPercent = ((Number(present) / total) * 100).toFixed(1);\n                  const latePercent = ((Number(late) / total) * 100).toFixed(1);\n                  const absentPercent = ((Number(absent) / total) * 100).toFixed(1);\n                  \n                  // Get Y position after table\n                  const finalY = doc.lastAutoTable?.finalY || 150;\n                  \n                  // Add summary section\n                  doc.setFont('helvetica', 'bold');\n                  doc.setFontSize(12);\n                  doc.setTextColor(0, 51, 102);\n                  doc.text('Attendance Summary:', 15, finalY + 15);\n                  \n                  doc.setFont('helvetica', 'normal');\n                  doc.setFontSize(10);\n                  doc.setTextColor(70, 70, 70);\n                  doc.text(`Total Records: ${total}`, 15, finalY + 25);\n                  doc.text(`Present: ${present} (${presentPercent}%)`, 15, finalY + 32);\n                  doc.text(`Late: ${late} (${latePercent}%)`, 15, finalY + 39);\n                  doc.text(`Absent: ${absent} (${absentPercent}%)`, 15, finalY + 46);\n                  \n                  // Try to add simple chart visual (colored bars)\n                  const barWidth = 120; // width of full bar in mm\n                  const barHeight = 8;\n                  const startX = 15;\n                  const startY = finalY + 55;\n                  \n                  // Present bar (green)\n                  const presentWidth = barWidth * (Number(present) / total);\n                  doc.setFillColor(52, 211, 153); // Green\n                  doc.rect(startX, startY, presentWidth, barHeight, 'F');\n                  \n                  // Late bar (yellow)\n                  const lateWidth = barWidth * (Number(late) / total);\n                  doc.setFillColor(251, 191, 36); // Yellow\n                  doc.rect(startX + presentWidth, startY, lateWidth, barHeight, 'F');\n                  \n                  // Absent bar (red)\n                  const absentWidth = barWidth * (Number(absent) / total);\n                  doc.setFillColor(239, 68, 68); // Red\n                  doc.rect(startX + presentWidth + lateWidth, startY, absentWidth, barHeight, 'F');\n                  \n                  // Add legend\n                  const legendY = startY + barHeight + 10;\n                  // Present legend\n                  doc.setFillColor(52, 211, 153);\n                  doc.rect(startX, legendY, 5, 5, 'F');\n                  doc.text('Present', startX + 10, legendY + 4);\n                  \n                  // Late legend\n                  doc.setFillColor(251, 191, 36);\n                  doc.rect(startX + 50, legendY, 5, 5, 'F');\n                  doc.text('Late', startX + 60, legendY + 4);\n                  \n                  // Absent legend\n                  doc.setFillColor(239, 68, 68);\n                  doc.rect(startX + 100, legendY, 5, 5, 'F');\n                  doc.text('Absent', startX + 110, legendY + 4);\n                }\n              } catch (summaryError) {\n                console.error('Error adding attendance summary:', summaryError);\n                // Continue without summary if there's an error\n              }\n            }\n            \n            // Add footer with teacher's name and page numbers\n            const pageCount = doc.internal.getNumberOfPages();\n            doc.setFont('helvetica', 'normal');\n            doc.setFontSize(9);\n            doc.setTextColor(100, 100, 100);\n            \n            const teacherName = store.state.auth.user ? \n              `${store.state.auth.user.firstName || ''} ${store.state.auth.user.lastName || ''}`.trim() : \n              'Teacher';\n            \n            for (let i = 1; i <= pageCount; i++) {\n              doc.setPage(i);\n              // Safe footer placement\n              const pageHeight = doc.internal.pageSize.getHeight();\n              doc.text(\n                `Generated by: ${teacherName} | Page ${i} of ${pageCount}`,\n                doc.internal.pageSize.getWidth() / 2,\n                pageHeight - 10,\n                { align: 'center' }\n              );\n            }\n            \n            // Save the PDF\n            try {\n              doc.save(`${fileName}.pdf`);\n              console.log(`PDF generated successfully for ${chartType}`);\n              pdfGenerated = true;\n            } catch (saveError) {\n              console.error('Error saving PDF:', saveError);\n              throw new Error('Error saving the PDF: ' + saveError.message);\n            }\n          } catch (pdfError) {\n            console.error('Error in primary PDF generation method:', pdfError);\n            \n            // Try fallback method if primary fails\n            if (!pdfGenerated) {\n              const fallbackSuccess = generateFallbackPDF(chartType, dataToExport, fileName);\n              if (fallbackSuccess) {\n                alert('Generated a simplified PDF report due to formatting issues.');\n              } else {\n                alert(`Failed to generate PDF report: ${pdfError.message || 'Unknown error'}. Please try Excel format instead.`);\n              }\n            }\n          }\n        }\n        \n        console.log(`Data export completed for ${chartType} as ${format}`);\n      } catch (error) {\n        console.error(`Error generating ${chartType} data:`, error);\n        alert(`Error generating report: ${error.message || 'Unknown error'}\\nPlease try Excel format instead.`);\n      }\n    };\n\n    // Enhanced fetchDashboardData function\n    const fetchDashboardData = async () => {\n      try {\n        loading.value = true;\n        const teacherId = store.state.auth.user._id;\n        \n        if (!teacherId) {\n          console.error('Teacher ID not available');\n          loading.value = false;\n          return;\n        }\n        \n        // Prepare query parameters with URLSearchParams for consistency\n        const params = new URLSearchParams();\n        \n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedSubject.value) params.append('subject', selectedSubject.value);\n        if (selectedStartDate.value) params.append('startDate', selectedStartDate.value);\n        if (selectedEndDate.value) params.append('endDate', selectedEndDate.value);\n        \n        console.log('Fetching dashboard data with params:', Object.fromEntries(params));\n        \n        // Fetch dashboard stats\n        const url = `http://localhost:8000/api/dashboard/teacher/${teacherId}/stats?${params.toString()}`;\n        console.log('Requesting URL:', url);\n        \n        const response = await axios.get(url, {\n          headers: {\n            'Authorization': `Bearer ${store.state.auth.token}`\n          }\n        });\n        \n        console.log('Dashboard data received:', response.data);\n        \n        // Store complete data for reference\n        data.value = response.data;\n        \n        // Check if we received any meaningful data (indicating valid filters)\n        const hasValidData = \n          (response.data.totalStudents > 0) || \n          (response.data.totalSections > 0) || \n          (Array.isArray(response.data.attendanceDistribution) && response.data.attendanceDistribution.some(val => val > 0)) ||\n          (Array.isArray(response.data.performanceTrends) && response.data.performanceTrends.length > 0);\n        \n        // If no valid data, it means the filter combination doesn't match any records\n        if (!hasValidData && (selectedYear.value || selectedSection.value || selectedSubject.value)) {\n          console.warn('No data found for the selected filters');\n        }\n        \n        // Update stats - only when we have valid data or no filters applied\n        totalStudents.value = response.data.totalStudents || 0;\n        totalSections.value = response.data.totalSections || 0;\n        totalSubjects.value = response.data.totalSubjects || 0;\n        \n        // Debug the class average score from API response\n        console.log('Average score from API:', response.data.averageScore);\n        console.log('Average score type:', typeof response.data.averageScore);\n        \n        // Update class average score from the response\n        if (response.data.hasOwnProperty('averageScore')) {\n          const scoreValue = parseFloat(response.data.averageScore);\n          console.log('Parsed score value:', scoreValue);\n          averageScore.value = isNaN(scoreValue) ? '0.0' : scoreValue.toFixed(1);\n          console.log('Final average score value:', averageScore.value);\n        } else {\n          averageScore.value = '0.0';\n        }\n        \n        // Update activities\n        recentActivities.value = response.data.recentActivities || [];\n        \n        // ALWAYS fetch attendance data separately to ensure we have the latest\n        await fetchAttendanceData();\n        \n        // Fetch assessment data separately\n        await fetchAssessmentData();\n        \n        // After updating the charts, apply the default filter (month) to each chart\n        // This ensures the charts' data is consistent with the filter state\n        const endDate = moment().format('YYYY-MM-DD');\n        const startDate = moment().subtract(30, 'days').format('YYYY-MM-DD');\n        \n        await Promise.all([\n          fetchChartData('attendance', startDate, endDate),\n          fetchChartData('assessmentType', startDate, endDate),\n          fetchChartData('performanceTrend', startDate, endDate),\n          fetchChartData('assessmentTypePerformance', startDate, endDate)\n        ]);\n\n        loading.value = false;\n      } catch (error) {\n        console.error('Error fetching dashboard data:', error);\n        // Initialize charts with empty data\n        initEmptyCharts();\n        loading.value = false;\n      }\n    };\n\n    // Add a dedicated function to fetch attendance data\n    const fetchAttendanceData = async () => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n        \n        // Prepare attendance parameters\n        const params = new URLSearchParams();\n        params.append('teacherId', teacherId);\n        \n        // Add date range - default to last 30 days if not specified\n        params.append('startDate', selectedStartDate.value || moment().subtract(30, 'days').format('YYYY-MM-DD'));\n        params.append('endDate', selectedEndDate.value || moment().format('YYYY-MM-DD'));\n        \n        // Add filters if selected\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedSubject.value) params.append('subject', selectedSubject.value);\n        \n        console.log('Fetching attendance data with params:', Object.fromEntries(params));\n        const url = `http://localhost:8000/api/attendance/stats?${params.toString()}`;\n        console.log('Requesting URL:', url);\n        \n        const response = await axios.get(url, {\n          headers: {\n            'Authorization': `Bearer ${store.state.auth.token}`\n          }\n        });\n        \n        console.log('Attendance data received:', response.data);\n        \n        if (response.data) {\n          // Store in chartData for export\n          chartData.value.attendance = response.data;\n          \n          // Parse attendance counts\n          const present = parseInt(response.data.present) || 0;\n          const late = parseInt(response.data.late) || 0;\n          const absent = parseInt(response.data.absent) || 0;\n          \n          // Update main data store\n          if (data.value) {\n            data.value.attendanceDistribution = [present, late, absent];\n          }\n          \n          // Update attendance chart\n          updatePerformanceChart({\n            attendanceDistribution: [present, late, absent]\n          });\n          \n          console.log('Attendance distribution updated:', [present, late, absent]);\n          return true;\n        }\n        return false;\n      } catch (error) {\n        console.error('Error fetching attendance data:', error);\n        \n        // Initialize with empty data on error\n        if (data.value) {\n          data.value.attendanceDistribution = [0, 0, 0];\n        }\n        \n        updatePerformanceChart({\n          attendanceDistribution: [0, 0, 0]\n        });\n        \n        return false;\n      }\n    };\n\n    const updatePerformanceChart = (data) => {\n      if (!performanceChart.value) return;\n      \n      const ctx = performanceChart.value.getContext('2d');\n      if (!ctx) return;\n\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process attendance distribution data\n      // Expected data format: [present, late, absent]\n      const attendanceData = Array.isArray(data.attendanceDistribution) \n        ? data.attendanceDistribution.slice(0, 3) \n        : [0, 0, 0];\n      \n      console.log('Attendance distribution data:', attendanceData);\n\n      // Calculate total attendance records\n      const totalAttendance = attendanceData.reduce((a, b) => a + (b || 0), 0);\n      \n      // Create attendance distribution chart\n      new Chart(ctx, {\n        type: 'doughnut',\n        data: {\n          labels: ['Present', 'Late', 'Absent'],\n          datasets: [\n            {\n              data: attendanceData,\n              backgroundColor: [\n                'rgba(52, 211, 153, 0.8)',  // Green for present\n                'rgba(251, 191, 36, 0.8)',  // Yellow for late\n                'rgba(239, 68, 68, 0.8)',   // Red for absent\n              ],\n              borderColor: [\n                'rgb(15, 140, 80)',         // Darker borders for contrast\n                'rgb(220, 160, 20)',\n                'rgb(220, 50, 50)',\n              ],\n              borderWidth: 1,\n              hoverOffset: 15\n            }\n          ]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          cutout: '60%',\n          plugins: {\n            legend: {\n              display: true,\n              position: 'bottom',\n              labels: {\n                padding: 20,\n                font: {\n                  size: 12\n                }\n              }\n            },\n            tooltip: {\n              callbacks: {\n                label: (context) => {\n                  const value = context.raw || 0;\n                  const total = attendanceData.reduce((a, b) => a + (b || 0), 0);\n                  const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;\n                  return `${context.label}: ${value} (${percentage}%)`;\n                }\n              },\n              titleFont: {\n                weight: 'bold',\n                size: 14\n              },\n              bodyFont: {\n                size: 13\n              },\n              backgroundColor: 'rgba(0, 0, 0, 0.8)',\n              padding: 12,\n              cornerRadius: 8\n            }\n          },\n          layout: {\n            padding: {\n              top: 10,\n              right: 20,\n              bottom: 10,\n              left: 20\n            }\n          }\n        }\n      });\n    };\n\n    const updateAssessmentTypeChart = (data) => {\n      if (!assessmentTypeChart.value) return;\n      \n      const ctx = assessmentTypeChart.value.getContext('2d');\n      if (!ctx) return;\n\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process incoming data to restructure it\n      const assessmentTypes = ['Quiz', 'Activity', 'Performance Task'];\n      \n      // Check if we have valid data\n      if (!data.assessmentData || !Array.isArray(data.assessmentData) || data.assessmentData.length === 0) {\n        // If no assessment data, just return without creating a chart\n        // The \"No data available\" message will be shown by the template\n        console.log('No assessment data available, skipping chart creation');\n        return;\n      }\n      \n        // Process actual data\n      const processedData = {\n        types: [],\n        scores: [],\n        counts: []\n      };\n      \n      // Filter out assessment types with data\n      const availableTypes = [...new Set(data.assessmentData.map(item => item.type))];\n      \n      // For each available type, get the score and count\n      availableTypes.forEach(type => {\n        const typeData = data.assessmentData.find(a => a.type === type);\n        if (typeData) {\n          processedData.types.push(type);\n          processedData.scores.push(parseFloat(typeData.averageScore) || 0);\n          processedData.counts.push(typeData.count || 0);\n        }\n      });\n      \n      console.log('Processed assessment chart data:', processedData);\n      \n      // Create a simple bar chart showing average scores\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: processedData.types,\n          datasets: [\n            {\n              label: 'Average Score (%)',\n              data: processedData.scores,\n              backgroundColor: [\n                'rgba(52, 211, 153, 0.8)',  // Green for Quiz\n                'rgba(59, 130, 246, 0.8)',  // Blue for Activity\n                'rgba(251, 191, 36, 0.8)',  // Yellow for Performance Task\n              ].slice(0, processedData.types.length),\n              borderColor: [\n                'rgb(15, 140, 80)',\n                'rgb(45, 110, 220)',\n                'rgb(220, 160, 20)',\n              ].slice(0, processedData.types.length),\n              borderWidth: 1,\n              borderRadius: 6,\n              barPercentage: 0.6\n            }\n          ]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              grid: {\n                color: 'rgba(0, 0, 0, 0.05)'\n              },\n              title: {\n                display: true,\n                text: 'Average Score (%)',\n                font: {\n                  size: 14,\n                  weight: 'bold'\n                }\n              },\n              ticks: {\n                font: {\n                  size: 12\n                }\n              }\n            },\n            x: {\n              grid: {\n                display: false\n              }\n            }\n          },\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: (context) => {\n                  const label = context.dataset.label || '';\n                  const value = context.raw || 0;\n                  return `${label}: ${value}%`;\n                },\n                afterLabel: (context) => {\n                  const type = processedData.types[context.dataIndex];\n                  const count = processedData.counts[context.dataIndex] || 0;\n                  return `Total ${type}s: ${count}`;\n                }\n              },\n              titleFont: {\n                size: 14,\n                weight: 'bold'\n              },\n              bodyFont: {\n                size: 13\n              },\n              padding: 12\n            }\n          }\n        }\n      });\n    };\n\n    const updatePerformanceTrendChart = (data) => {\n      if (!performanceTrendChart.value) {\n        console.warn('Performance trend chart reference not found');\n        return;\n      }\n      \n      const ctx = performanceTrendChart.value.getContext('2d');\n      if (!ctx) {\n        console.warn('Could not get 2d context for performance trend chart');\n        return;\n      }\n\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) {\n        existingChart.destroy();\n      }\n\n      // Ensure data is valid\n      const validData = Array.isArray(data) ? data : [];\n      console.log('Creating performance trend chart with data:', validData);\n\n      new Chart(ctx, {\n        type: 'line',\n        data: {\n          labels: validData.map(d => moment(d.date).format('MMM D, YYYY')),\n          datasets: [{\n            label: 'Average Score',\n            data: validData.map(d => Number(d.score) || 0),\n            borderColor: '#4CAF50',\n            backgroundColor: 'rgba(76, 175, 80, 0.1)',\n            tension: 0.4,\n            fill: true,\n            pointRadius: 4,\n            pointHoverRadius: 6\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: (context) => {\n                  const dataPoint = validData[context.dataIndex];\n                  return `${dataPoint.name}: ${(context.raw || 0).toFixed(1)}%`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              ticks: {\n                stepSize: 20,\n                font: {\n                  size: 12\n                }\n              },\n              title: {\n                display: true,\n                text: 'Average Score (%)',\n                font: {\n                  size: 14,\n                  weight: 'bold'\n                }\n              }\n            },\n            x: {\n              ticks: {\n                font: {\n                  size: 12\n                },\n                maxRotation: 45,\n                minRotation: 45\n              }\n            }\n          }\n        }\n      });\n    };\n\n    const updateAssessmentTypePerformanceChart = (data) => {\n      if (!assessmentTypePerformanceChart.value) return;\n      \n      const ctx = assessmentTypePerformanceChart.value.getContext('2d');\n      if (!ctx) return;\n\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process the performance trends data by assessment type\n      const trendsByType = {\n        Quiz: [],\n        Activity: [],\n        'Performance Task': []\n      };\n\n      // Process performance trends data\n      if (Array.isArray(data.performanceTrends)) {\n        data.performanceTrends.forEach(trend => {\n          const type = trend.type || trend.name;\n          if (type in trendsByType) {\n            trendsByType[type].push({\n              date: new Date(trend.date),\n              score: parseFloat(trend.score) || 0\n            });\n          }\n        });\n      }\n\n      // Sort data points by date for each type\n      Object.keys(trendsByType).forEach(type => {\n        trendsByType[type].sort((a, b) => a.date - b.date);\n      });\n\n      // Get unique dates across all types\n      const allDates = [...new Set(\n        Object.values(trendsByType)\n          .flat()\n          .map(item => item.date)\n      )].sort((a, b) => a - b);\n\n      // Create datasets\n      const datasets = Object.entries(trendsByType).map(([type, data], index) => {\n        const colors = [\n          'rgb(52, 211, 153)',   // Green for Quiz\n          'rgb(59, 130, 246)',   // Blue for Activity\n          'rgb(251, 191, 36)'    // Yellow for Performance Task\n        ];\n        const color = colors[index];\n\n        return {\n          label: type,\n          data: allDates.map(date => {\n            const point = data.find(d => d.date.getTime() === date.getTime());\n            return point ? point.score : null;\n          }),\n          borderColor: color,\n          backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),\n          fill: true,\n          tension: 0.4,\n          pointRadius: 4,\n          pointHoverRadius: 6,\n          spanGaps: true // This will connect points even if there are null values\n        };\n      });\n\n      new Chart(ctx, {\n        type: 'line',\n        data: {\n          labels: allDates.map(date => moment(date).format('MMM D, YYYY')),\n          datasets\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          interaction: {\n            intersect: false,\n            mode: 'index'\n          },\n          plugins: {\n            legend: {\n              position: 'top'\n            },\n            tooltip: {\n              callbacks: {\n                label: (context) => {\n                  const value = context.raw !== null ? context.raw.toFixed(1) : 'N/A';\n                  return `${context.dataset.label}: ${value}%`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              title: {\n                display: true,\n                text: 'Score (%)'\n              }\n            },\n            x: {\n              ticks: {\n                maxRotation: 45,\n                minRotation: 45\n              }\n            }\n          }\n        }\n      });\n    };\n\n    const formatDate = (date) => {\n      return moment(date).format('MMM D, YYYY')\n    }\n\n    const applyFilters = async () => {\n      // Save selected values to localStorage\n      if (selectedYear.value) {\n        localStorage.setItem('selectedYear', selectedYear.value)\n      } else {\n        localStorage.removeItem('selectedYear')\n      }\n\n      if (selectedSection.value) {\n        localStorage.setItem('selectedSection', selectedSection.value)\n      } else {\n        localStorage.removeItem('selectedSection')\n      }\n\n      if (selectedSubject.value) {\n        localStorage.setItem('selectedSubject', selectedSubject.value)\n      } else {\n        localStorage.removeItem('selectedSubject')\n      }\n\n      await fetchDashboardData()\n    }\n\n    // Watch for filter changes\n    watch(selectedYear, handleYearChange)\n    watch([selectedSection, selectedSubject], applyFilters)\n    watch([selectedStartDate, selectedEndDate], () => {\n      if (selectedStartDate.value && selectedEndDate.value) {\n        // Validate date range\n        const start = moment(selectedStartDate.value);\n        const end = moment(selectedEndDate.value);\n        \n        if (end.isBefore(start)) {\n          selectedEndDate.value = selectedStartDate.value;\n        }\n        \n        fetchDashboardData();\n      }\n    })\n\n    const fetchAssessmentData = async () => {\n      try {\n        const teacherId = getTeacherId();\n        if (!teacherId) return;\n        \n        // Prepare query parameters\n        const params = {\n          teacherId,\n          year: selectedYear.value || '',\n          section: selectedSection.value || '',\n          subject: selectedSubject.value || ''\n        };\n        \n        if (selectedStartDate.value) params.startDate = selectedStartDate.value;\n        if (selectedEndDate.value) params.endDate = selectedEndDate.value;\n        \n        console.log('Fetching assessment data with params:', params);\n        \n        // Try the assessments/stats endpoint first\n        try {\n          const assessmentResponse = await axios.get('http://localhost:8000/api/assessments/stats', {\n            params,\n            headers: {\n              'Authorization': `Bearer ${store.state.auth.token}`\n            }\n          });\n          \n          processAssessmentResponse(assessmentResponse.data);\n        } catch (error) {\n          // If the first endpoint fails, try the fallback endpoint\n          console.log('Falling back to /assessments endpoint');\n          const assessmentResponse = await axios.get('http://localhost:8000/api/assessments', {\n            params,\n            headers: {\n              'Authorization': `Bearer ${store.state.auth.token}`\n            }\n          });\n          \n          processAssessmentResponse(assessmentResponse.data);\n        }\n      } catch (error) {\n        console.error('Error fetching assessment data:', error);\n        // Initialize assessment charts with empty data\n        updateAssessmentTypeChart({ assessmentData: [] });\n        updatePerformanceTrendChart([]);\n        updateAssessmentTypePerformanceChart({\n          performanceTrends: []\n        });\n      }\n    };\n\n    // Helper function to process assessment response data\n    const processAssessmentResponse = (data) => {\n      if (data) {\n        console.log('Assessment data received:', data);\n        \n        // Update assessment type charts with this data\n        if (data.assessmentTypes) {\n          const assessmentData = [];\n          \n          Object.keys(data.assessmentTypes).forEach(type => {\n            const typeData = data.assessmentTypes[type];\n            if (typeData) {\n              let avgScore = 0;\n              if (typeData.scoreCount && typeData.scoreCount > 0) {\n                avgScore = (typeData.totalScore / typeData.scoreCount).toFixed(1);\n              }\n              \n              assessmentData.push({\n                type: type,\n                averageScore: avgScore,\n                count: typeData.count || 0\n              });\n            }\n          });\n          \n          updateAssessmentTypeChart({ assessmentData });\n        } else if (Array.isArray(data)) {\n          // If data is an array of assessments, process it into the format we need\n          const assessmentTypes = {\n            'Quiz': { count: 0, totalScore: 0, scoreCount: 0 },\n            'Activity': { count: 0, totalScore: 0, scoreCount: 0 },\n            'Performance Task': { count: 0, totalScore: 0, scoreCount: 0 }\n          };\n          \n          // Process raw assessment data\n          data.forEach(assessment => {\n            const type = assessment.type || 'Other';\n            if (assessmentTypes[type]) {\n              assessmentTypes[type].count++;\n              \n              // Process scores if available\n              if (assessment.scores) {\n                // Handle both array and object formats\n                let scoreArray = [];\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (typeof assessment.scores === 'object') {\n                  scoreArray = Object.values(assessment.scores);\n                }\n                \n                scoreArray.forEach(score => {\n                  if (typeof score === 'number') {\n                    assessmentTypes[type].totalScore += score;\n                    assessmentTypes[type].scoreCount++;\n                  }\n                });\n              }\n            }\n          });\n          \n          // Convert to format for chart\n          const assessmentData = Object.keys(assessmentTypes).map(type => {\n            const typeData = assessmentTypes[type];\n            const averageScore = typeData.scoreCount > 0 \n              ? (typeData.totalScore / typeData.scoreCount).toFixed(1) \n              : 0;\n            \n            return {\n              type,\n              averageScore,\n              count: typeData.count\n            };\n          });\n          \n          updateAssessmentTypeChart({ assessmentData });\n          \n          // Create performance trends data\n          const performanceTrends = data\n            .filter(a => a.date) // Only include assessments with dates\n            .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n            .map(assessment => {\n              // Calculate average score for this assessment\n              let averageScore = 0;\n              let scoreArray = [];\n              \n              if (assessment.scores) {\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (typeof assessment.scores === 'object') {\n                  scoreArray = Object.values(assessment.scores);\n                }\n                \n                const validScores = scoreArray.filter(score => typeof score === 'number');\n                if (validScores.length > 0) {\n                  const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                  averageScore = totalScore / validScores.length;\n                }\n              }\n              \n              return {\n                date: assessment.date,\n                score: averageScore,\n                name: assessment.name || assessment.title || assessment.type,\n                type: assessment.type\n              };\n            });\n          \n          updatePerformanceTrendChart(performanceTrends);\n          updateAssessmentTypePerformanceChart({\n            performanceTrends\n          });\n        }\n      }\n    };\n\n    onMounted(async () => {\n      if (store.state.auth.user?._id && store.state.auth.token) {\n        console.log('Component mounted, initializing...');\n        \n        // Wait for the next tick to ensure DOM elements are rendered\n        await nextTick();\n        \n        try {\n          // Initialize empty charts first\n          console.log('Initializing empty charts...');\n          \n          initEmptyCharts();\n          \n          console.log('Empty charts initialized');\n          \n          // Fetch sections and subjects\n          await fetchTeacherSectionsAndSubjects(selectedYear.value);\n          console.log('Sections and subjects fetched');\n          \n          // Fetch actual dashboard data\n          await fetchDashboardData();\n          console.log('Initial data fetch completed');\n        } catch (error) {\n          console.error('Error during initialization:', error);\n        }\n      } else {\n        console.error('No user ID or token found');\n      }\n      \n      // Add default chart filter periods\n      Object.keys(chartFilters.value).forEach(chartType => {\n        chartFilters.value[chartType].period = 'month';\n      });\n    })\n\n    return {\n      totalStudents,\n      totalSections,\n      totalSubjects,\n      averageScore,\n      performanceChart,\n      recentActivities,\n      sections,\n      subjects,\n      selectedYear,\n      selectedSection,\n      selectedSubject,\n      hasAttendanceData,\n      hasPerformanceData,\n      hasAssessmentData,\n      hasActivity,\n      formatDate,\n      getFilterDisplay,\n      handleYearChange,\n      applyFilters,\n      assessmentTypeChart,\n      performanceTrendChart,\n      assessmentTypePerformanceChart,\n      selectedStartDate,\n      selectedEndDate,\n      today,\n      loading,\n      availableYears,\n      userName,\n      chartFilters,\n      applyChartDateFilter,\n      generateChartData\n    }\n  }\n}\n</script>\n\n<style scoped>\n.dashboard {\n  padding: 2rem;\n  background-color: #f8f9fa;\n  min-height: 100vh;\n}\n\n/* Chart Filters */\n.chart-filters {\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  margin-bottom: 0.75rem;\n}\n\n.date-filter-group {\n  border-radius: 8px;\n  overflow: hidden;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.date-filter-group .btn {\n  border-radius: 0;\n  font-size: 0.8rem;\n  padding: 0.3rem 0.75rem;\n  border: 1px solid #e2e8f0;\n  color: #64748b;\n  background-color: white;\n  transition: all 0.2s ease;\n}\n\n.date-filter-group .btn:first-child {\n  border-radius: 8px 0 0 8px;\n}\n\n.date-filter-group .btn:last-child {\n  border-radius: 0 8px 8px 0;\n}\n\n.date-filter-group .btn.btn-primary {\n  background-color: #003366;\n  color: white;\n  border-color: #003366;\n}\n\n.date-filter-group .btn.btn-outline-primary:hover {\n  background-color: #f8fafc;\n  color: #003366;\n  border-color: #003366;\n}\n\n/* Greeting Section Styles */\n.greeting-section {\n  padding-bottom: 1.5rem;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n}\n\n.greeting {\n  font-size: 2.25rem;\n  font-weight: 700;\n  color: #003366;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.5px;\n}\n\n.greeting-subtitle {\n  color: #64748b;\n  font-size: 1.125rem;\n  font-weight: 400;\n  margin: 0;\n}\n\n.dashboard-title {\n  font-size: 2rem;\n  font-weight: 700;\n  color: #2c3e50;\n  margin: 0;\n  letter-spacing: -0.5px;\n}\n\n.dashboard-card {\n  background: #fff;\n  border-radius: 12px;\n  padding: 1.5rem;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  display: flex;\n  align-items: center;\n  gap: 1.25rem;\n  height: 100%;\n  transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n.dashboard-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);\n}\n\n.icon-container {\n  width: 52px;\n  height: 52px;\n  border-radius: 12px;\n  background-color: #003366;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: transform 0.2s ease;\n}\n\n.dashboard-card:hover .icon-container {\n  transform: scale(1.05);\n}\n\n.icon-container i {\n  color: white;\n  font-size: 1.5rem;\n}\n\n.card-info {\n  flex: 1;\n}\n\n.stat-title {\n  font-size: 0.875rem;\n  color: #64748b;\n  margin: 0 0 0.5rem 0;\n  font-weight: 600;\n  letter-spacing: 0.3px;\n}\n\n.stat-value {\n  font-size: 1.75rem;\n  font-weight: 700;\n  color: #1e293b;\n  line-height: 1.2;\n}\n\n.stat-value.loading {\n  color: #94a3b8;\n  font-size: 1.5rem;\n}\n\n.no-data {\n  color: #94a3b8;\n  font-style: italic;\n  font-size: 0.875rem;\n}\n\n.chart-container {\n  position: relative;\n  height: 400px;\n  width: 100%;\n  margin-bottom: 1rem;\n}\n\n.loading-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background-color: rgba(255, 255, 255, 0.8);\n  z-index: 10;\n  border-radius: 8px;\n}\n\n.loading-overlay i {\n  font-size: 2rem;\n  color: #003366;\n  margin-bottom: 1rem;\n}\n\n.loading-overlay p {\n  font-size: 0.9rem;\n  color: #64748b;\n}\n\n.chart-card {\n  background: white;\n  border-radius: 12px;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  height: 100%;\n  padding: 1.5rem;\n}\n\n.card-title {\n  font-size: 1.125rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.3px;\n}\n\n.chart-description {\n  font-size: 0.85rem;\n  color: #64748b;\n  margin-bottom: 1.25rem;\n  font-style: italic;\n}\n\n.no-data-message {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  color: #94a3b8;\n  font-style: italic;\n  text-align: center;\n  width: 100%;\n  padding: 1rem;\n}\n\n.table {\n  margin-bottom: 0;\n}\n\n.table th {\n  font-weight: 600;\n  color: #475569;\n  border-bottom-width: 1px;\n  padding: 1rem;\n  font-size: 0.875rem;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.table td {\n  padding: 1rem;\n  color: #1e293b;\n  vertical-align: middle;\n  font-size: 0.9rem;\n  border-bottom: 1px solid #e2e8f0;\n}\n\n.table tr:last-child td {\n  border-bottom: none;\n}\n\n@media (max-width: 768px) {\n  .dashboard {\n    padding: 1rem;\n  }\n  \n  .dashboard-card {\n    margin-bottom: 1rem;\n  }\n\n  .filter-menu {\n    width: 100%;\n    max-width: 320px;\n  }\n\n  .btn-filter {\n    min-width: auto;\n    width: 100%;\n  }\n}\n\n/* Filter and Form Styles */\n.btn-filter {\n  background-color: white;\n  border: 1px solid #e2e8f0;\n  padding: 0.75rem 1.25rem;\n  font-size: 0.9rem;\n  color: #1e293b;\n  min-width: 220px;\n  text-align: left;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s ease;\n}\n\n.btn-filter:hover {\n  background-color: #f8fafc;\n  border-color: #003366;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);\n}\n\n.filter-menu {\n  width: 320px;\n  padding: 1.25rem;\n  border: none;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\n  border-radius: 12px;\n}\n\n.dropdown-header {\n  color: #003366;\n  font-weight: 700;\n  padding: 0;\n  margin-bottom: 1.25rem;\n  font-size: 1rem;\n}\n\n.form-label {\n  font-weight: 600;\n  color: #475569;\n  margin-bottom: 0.5rem;\n  font-size: 0.875rem;\n}\n\n.form-select, .form-control {\n  border: 1px solid #e2e8f0;\n  border-radius: 8px;\n  padding: 0.625rem;\n  font-size: 0.9rem;\n  color: #1e293b;\n  background-color: #fff;\n  transition: all 0.2s ease;\n}\n\n.form-select:hover, .form-control:hover {\n  border-color: #003366;\n}\n\n.form-select:focus, .form-control:focus {\n  border-color: #003366;\n  box-shadow: 0 0 0 2px rgba(0, 51, 102, 0.1);\n}\n\n.form-select:disabled {\n  background-color: #f1f5f9;\n  cursor: not-allowed;\n  opacity: 0.7;\n}\n\n.dropdown-divider {\n  margin: 1.25rem 0;\n  border-top: 1px solid #e2e8f0;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}