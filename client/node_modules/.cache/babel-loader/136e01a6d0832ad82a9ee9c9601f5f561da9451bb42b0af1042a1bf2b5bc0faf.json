{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { ref, onMounted, computed, watch, onUnmounted, nextTick } from 'vue';\nimport { useStore } from 'vuex';\nimport Chart from 'chart.js/auto';\nimport axios from 'axios';\nimport moment from 'moment';\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: 'http://localhost:8000/api'\n});\nexport default {\n  name: 'Dashboard',\n  setup() {\n    const store = useStore();\n    const performanceChart = ref(null);\n    const assessmentTypeChart = ref(null);\n    const performanceTrendChart = ref(null);\n    const sectionChart = ref(null);\n    const selectedYear = ref('');\n    const selectedSection = ref('');\n    const selectedSubject = ref('');\n    const dashboardContainer = ref(null);\n    const isLoading = ref(false);\n    const lastUpdate = ref(null);\n    const autoRefreshInterval = ref(null);\n    const sections = ref([]);\n    const subjects = ref([]);\n    const availableYears = ref(['1st', '2nd', '3rd', '4th']);\n\n    // Computed properties\n    const isCITHead = computed(() => store.getters.isCITHead);\n    const token = computed(() => store.state.auth.token);\n\n    // Get user name\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'User' : 'User';\n    });\n\n    // Check if filters are active\n    const hasActiveFilters = computed(() => {\n      return Boolean(selectedYear.value || selectedSection.value || selectedSubject.value);\n    });\n\n    // Set auth token for all requests\n    watch(token, newToken => {\n      if (newToken) {\n        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      }\n    }, {\n      immediate: true\n    });\n\n    // Dashboard stats\n    const totalStudents = ref(0);\n    const totalTeachers = ref(0);\n    const averageAttendance = ref(0);\n    const averageScore = ref(0);\n    const activeSections = ref(0);\n    const data = ref(null);\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      if (data.value && data.value.attendanceDistribution) {\n        return data.value.attendanceDistribution.some(val => val > 0);\n      }\n      return false;\n    });\n    const hasScoreData = computed(() => {\n      return data.value?.averageScore > 0;\n    });\n    const hasPerformanceData = computed(() => {\n      // Check if we have any assessment or performance data\n      if (data.value) {\n        // Check for averageScore > 0\n        if (typeof data.value.averageScore === 'number' && data.value.averageScore > 0) {\n          return true;\n        }\n\n        // Check for performance trends\n        if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    });\n    const hasAssessmentData = computed(() => {\n      if (data.value) {\n        // Check directly in assessmentTypes\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n\n        // Fallback to assessmentTypeDistribution\n        if (data.value.assessmentTypeDistribution) {\n          return true;\n        }\n      }\n      return false;\n    });\n    const hasSectionData = computed(() => {\n      return data.value?.sections?.length > 0;\n    });\n\n    // Fetch years and sections with data from all teacher class records\n    const fetchAvailableFilters = async () => {\n      try {\n        // Use existing backend endpoints that already pull data from TeacherClassRecord\n        const teacherClassRecordsResponse = await api.get('/teacher-class-records');\n        if (teacherClassRecordsResponse.data) {\n          const records = teacherClassRecordsResponse.data;\n\n          // Extract unique years, sections, and subjects with teacher info\n          const uniqueYears = [...new Set(records.map(record => record.year))].filter(Boolean).sort();\n          const uniqueSections = [];\n          const uniqueSubjects = [];\n\n          // Process sections with teacher info\n          records.forEach(record => {\n            if (record.section && !uniqueSections.some(s => s.name === record.section)) {\n              uniqueSections.push({\n                id: record._id,\n                name: record.section,\n                teacherName: record.teacherName || ''\n              });\n            }\n            if (record.subject && !uniqueSubjects.some(s => s.name === record.subject)) {\n              uniqueSubjects.push({\n                id: record._id,\n                name: record.subject,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n\n          // Update reactive data\n          availableYears.value = uniqueYears.length > 0 ? uniqueYears : ['1st', '2nd', '3rd', '4th'];\n\n          // If no year is selected, populate all available sections with teacher info\n          if (!selectedYear.value) {\n            sections.value = uniqueSections;\n            subjects.value = uniqueSubjects;\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching available filters:', error);\n        // Keep default years if API fails\n        availableYears.value = ['1st', '2nd', '3rd', '4th'];\n      }\n    };\n\n    // Fetch sections and subjects with data for a specific year\n    const fetchSectionsAndSubjects = async (year = '') => {\n      try {\n        // Use existing backend endpoints that already pull data from TeacherClassRecord\n        const response = await api.get('/teacher-class-records', {\n          params: {\n            year\n          }\n        });\n        if (response.data) {\n          const records = response.data;\n\n          // Process sections with teacher info for the selected year\n          const uniqueSections = [];\n          records.forEach(record => {\n            if (record.section && !uniqueSections.some(s => s.name === record.section)) {\n              uniqueSections.push({\n                id: record._id,\n                name: record.section,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n\n          // Extract unique subjects\n          const uniqueSubjects = [];\n          records.forEach(record => {\n            if (record.subject && !uniqueSubjects.some(s => s.name === record.subject)) {\n              uniqueSubjects.push({\n                id: record._id,\n                name: record.subject,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n          sections.value = uniqueSections;\n          subjects.value = uniqueSubjects;\n        }\n      } catch (error) {\n        console.error('Error fetching sections and subjects:', error);\n        sections.value = [];\n        subjects.value = [];\n      }\n    };\n\n    // Fetch subjects for a specific section with data\n    const fetchSubjectsBySection = async (year, section) => {\n      try {\n        // Use existing endpoints\n        const response = await api.get('/teacher-class-records', {\n          params: {\n            year,\n            section\n          }\n        });\n        if (response.data) {\n          const records = response.data;\n\n          // Extract unique subjects for this section\n          const uniqueSubjects = [];\n          records.forEach(record => {\n            if (record.subject && !uniqueSubjects.some(s => s.name === record.subject)) {\n              uniqueSubjects.push({\n                id: record._id,\n                name: record.subject,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n          subjects.value = uniqueSubjects;\n        }\n      } catch (error) {\n        console.error('Error fetching subjects by section:', error);\n        subjects.value = [];\n      }\n    };\n\n    // Get attendance data for the charts\n    const fetchAttendanceData = async () => {\n      try {\n        // Make a specific request for attendance data with the selected filters\n        const attendanceParams = {\n          year: selectedYear.value,\n          section: selectedSection.value,\n          subject: selectedSubject.value\n        };\n\n        // First try the /dashboard/attendance endpoint\n        try {\n          const dashboardResponse = await api.get('/dashboard/attendance', {\n            params: attendanceParams\n          });\n          if (dashboardResponse.data && dashboardResponse.data.distribution) {\n            // If the backend provides a formatted distribution, use it directly\n            return dashboardResponse.data.distribution;\n          }\n        } catch (error) {\n          console.log('Falling back to raw attendance records');\n        }\n\n        // If no dashboard endpoint or it didn't return distribution, fetch raw attendance records\n        const attendanceResponse = await api.get('/attendance', {\n          params: attendanceParams\n        });\n        if (attendanceResponse.data && Array.isArray(attendanceResponse.data)) {\n          // Process raw attendance records\n          const attendanceCounts = [0, 0, 0]; // [present, late, absent]\n\n          attendanceResponse.data.forEach(record => {\n            if (record.status === 'present') attendanceCounts[0]++;else if (record.status === 'late') attendanceCounts[1]++;else if (record.status === 'absent') attendanceCounts[2]++;\n          });\n          return attendanceCounts;\n        }\n        return [0, 0, 0]; // Default return if no data\n      } catch (error) {\n        console.error('Error fetching attendance data:', error);\n        return [0, 0, 0]; // Default on error\n      }\n    };\n    const fetchDashboardData = async () => {\n      try {\n        isLoading.value = true;\n\n        // Use the existing stats endpoint from dashboard.js\n        const statsResponse = await api.get('/dashboard/stats', {\n          params: {\n            year: selectedYear.value,\n            section: selectedSection.value,\n            subject: selectedSubject.value\n          }\n        });\n        data.value = statsResponse.data || {};\n\n        // Update basic stats from the response structure in dashboard.js\n        totalStudents.value = data.value.totalStudents || 0;\n        totalTeachers.value = data.value.totalTeachers || 0;\n        activeSections.value = data.value.activeSections || 0;\n\n        // Update additional stats from the response\n        if (typeof data.value.averageAttendance === 'number') {\n          averageAttendance.value = data.value.averageAttendance;\n        } else {\n          // If not provided, calculate from attendance data\n          const attendanceDistribution = await fetchAttendanceData();\n          const totalAttendance = attendanceDistribution.reduce((a, b) => a + b, 0);\n          if (totalAttendance > 0) {\n            // Calculate percentage of present and late (not absent)\n            const presentAttendance = attendanceDistribution[0] + attendanceDistribution[1];\n            averageAttendance.value = Math.round(presentAttendance / totalAttendance * 100);\n          } else {\n            averageAttendance.value = 0;\n          }\n        }\n        averageScore.value = data.value.averageScore || 0;\n\n        // Get attendance data for charts - must run even if stats provided it\n        data.value.attendanceDistribution = await fetchAttendanceData();\n\n        // Process assessment data for charts\n        await processAssessmentData(data.value);\n\n        // Update charts with new data\n        updateCharts(data.value);\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Failed to fetch dashboard data:', error);\n        if (error.response) {\n          console.error('Error response:', error.response.data);\n        }\n\n        // Initialize with empty data if main stats request fails\n        data.value = {\n          totalStudents: 0,\n          totalTeachers: 0,\n          activeSections: 0,\n          attendanceDistribution: [0, 0, 0],\n          averageAttendance: 0,\n          assessmentTypes: [],\n          performanceTrends: [],\n          averageScore: 0,\n          sections: []\n        };\n        totalStudents.value = 0;\n        totalTeachers.value = 0;\n        activeSections.value = 0;\n        averageAttendance.value = 0;\n        averageScore.value = 0;\n\n        // Update charts with empty data\n        updateCharts(data.value);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    // Process assessment data for charts\n    const processAssessmentData = async data => {\n      try {\n        // Try to use the assessment data from stats if available\n        if (data.performanceTrends && Array.isArray(data.performanceTrends) && data.performanceTrends.length > 0) {\n          // Already have the data from stats endpoint, just ensure it has the right format\n          data.performanceTrends = data.performanceTrends.map(trend => ({\n            date: trend.date,\n            title: trend.name || '',\n            averageScore: trend.score || 0,\n            type: trend.type || ''\n          }));\n        } else {\n          // Otherwise fetch assessment data specifically for the filters\n          const assessmentResponse = await api.get('/assessments', {\n            params: {\n              year: selectedYear.value,\n              section: selectedSection.value,\n              subject: selectedSubject.value\n            }\n          });\n          if (assessmentResponse.data && Array.isArray(assessmentResponse.data)) {\n            const assessments = assessmentResponse.data;\n\n            // Group assessments by type\n            const assessmentTypes = {\n              'Quiz': {\n                count: 0,\n                totalScore: 0,\n                scores: []\n              },\n              'Activity': {\n                count: 0,\n                totalScore: 0,\n                scores: []\n              },\n              'Performance Task': {\n                count: 0,\n                totalScore: 0,\n                scores: []\n              }\n            };\n\n            // Process each assessment\n            assessments.forEach(assessment => {\n              const type = assessment.type || 'Other';\n              if (assessmentTypes[type]) {\n                assessmentTypes[type].count++;\n\n                // Process scores if available\n                if (assessment.scores && Array.isArray(assessment.scores)) {\n                  assessment.scores.forEach(score => {\n                    if (typeof score === 'number') {\n                      const percentage = assessment.maxScore ? score / assessment.maxScore * 100 : score;\n                      assessmentTypes[type].totalScore += percentage;\n                      assessmentTypes[type].scores.push(percentage);\n                    }\n                  });\n                }\n              }\n            });\n\n            // Calculate averages and prepare for chart\n            data.assessmentTypes = Object.keys(assessmentTypes).map(type => {\n              const typeData = assessmentTypes[type];\n              const averageScore = typeData.scores.length > 0 ? typeData.totalScore / typeData.scores.length : 0;\n              return {\n                type,\n                averageScore: Math.round(averageScore),\n                count: typeData.count,\n                completionRate: typeData.count > 0 ? 100 : 0\n              };\n            });\n\n            // Generate performance trends from assessment data\n            data.performanceTrends = assessments.filter(a => a.date) // Only include assessments with dates\n            .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n            .map(assessment => {\n              // Calculate average score for this assessment\n              let averageScore = 0;\n              if (assessment.scores && Array.isArray(assessment.scores) && assessment.scores.length > 0) {\n                const totalScore = assessment.scores.reduce((sum, score) => sum + (typeof score === 'number' ? score : 0), 0);\n                averageScore = assessment.maxScore ? totalScore / assessment.scores.length / assessment.maxScore * 100 : totalScore / assessment.scores.length;\n              }\n              return {\n                date: assessment.date,\n                title: assessment.name || assessment.type,\n                averageScore: Math.round(averageScore),\n                type: assessment.type\n              };\n            });\n\n            // If no performance trends data, use dummy or empty array\n            if (data.performanceTrends.length === 0) {\n              data.performanceTrends = [];\n            }\n\n            // Process section data if available\n            if (assessments.length > 0) {\n              // Group assessments by section\n              const sectionPerformance = {};\n              assessments.forEach(assessment => {\n                if (assessment.section && assessment.scores && Array.isArray(assessment.scores)) {\n                  if (!sectionPerformance[assessment.section]) {\n                    sectionPerformance[assessment.section] = {\n                      totalScore: 0,\n                      scoreCount: 0,\n                      attendanceCount: 0,\n                      attendanceTotal: 0\n                    };\n                  }\n                  assessment.scores.forEach(score => {\n                    if (typeof score === 'number') {\n                      const percentage = assessment.maxScore ? score / assessment.maxScore * 100 : score;\n                      sectionPerformance[assessment.section].totalScore += percentage;\n                      sectionPerformance[assessment.section].scoreCount++;\n                    }\n                  });\n                }\n              });\n\n              // Prepare section data for chart\n              if (Object.keys(sectionPerformance).length > 0) {\n                data.sections = Object.keys(sectionPerformance).map(sectionName => {\n                  const section = sectionPerformance[sectionName];\n                  const averageScore = section.scoreCount > 0 ? section.totalScore / section.scoreCount : 0;\n                  const attendanceRate = section.attendanceTotal > 0 ? section.attendanceCount / section.attendanceTotal * 100 : 0;\n                  return {\n                    name: sectionName,\n                    averageScore: Math.round(averageScore),\n                    attendanceRate: Math.round(attendanceRate),\n                    performance: Math.round(averageScore) // For backward compatibility\n                  };\n                });\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error processing assessment data:', error);\n\n        // Set default values for assessment data\n        data.assessmentTypes = [{\n          type: 'Quiz',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Activity',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Performance Task',\n          averageScore: 0,\n          count: 0\n        }];\n\n        // Leave other data as is, but ensure we have arrays\n        if (!data.performanceTrends) data.performanceTrends = [];\n        if (!data.sections) data.sections = [];\n      }\n    };\n    const updateCharts = data => {\n      updatePerformanceChart(data);\n      updateAssessmentTypeChart(data);\n      updatePerformanceTrendChart(data);\n      updateSectionChart(data);\n    };\n\n    // Initialize dummy data for charts when no data is available\n    const initDummyData = () => {\n      // Create sample data structure\n      const dummyData = {\n        totalStudents: 0,\n        totalTeachers: 0,\n        activeSections: 0,\n        averageAttendance: 0,\n        averageScore: 0,\n        attendanceDistribution: [0, 0, 0],\n        assessmentTypes: [{\n          type: 'Quiz',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Activity',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Performance Task',\n          averageScore: 0,\n          count: 0\n        }],\n        performanceTrends: [],\n        sections: []\n      };\n\n      // Update charts with dummy data\n      updateCharts(dummyData);\n    };\n\n    // Format date for display\n    const formatDate = date => {\n      if (!date) return '';\n      return moment(date).format('MMMM D, YYYY h:mm A');\n    };\n\n    // Handle year change\n    const handleYearChange = async () => {\n      selectedSection.value = '';\n      selectedSubject.value = '';\n      if (selectedYear.value) {\n        await fetchSectionsAndSubjects(selectedYear.value);\n      } else {\n        sections.value = [];\n        subjects.value = [];\n      }\n      await fetchDashboardData();\n    };\n\n    // Handle section change\n    const handleSectionChange = () => {\n      // If a section is selected, filter subjects by that section\n      if (selectedSection.value) {\n        fetchSubjectsBySection(selectedYear.value, selectedSection.value);\n      } else {\n        // If no section selected, fetch all subjects for the year\n        fetchSectionsAndSubjects(selectedYear.value);\n      }\n      fetchDashboardData();\n    };\n\n    // Handle filter change\n    const handleFilterChange = () => {\n      fetchDashboardData();\n    };\n\n    // Clear all filters\n    const clearFilters = () => {\n      selectedYear.value = '';\n      selectedSection.value = '';\n      selectedSubject.value = '';\n\n      // Refresh available filters after clearing\n      fetchAvailableFilters().then(() => {\n        fetchDashboardData();\n      });\n    };\n\n    // Get filter display text\n    const getFilterDisplay = () => {\n      const filters = [];\n      if (selectedYear.value) filters.push(selectedYear.value + ' Year');\n      if (selectedSection.value) {\n        // Find the section object to get teacher name\n        const sectionObj = sections.value.find(s => s.name === selectedSection.value);\n        if (sectionObj && sectionObj.teacherName) {\n          filters.push(`${selectedSection.value} - ${sectionObj.teacherName}`);\n        } else {\n          filters.push(selectedSection.value);\n        }\n      }\n      if (selectedSubject.value) {\n        // Find the subject object to get teacher name\n        const subjectObj = subjects.value.find(s => s.name === selectedSubject.value);\n        if (subjectObj && subjectObj.teacherName) {\n          filters.push(`${selectedSubject.value} - ${subjectObj.teacherName}`);\n        } else {\n          filters.push(selectedSubject.value);\n        }\n      }\n      return filters.length > 0 ? filters.join(' - ') : 'Filter View';\n    };\n\n    // Update charts with data\n    const updatePerformanceChart = data => {\n      if (performanceChart.value) {\n        const ctx = performanceChart.value.getContext('2d');\n\n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n\n        // Attendance status distribution data\n        const attendanceLabels = ['Present', 'Late', 'Absent'];\n        const attendanceData = data.attendanceDistribution || [0, 0, 0];\n\n        // Log for debugging\n        console.log('Attendance distribution data:', attendanceData);\n\n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: attendanceLabels,\n            datasets: [{\n              data: attendanceData,\n              backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],\n              borderWidth: 0,\n              hoverOffset: 4\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            cutout: '70%',\n            plugins: {\n              legend: {\n                position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                  padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function (context) {\n                    const label = context.label || '';\n                    const value = context.raw || 0;\n                    const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);\n                    const percentage = total > 0 ? Math.round(value / total * 100) : 0;\n                    return `${label}: ${value} (${percentage}%)`;\n                  }\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n    const updateAssessmentTypeChart = data => {\n      if (assessmentTypeChart.value) {\n        const ctx = assessmentTypeChart.value.getContext('2d');\n\n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n\n        // Assessment types data\n        const assessmentData = data.assessmentTypes || [];\n        const labels = [];\n        const values = [];\n        const colors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#6366f1'];\n        try {\n          // Extract assessment types data\n          if (Array.isArray(assessmentData)) {\n            // If array format\n            assessmentData.forEach((item, index) => {\n              if (item && typeof item === 'object') {\n                labels.push(item.type || `Type ${index + 1}`);\n                values.push(parseFloat(item.averageScore) || 0);\n              }\n            });\n          } else if (typeof assessmentData === 'object' && assessmentData !== null) {\n            // If object format\n            Object.entries(assessmentData).forEach(([type, data], index) => {\n              labels.push(type);\n              values.push(parseFloat(data.averageScore) || 0);\n            });\n          }\n\n          // If no data was extracted, use default types\n          if (labels.length === 0) {\n            labels.push('Quiz', 'Activity', 'Performance Task');\n            values.push(0, 0, 0);\n          }\n        } catch (error) {\n          console.error('Error processing assessment data:', error);\n          // Fallback to default labels and values\n          labels.push('Quiz', 'Activity', 'Performance Task');\n          values.push(0, 0, 0);\n        }\n\n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'bar',\n          data: {\n            labels: labels,\n            datasets: [{\n              label: 'Average Score (%)',\n              data: values,\n              backgroundColor: colors.slice(0, labels.length),\n              borderWidth: 0,\n              borderRadius: 6,\n              maxBarThickness: 50\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: false\n              },\n              tooltip: {\n                callbacks: {\n                  label: function (context) {\n                    return `Average Score: ${context.raw}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function (value) {\n                    return value + '%';\n                  }\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n    const updatePerformanceTrendChart = data => {\n      if (performanceTrendChart.value) {\n        const ctx = performanceTrendChart.value.getContext('2d');\n\n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n\n        // Performance trends data\n        const performanceTrends = data.performanceTrends || [];\n        const labels = [];\n        const scores = [];\n\n        // Extract performance trends data\n        performanceTrends.forEach(item => {\n          // Format date if available\n          const date = item.date ? moment(item.date).format('MMM D') : '';\n          // Use assessment title or date as label\n          labels.push(item.title ? `${item.title} (${date})` : date);\n          scores.push(item.averageScore || 0);\n        });\n\n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: labels,\n            datasets: [{\n              label: 'Average Score',\n              data: scores,\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderColor: '#3b82f6',\n              borderWidth: 2,\n              tension: 0.4,\n              fill: true,\n              pointBackgroundColor: '#3b82f6',\n              pointRadius: 4,\n              pointHoverRadius: 6\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: false\n              },\n              tooltip: {\n                callbacks: {\n                  label: function (context) {\n                    return `Average Score: ${context.raw}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function (value) {\n                    return value + '%';\n                  }\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n    const updateSectionChart = data => {\n      if (sectionChart.value) {\n        const ctx = sectionChart.value.getContext('2d');\n\n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n\n        // Section performance data\n        const sectionData = data.sections || [];\n        const labels = [];\n        const performanceData = [];\n        const attendanceData = [];\n\n        // Extract section performance data\n        sectionData.forEach(section => {\n          labels.push(section.name);\n          performanceData.push(section.averageScore || 0);\n          attendanceData.push(section.attendanceRate || 0);\n        });\n\n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'bar',\n          data: {\n            labels: labels,\n            datasets: [{\n              label: 'Average Score',\n              data: performanceData,\n              backgroundColor: '#3b82f6',\n              borderWidth: 0,\n              borderRadius: 6,\n              maxBarThickness: 30\n            }, {\n              label: 'Attendance Rate',\n              data: attendanceData,\n              backgroundColor: '#10b981',\n              borderWidth: 0,\n              borderRadius: 6,\n              maxBarThickness: 30\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                  padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function (context) {\n                    const label = context.dataset.label || '';\n                    const value = context.raw || 0;\n                    return `${label}: ${value}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function (value) {\n                    return value + '%';\n                  }\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n    const refreshDashboard = () => {\n      fetchDashboardData();\n    };\n    const scrollToSection = sectionId => {\n      const section = document.getElementById(sectionId);\n      if (section) {\n        section.scrollIntoView({\n          behavior: 'smooth'\n        });\n      }\n    };\n\n    // Auto-refresh logic\n    const setupAutoRefresh = () => {\n      // Clear any existing interval\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n\n      // Set new interval (every 5 minutes)\n      autoRefreshInterval.value = setInterval(() => {\n        fetchDashboardData();\n      }, 5 * 60 * 1000);\n    };\n\n    // Fetch data on component mount\n    onMounted(async () => {\n      try {\n        // Initialize with dummy data while loading\n        nextTick(() => {\n          initDummyData();\n        });\n\n        // Set up API interceptor to handle 404 errors gracefully\n        api.interceptors.response.use(response => response, error => {\n          if (error.response && error.response.status === 404) {\n            console.warn(`API endpoint not found: ${error.config.url}`);\n            // Don't rethrow, allow handling in the catch block\n          }\n          return Promise.reject(error);\n        });\n\n        // Set auth token for API requests\n        if (store.state.auth.token) {\n          api.defaults.headers.common['Authorization'] = `Bearer ${store.state.auth.token}`;\n        }\n\n        // Fetch available years and sections with data\n        await fetchAvailableFilters();\n\n        // Fetch sections and subjects if year is selected\n        if (selectedYear.value) {\n          await fetchSectionsAndSubjects(selectedYear.value);\n        }\n\n        // Fetch dashboard data\n        await fetchDashboardData();\n        setupAutoRefresh();\n      } catch (error) {\n        console.error('Error initializing dashboard:', error);\n        // Initialize with dummy data if there's an error\n        initDummyData();\n      }\n    });\n\n    // Clean up on component unmount\n    onUnmounted(() => {\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n    });\n    return {\n      performanceChart,\n      assessmentTypeChart,\n      performanceTrendChart,\n      sectionChart,\n      selectedYear,\n      selectedSection,\n      selectedSubject,\n      sections,\n      subjects,\n      availableYears,\n      isCITHead,\n      userName,\n      hasActiveFilters,\n      totalStudents,\n      totalTeachers,\n      averageAttendance,\n      averageScore,\n      activeSections,\n      hasAttendanceData,\n      hasScoreData,\n      hasPerformanceData,\n      hasAssessmentData,\n      hasSectionData,\n      dashboardContainer,\n      isLoading,\n      lastUpdate,\n      formatDate,\n      scrollToSection,\n      handleYearChange,\n      handleSectionChange,\n      handleFilterChange,\n      clearFilters,\n      getFilterDisplay,\n      refreshDashboard,\n      fetchAvailableFilters\n    };\n  }\n};","map":{"version":3,"names":["ref","onMounted","computed","watch","onUnmounted","nextTick","useStore","Chart","axios","moment","api","create","baseURL","name","setup","store","performanceChart","assessmentTypeChart","performanceTrendChart","sectionChart","selectedYear","selectedSection","selectedSubject","dashboardContainer","isLoading","lastUpdate","autoRefreshInterval","sections","subjects","availableYears","isCITHead","getters","token","state","auth","userName","user","firstName","lastName","trim","hasActiveFilters","Boolean","value","newToken","defaults","headers","common","immediate","totalStudents","totalTeachers","averageAttendance","averageScore","activeSections","data","hasAttendanceData","attendanceDistribution","some","val","hasScoreData","hasPerformanceData","Array","isArray","performanceTrends","length","hasAssessmentData","assessmentTypes","Object","values","type","count","assessmentTypeDistribution","hasSectionData","fetchAvailableFilters","teacherClassRecordsResponse","get","records","uniqueYears","Set","map","record","year","filter","sort","uniqueSections","uniqueSubjects","forEach","section","s","push","id","_id","teacherName","subject","error","console","fetchSectionsAndSubjects","response","params","fetchSubjectsBySection","fetchAttendanceData","attendanceParams","dashboardResponse","distribution","log","attendanceResponse","attendanceCounts","status","fetchDashboardData","statsResponse","totalAttendance","reduce","a","b","presentAttendance","Math","round","processAssessmentData","updateCharts","Date","trend","date","title","score","assessmentResponse","assessments","totalScore","scores","assessment","percentage","maxScore","keys","typeData","completionRate","sum","sectionPerformance","scoreCount","attendanceCount","attendanceTotal","sectionName","attendanceRate","performance","updatePerformanceChart","updateAssessmentTypeChart","updatePerformanceTrendChart","updateSectionChart","initDummyData","dummyData","formatDate","format","handleYearChange","handleSectionChange","handleFilterChange","clearFilters","then","getFilterDisplay","filters","sectionObj","find","subjectObj","join","ctx","getContext","chart","destroy","attendanceLabels","attendanceData","labels","datasets","backgroundColor","borderWidth","hoverOffset","options","responsive","maintainAspectRatio","cutout","plugins","legend","position","usePointStyle","padding","font","size","tooltip","callbacks","label","context","raw","total","assessmentData","colors","item","index","parseFloat","entries","slice","borderRadius","maxBarThickness","display","scales","y","beginAtZero","max","ticks","callback","borderColor","tension","fill","pointBackgroundColor","pointRadius","pointHoverRadius","x","maxRotation","minRotation","sectionData","performanceData","dataset","refreshDashboard","scrollToSection","sectionId","document","getElementById","scrollIntoView","behavior","setupAutoRefresh","clearInterval","setInterval","interceptors","use","warn","config","url","Promise","reject"],"sources":["D:\\au_dev\\client\\src\\views\\Dashboard.vue"],"sourcesContent":["<template>\n  <div class=\"dashboard\" ref=\"dashboardContainer\">\n    <!-- Greeting Section -->\n    <div class=\"greeting-section mb-4\">\n      <h2 class=\"greeting\">Welcome, Dean {{ userName }}</h2>\n      <p class=\"greeting-subtitle\">Computer and Information Technology Department Dashboard</p>\n    </div>\n    \n    <div class=\"d-flex justify-content-between align-items-center mb-4\">\n      <!-- Combined Filter Dropdown -->\n      <div class=\"dropdown\">\n        <button class=\"btn btn-filter dropdown-toggle\" type=\"button\" id=\"filterDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n          <i class=\"fas fa-filter me-2\"></i>\n          {{ getFilterDisplay() }}\n        </button>\n        <div class=\"dropdown-menu filter-menu p-3\" aria-labelledby=\"filterDropdown\">\n          <h6 class=\"dropdown-header\">Filter Options</h6>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Academic Year</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedYear\" @change=\"handleYearChange\">\n              <option value=\"\">All Years</option>\n              <option v-for=\"year in availableYears\" :key=\"year\" :value=\"year\">{{ year }} Year</option>\n          </select>\n        </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Section</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedSection\" @change=\"handleSectionChange\" :disabled=\"!selectedYear\">\n              <option value=\"\">All Sections</option>\n              <option v-for=\"section in sections\" :key=\"section.id\" :value=\"section.name\">\n                {{ section.name }}{{ section.teacherName ? ` - ${section.teacherName}` : '' }}\n              </option>\n            </select>\n          </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Subject</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedSubject\" @change=\"handleFilterChange\" :disabled=\"!selectedYear\">\n              <option value=\"\">All Subjects</option>\n              <option v-for=\"subject in subjects\" :key=\"subject.id\" :value=\"subject.name\">\n                {{ subject.name }}{{ subject.teacherName ? ` - ${subject.teacherName}` : '' }}\n              </option>\n            </select>\n          </div>\n          <div class=\"d-flex justify-content-between\">\n            <button class=\"btn btn-outline-secondary\" @click=\"clearFilters\">Clear Filters</button>\n            <button class=\"btn btn-primary\" @click=\"refreshDashboard\">Apply</button>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Last Updated -->\n      <div class=\"last-update-badge\" v-if=\"lastUpdate\">\n        Last updated: {{ formatDate(lastUpdate) }}\n        <button class=\"btn btn-refresh ms-2\" @click=\"refreshDashboard\" title=\"Refresh Dashboard\">\n          <i class=\"fas fa-sync-alt\"></i>\n        </button>\n      </div>\n    </div>\n\n    <!-- Stats Cards -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Total Students Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-user-graduate\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Students</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ totalStudents }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n        </div>\n      </div>\n      </div>\n\n      <!-- Total Teachers Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-chalkboard-teacher\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Teachers</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ totalTeachers }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n        </div>\n      </div>\n        </div>\n\n      <!-- Active Sections Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-users\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Active Sections</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ activeSections }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Performance Stats -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Average Attendance Card -->\n      <div class=\"col-md-6\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-clock\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Average Attendance</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading && hasAttendanceData\">{{ averageAttendance }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"isLoading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n        </div>\n      </div>\n      </div>\n      \n      <!-- Average Score Card -->\n      <div class=\"col-md-6\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-chart-line\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Average Score</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading && hasScoreData\">{{ averageScore }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"isLoading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Charts Row -->\n    <div class=\"row mb-4\">\n      <!-- Attendance Distribution Chart -->\n      <div class=\"col-md-6 mb-4\">\n      <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-calendar-check me-2\"></i>\n              Attendance Distribution\n            </h5>\n            <p class=\"chart-description\">Breakdown of student attendance patterns across the department</p>\n        <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n          <canvas ref=\"performanceChart\"></canvas>\n              <p v-if=\"!hasAttendanceData && !isLoading\" class=\"no-data-message\">No attendance data available</p>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Assessment Type Distribution -->\n      <div class=\"col-md-6 mb-4\">\n      <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-tasks me-2\"></i>\n              Assessment Performance Analysis\n            </h5>\n            <p class=\"chart-description\">Average scores by assessment type across the department</p>\n        <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n          <canvas ref=\"assessmentTypeChart\"></canvas>\n              <p v-if=\"!hasAssessmentData && !isLoading\" class=\"no-data-message\">No assessment data available</p>\n            </div>\n        </div>\n      </div>\n    </div>\n\n      <!-- Performance Trend Chart -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-chart-line me-2\"></i>\n              Performance Trends Over Time\n            </h5>\n            <p class=\"chart-description\">Department average scores across recent assessments</p>\n      <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"performanceTrendChart\"></canvas>\n              <p v-if=\"!hasPerformanceData && !isLoading\" class=\"no-data-message\">No performance data available</p>\n            </div>\n          </div>\n      </div>\n    </div>\n\n    <!-- Section Performance -->\n      <div class=\"col-md-6 mb-4\">\n    <div class=\"chart-card\">\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <i class=\"fas fa-users me-2\"></i>\n              Section Performance\n            </h5>\n            <p class=\"chart-description\">Comparison of performance across different sections</p>\n      <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n        <canvas ref=\"sectionChart\"></canvas>\n              <p v-if=\"!hasSectionData && !isLoading\" class=\"no-data-message\">No section data available</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted, computed, watch, onUnmounted, nextTick } from 'vue'\nimport { useStore } from 'vuex'\nimport Chart from 'chart.js/auto'\nimport axios from 'axios'\nimport moment from 'moment'\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: 'http://localhost:8000/api'\n});\n\nexport default {\n  name: 'Dashboard',\n  setup() {\n    const store = useStore()\n    const performanceChart = ref(null)\n    const assessmentTypeChart = ref(null)\n    const performanceTrendChart = ref(null)\n    const sectionChart = ref(null)\n    const selectedYear = ref('')\n    const selectedSection = ref('')\n    const selectedSubject = ref('')\n    const dashboardContainer = ref(null)\n    const isLoading = ref(false)\n    const lastUpdate = ref(null)\n    const autoRefreshInterval = ref(null)\n    const sections = ref([])\n    const subjects = ref([])\n    const availableYears = ref(['1st', '2nd', '3rd', '4th'])\n\n    // Computed properties\n    const isCITHead = computed(() => store.getters.isCITHead)\n    const token = computed(() => store.state.auth.token)\n    \n    // Get user name\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'User' : 'User';\n    });\n    \n    // Check if filters are active\n    const hasActiveFilters = computed(() => {\n      return Boolean(selectedYear.value || selectedSection.value || selectedSubject.value);\n    });\n\n    // Set auth token for all requests\n    watch(token, (newToken) => {\n      if (newToken) {\n        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      }\n    }, { immediate: true });\n\n    // Dashboard stats\n    const totalStudents = ref(0)\n    const totalTeachers = ref(0)\n    const averageAttendance = ref(0)\n    const averageScore = ref(0)\n    const activeSections = ref(0)\n    const data = ref(null)\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      if (data.value && data.value.attendanceDistribution) {\n        return data.value.attendanceDistribution.some(val => val > 0);\n      }\n      return false;\n    });\n\n    const hasScoreData = computed(() => {\n      return data.value?.averageScore > 0;\n    });\n\n    const hasPerformanceData = computed(() => {\n      // Check if we have any assessment or performance data\n      if (data.value) {\n        // Check for averageScore > 0\n        if (typeof data.value.averageScore === 'number' && data.value.averageScore > 0) {\n          return true;\n        }\n        \n        // Check for performance trends\n        if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    });\n\n    const hasAssessmentData = computed(() => {\n      if (data.value) {\n        // Check directly in assessmentTypes\n        if (data.value.assessmentTypes) {\n          const assessmentTypes = Object.values(data.value.assessmentTypes);\n          return assessmentTypes.some(type => type.count > 0);\n        }\n        \n        // Fallback to assessmentTypeDistribution\n        if (data.value.assessmentTypeDistribution) {\n          return true;\n        }\n      }\n      return false;\n    });\n\n    const hasSectionData = computed(() => {\n      return data.value?.sections?.length > 0;\n    });\n\n    // Fetch years and sections with data from all teacher class records\n    const fetchAvailableFilters = async () => {\n      try {\n        // Use existing backend endpoints that already pull data from TeacherClassRecord\n        const teacherClassRecordsResponse = await api.get('/teacher-class-records');\n        \n        if (teacherClassRecordsResponse.data) {\n          const records = teacherClassRecordsResponse.data;\n          \n          // Extract unique years, sections, and subjects with teacher info\n          const uniqueYears = [...new Set(records.map(record => record.year))].filter(Boolean).sort();\n          const uniqueSections = [];\n          const uniqueSubjects = [];\n          \n          // Process sections with teacher info\n          records.forEach(record => {\n            if (record.section && !uniqueSections.some(s => s.name === record.section)) {\n              uniqueSections.push({\n                id: record._id,\n                name: record.section,\n                teacherName: record.teacherName || ''\n              });\n            }\n            \n            if (record.subject && !uniqueSubjects.some(s => s.name === record.subject)) {\n              uniqueSubjects.push({\n                id: record._id,\n                name: record.subject,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n          \n          // Update reactive data\n          availableYears.value = uniqueYears.length > 0 ? uniqueYears : ['1st', '2nd', '3rd', '4th'];\n          \n          // If no year is selected, populate all available sections with teacher info\n          if (!selectedYear.value) {\n            sections.value = uniqueSections;\n            subjects.value = uniqueSubjects;\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching available filters:', error);\n        // Keep default years if API fails\n        availableYears.value = ['1st', '2nd', '3rd', '4th'];\n      }\n    };\n\n    // Fetch sections and subjects with data for a specific year\n    const fetchSectionsAndSubjects = async (year = '') => {\n      try {\n        // Use existing backend endpoints that already pull data from TeacherClassRecord\n        const response = await api.get('/teacher-class-records', {\n          params: { year }\n        });\n        \n        if (response.data) {\n          const records = response.data;\n          \n          // Process sections with teacher info for the selected year\n          const uniqueSections = [];\n          records.forEach(record => {\n            if (record.section && !uniqueSections.some(s => s.name === record.section)) {\n              uniqueSections.push({\n                id: record._id,\n                name: record.section,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n          \n          // Extract unique subjects\n          const uniqueSubjects = [];\n          records.forEach(record => {\n            if (record.subject && !uniqueSubjects.some(s => s.name === record.subject)) {\n              uniqueSubjects.push({\n                id: record._id,\n                name: record.subject,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n          \n          sections.value = uniqueSections;\n          subjects.value = uniqueSubjects;\n        }\n      } catch (error) {\n        console.error('Error fetching sections and subjects:', error);\n        sections.value = [];\n        subjects.value = [];\n      }\n    };\n\n    // Fetch subjects for a specific section with data\n    const fetchSubjectsBySection = async (year, section) => {\n      try {\n        // Use existing endpoints\n        const response = await api.get('/teacher-class-records', {\n          params: { year, section }\n        });\n        \n        if (response.data) {\n          const records = response.data;\n          \n          // Extract unique subjects for this section\n          const uniqueSubjects = [];\n          records.forEach(record => {\n            if (record.subject && !uniqueSubjects.some(s => s.name === record.subject)) {\n              uniqueSubjects.push({\n                id: record._id,\n                name: record.subject,\n                teacherName: record.teacherName || ''\n              });\n            }\n          });\n          \n          subjects.value = uniqueSubjects;\n        }\n      } catch (error) {\n        console.error('Error fetching subjects by section:', error);\n        subjects.value = [];\n      }\n    };\n\n    // Get attendance data for the charts\n    const fetchAttendanceData = async () => {\n      try {\n        // Make a specific request for attendance data with the selected filters\n        const attendanceParams = {\n          year: selectedYear.value,\n          section: selectedSection.value,\n          subject: selectedSubject.value\n        };\n        \n        // First try the /dashboard/attendance endpoint\n        try {\n          const dashboardResponse = await api.get('/dashboard/attendance', { params: attendanceParams });\n          \n          if (dashboardResponse.data && dashboardResponse.data.distribution) {\n            // If the backend provides a formatted distribution, use it directly\n            return dashboardResponse.data.distribution;\n          }\n        } catch (error) {\n          console.log('Falling back to raw attendance records');\n        }\n        \n        // If no dashboard endpoint or it didn't return distribution, fetch raw attendance records\n        const attendanceResponse = await api.get('/attendance', { params: attendanceParams });\n        \n        if (attendanceResponse.data && Array.isArray(attendanceResponse.data)) {\n          // Process raw attendance records\n          const attendanceCounts = [0, 0, 0]; // [present, late, absent]\n          \n          attendanceResponse.data.forEach(record => {\n            if (record.status === 'present') attendanceCounts[0]++;\n            else if (record.status === 'late') attendanceCounts[1]++;\n            else if (record.status === 'absent') attendanceCounts[2]++;\n          });\n          \n          return attendanceCounts;\n        }\n        \n        return [0, 0, 0]; // Default return if no data\n      } catch (error) {\n        console.error('Error fetching attendance data:', error);\n        return [0, 0, 0]; // Default on error\n      }\n    };\n\n    const fetchDashboardData = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Use the existing stats endpoint from dashboard.js\n        const statsResponse = await api.get('/dashboard/stats', {\n          params: {\n            year: selectedYear.value,\n            section: selectedSection.value,\n            subject: selectedSubject.value\n          }\n        });\n        \n        data.value = statsResponse.data || {};\n        \n        // Update basic stats from the response structure in dashboard.js\n        totalStudents.value = data.value.totalStudents || 0;\n        totalTeachers.value = data.value.totalTeachers || 0;\n        activeSections.value = data.value.activeSections || 0;\n        \n        // Update additional stats from the response\n        if (typeof data.value.averageAttendance === 'number') {\n          averageAttendance.value = data.value.averageAttendance;\n        } else {\n          // If not provided, calculate from attendance data\n          const attendanceDistribution = await fetchAttendanceData();\n          const totalAttendance = attendanceDistribution.reduce((a, b) => a + b, 0);\n          \n          if (totalAttendance > 0) {\n            // Calculate percentage of present and late (not absent)\n            const presentAttendance = attendanceDistribution[0] + attendanceDistribution[1];\n            averageAttendance.value = Math.round((presentAttendance / totalAttendance) * 100);\n          } else {\n            averageAttendance.value = 0;\n          }\n        }\n        \n        averageScore.value = data.value.averageScore || 0;\n        \n        // Get attendance data for charts - must run even if stats provided it\n        data.value.attendanceDistribution = await fetchAttendanceData();\n        \n        // Process assessment data for charts\n        await processAssessmentData(data.value);\n\n        // Update charts with new data\n        updateCharts(data.value);\n        \n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Failed to fetch dashboard data:', error);\n        if (error.response) {\n          console.error('Error response:', error.response.data);\n        }\n        \n        // Initialize with empty data if main stats request fails\n        data.value = {\n          totalStudents: 0,\n          totalTeachers: 0,\n          activeSections: 0,\n          attendanceDistribution: [0, 0, 0],\n          averageAttendance: 0,\n          assessmentTypes: [],\n          performanceTrends: [],\n          averageScore: 0,\n          sections: []\n        };\n        \n        totalStudents.value = 0;\n        totalTeachers.value = 0;\n        activeSections.value = 0;\n        averageAttendance.value = 0;\n        averageScore.value = 0;\n        \n        // Update charts with empty data\n        updateCharts(data.value);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    \n    // Process assessment data for charts\n    const processAssessmentData = async (data) => {\n      try {\n        // Try to use the assessment data from stats if available\n        if (data.performanceTrends && Array.isArray(data.performanceTrends) && data.performanceTrends.length > 0) {\n          // Already have the data from stats endpoint, just ensure it has the right format\n          data.performanceTrends = data.performanceTrends.map(trend => ({\n            date: trend.date,\n            title: trend.name || '',\n            averageScore: trend.score || 0,\n            type: trend.type || ''\n          }));\n        } else {\n          // Otherwise fetch assessment data specifically for the filters\n          const assessmentResponse = await api.get('/assessments', {\n            params: {\n              year: selectedYear.value,\n              section: selectedSection.value,\n              subject: selectedSubject.value\n            }\n          });\n          \n          if (assessmentResponse.data && Array.isArray(assessmentResponse.data)) {\n            const assessments = assessmentResponse.data;\n            \n            // Group assessments by type\n            const assessmentTypes = {\n              'Quiz': { count: 0, totalScore: 0, scores: [] },\n              'Activity': { count: 0, totalScore: 0, scores: [] },\n              'Performance Task': { count: 0, totalScore: 0, scores: [] }\n            };\n            \n            // Process each assessment\n            assessments.forEach(assessment => {\n              const type = assessment.type || 'Other';\n              if (assessmentTypes[type]) {\n                assessmentTypes[type].count++;\n                \n                // Process scores if available\n                if (assessment.scores && Array.isArray(assessment.scores)) {\n                  assessment.scores.forEach(score => {\n                    if (typeof score === 'number') {\n                      const percentage = assessment.maxScore ? (score / assessment.maxScore) * 100 : score;\n                      assessmentTypes[type].totalScore += percentage;\n                      assessmentTypes[type].scores.push(percentage);\n                    }\n                  });\n                }\n              }\n            });\n            \n            // Calculate averages and prepare for chart\n            data.assessmentTypes = Object.keys(assessmentTypes).map(type => {\n              const typeData = assessmentTypes[type];\n              const averageScore = typeData.scores.length > 0 \n                ? typeData.totalScore / typeData.scores.length \n                : 0;\n                \n              return {\n                type,\n                averageScore: Math.round(averageScore),\n                count: typeData.count,\n                completionRate: typeData.count > 0 ? 100 : 0\n              };\n            });\n            \n            // Generate performance trends from assessment data\n            data.performanceTrends = assessments\n              .filter(a => a.date) // Only include assessments with dates\n              .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date\n              .map(assessment => {\n                // Calculate average score for this assessment\n                let averageScore = 0;\n                if (assessment.scores && Array.isArray(assessment.scores) && assessment.scores.length > 0) {\n                  const totalScore = assessment.scores.reduce((sum, score) => sum + (typeof score === 'number' ? score : 0), 0);\n                  averageScore = assessment.maxScore \n                    ? (totalScore / assessment.scores.length / assessment.maxScore) * 100\n                    : totalScore / assessment.scores.length;\n                }\n                \n                return {\n                  date: assessment.date,\n                  title: assessment.name || assessment.type,\n                  averageScore: Math.round(averageScore),\n                  type: assessment.type\n                };\n              });\n              \n              // If no performance trends data, use dummy or empty array\n              if (data.performanceTrends.length === 0) {\n                data.performanceTrends = [];\n              }\n              \n              // Process section data if available\n              if (assessments.length > 0) {\n                // Group assessments by section\n                const sectionPerformance = {};\n                \n                assessments.forEach(assessment => {\n                  if (assessment.section && assessment.scores && Array.isArray(assessment.scores)) {\n                    if (!sectionPerformance[assessment.section]) {\n                      sectionPerformance[assessment.section] = {\n                        totalScore: 0,\n                        scoreCount: 0,\n                        attendanceCount: 0,\n                        attendanceTotal: 0\n                      };\n                    }\n                    \n                    assessment.scores.forEach(score => {\n                      if (typeof score === 'number') {\n                        const percentage = assessment.maxScore ? (score / assessment.maxScore) * 100 : score;\n                        sectionPerformance[assessment.section].totalScore += percentage;\n                        sectionPerformance[assessment.section].scoreCount++;\n                      }\n                    });\n                  }\n                });\n                \n                // Prepare section data for chart\n                if (Object.keys(sectionPerformance).length > 0) {\n                  data.sections = Object.keys(sectionPerformance).map(sectionName => {\n                    const section = sectionPerformance[sectionName];\n                    const averageScore = section.scoreCount > 0 \n                      ? section.totalScore / section.scoreCount \n                      : 0;\n                    const attendanceRate = section.attendanceTotal > 0 \n                      ? section.attendanceCount / section.attendanceTotal * 100 \n                      : 0;\n                    \n                    return {\n                      name: sectionName,\n                      averageScore: Math.round(averageScore),\n                      attendanceRate: Math.round(attendanceRate),\n                      performance: Math.round(averageScore) // For backward compatibility\n                    };\n                  });\n                }\n              }\n          }\n        }\n      } catch (error) {\n        console.error('Error processing assessment data:', error);\n        \n        // Set default values for assessment data\n        data.assessmentTypes = [\n          { type: 'Quiz', averageScore: 0, count: 0 },\n          { type: 'Activity', averageScore: 0, count: 0 },\n          { type: 'Performance Task', averageScore: 0, count: 0 }\n        ];\n        \n        // Leave other data as is, but ensure we have arrays\n        if (!data.performanceTrends) data.performanceTrends = [];\n        if (!data.sections) data.sections = [];\n      }\n    };\n\n    const updateCharts = (data) => {\n      updatePerformanceChart(data);\n      updateAssessmentTypeChart(data);\n      updatePerformanceTrendChart(data);\n      updateSectionChart(data);\n    };\n\n    // Initialize dummy data for charts when no data is available\n    const initDummyData = () => {\n      // Create sample data structure\n      const dummyData = {\n        totalStudents: 0,\n        totalTeachers: 0,\n        activeSections: 0,\n        averageAttendance: 0,\n        averageScore: 0,\n        attendanceDistribution: [0, 0, 0],\n        assessmentTypes: [\n          { type: 'Quiz', averageScore: 0, count: 0 },\n          { type: 'Activity', averageScore: 0, count: 0 },\n          { type: 'Performance Task', averageScore: 0, count: 0 }\n        ],\n        performanceTrends: [],\n        sections: []\n      };\n      \n      // Update charts with dummy data\n      updateCharts(dummyData);\n    };\n\n    // Format date for display\n    const formatDate = (date) => {\n      if (!date) return '';\n      return moment(date).format('MMMM D, YYYY h:mm A');\n    };\n\n    // Handle year change\n    const handleYearChange = async () => {\n      selectedSection.value = '';\n      selectedSubject.value = '';\n      \n      if (selectedYear.value) {\n        await fetchSectionsAndSubjects(selectedYear.value);\n      } else {\n        sections.value = [];\n        subjects.value = [];\n      }\n      \n      await fetchDashboardData();\n    };\n\n    // Handle section change\n    const handleSectionChange = () => {\n      // If a section is selected, filter subjects by that section\n      if (selectedSection.value) {\n        fetchSubjectsBySection(selectedYear.value, selectedSection.value);\n      } else {\n        // If no section selected, fetch all subjects for the year\n        fetchSectionsAndSubjects(selectedYear.value);\n      }\n      \n      fetchDashboardData();\n    };\n\n    // Handle filter change\n    const handleFilterChange = () => {\n      fetchDashboardData();\n    };\n\n    // Clear all filters\n    const clearFilters = () => {\n      selectedYear.value = '';\n      selectedSection.value = '';\n      selectedSubject.value = '';\n      \n      // Refresh available filters after clearing\n      fetchAvailableFilters().then(() => {\n        fetchDashboardData();\n      });\n    };\n\n    // Get filter display text\n    const getFilterDisplay = () => {\n      const filters = [];\n      if (selectedYear.value) filters.push(selectedYear.value + ' Year');\n      \n      if (selectedSection.value) {\n        // Find the section object to get teacher name\n        const sectionObj = sections.value.find(s => s.name === selectedSection.value);\n        if (sectionObj && sectionObj.teacherName) {\n          filters.push(`${selectedSection.value} - ${sectionObj.teacherName}`);\n        } else {\n          filters.push(selectedSection.value);\n        }\n      }\n      \n      if (selectedSubject.value) {\n        // Find the subject object to get teacher name\n        const subjectObj = subjects.value.find(s => s.name === selectedSubject.value);\n        if (subjectObj && subjectObj.teacherName) {\n          filters.push(`${selectedSubject.value} - ${subjectObj.teacherName}`);\n        } else {\n          filters.push(selectedSubject.value);\n        }\n      }\n      \n      return filters.length > 0 ? filters.join(' - ') : 'Filter View';\n    };\n\n    // Update charts with data\n    const updatePerformanceChart = (data) => {\n      if (performanceChart.value) {\n        const ctx = performanceChart.value.getContext('2d');\n        \n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n        \n        // Attendance status distribution data\n        const attendanceLabels = ['Present', 'Late', 'Absent'];\n        const attendanceData = data.attendanceDistribution || [0, 0, 0];\n        \n        // Log for debugging\n        console.log('Attendance distribution data:', attendanceData);\n        \n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: attendanceLabels,\n            datasets: [{\n              data: attendanceData,\n              backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],\n              borderWidth: 0,\n              hoverOffset: 4\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            cutout: '70%',\n            plugins: {\n              legend: {\n                position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                  padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function(context) {\n                    const label = context.label || '';\n                    const value = context.raw || 0;\n                    const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);\n                    const percentage = total > 0 ? Math.round((value / total) * 100) : 0;\n                    return `${label}: ${value} (${percentage}%)`;\n                  }\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const updateAssessmentTypeChart = (data) => {\n      if (assessmentTypeChart.value) {\n        const ctx = assessmentTypeChart.value.getContext('2d');\n        \n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n        \n        // Assessment types data\n        const assessmentData = data.assessmentTypes || [];\n        const labels = [];\n        const values = [];\n        const colors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#6366f1'];\n        \n        try {\n          // Extract assessment types data\n          if (Array.isArray(assessmentData)) {\n            // If array format\n            assessmentData.forEach((item, index) => {\n              if (item && typeof item === 'object') {\n                labels.push(item.type || `Type ${index + 1}`);\n                values.push(parseFloat(item.averageScore) || 0);\n              }\n            });\n          } else if (typeof assessmentData === 'object' && assessmentData !== null) {\n            // If object format\n            Object.entries(assessmentData).forEach(([type, data], index) => {\n              labels.push(type);\n              values.push(parseFloat(data.averageScore) || 0);\n            });\n          }\n          \n          // If no data was extracted, use default types\n          if (labels.length === 0) {\n            labels.push('Quiz', 'Activity', 'Performance Task');\n            values.push(0, 0, 0);\n          }\n        } catch (error) {\n          console.error('Error processing assessment data:', error);\n          // Fallback to default labels and values\n          labels.push('Quiz', 'Activity', 'Performance Task');\n          values.push(0, 0, 0);\n        }\n        \n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'bar',\n          data: {\n            labels: labels,\n            datasets: [{\n              label: 'Average Score (%)',\n              data: values,\n              backgroundColor: colors.slice(0, labels.length),\n              borderWidth: 0,\n              borderRadius: 6,\n              maxBarThickness: 50\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                  display: false\n              },\n              tooltip: {\n                callbacks: {\n                  label: function(context) {\n                    return `Average Score: ${context.raw}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function(value) {\n                    return value + '%';\n                  }\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const updatePerformanceTrendChart = (data) => {\n      if (performanceTrendChart.value) {\n        const ctx = performanceTrendChart.value.getContext('2d');\n        \n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n        \n        // Performance trends data\n        const performanceTrends = data.performanceTrends || [];\n        const labels = [];\n        const scores = [];\n        \n        // Extract performance trends data\n        performanceTrends.forEach(item => {\n          // Format date if available\n          const date = item.date ? moment(item.date).format('MMM D') : '';\n          // Use assessment title or date as label\n          labels.push(item.title ? `${item.title} (${date})` : date);\n          scores.push(item.averageScore || 0);\n        });\n        \n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: labels,\n            datasets: [{\n              label: 'Average Score',\n              data: scores,\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderColor: '#3b82f6',\n              borderWidth: 2,\n              tension: 0.4,\n              fill: true,\n              pointBackgroundColor: '#3b82f6',\n              pointRadius: 4,\n              pointHoverRadius: 6\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: false\n              },\n              tooltip: {\n                callbacks: {\n                  label: function(context) {\n                    return `Average Score: ${context.raw}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function(value) {\n                    return value + '%';\n                  }\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const updateSectionChart = (data) => {\n      if (sectionChart.value) {\n        const ctx = sectionChart.value.getContext('2d');\n        \n        // Dispose of existing chart if it exists\n        if (ctx.chart) {\n          ctx.chart.destroy();\n        }\n        \n        // Section performance data\n        const sectionData = data.sections || [];\n        const labels = [];\n        const performanceData = [];\n        const attendanceData = [];\n        \n        // Extract section performance data\n        sectionData.forEach(section => {\n          labels.push(section.name);\n          performanceData.push(section.averageScore || 0);\n          attendanceData.push(section.attendanceRate || 0);\n        });\n        \n        // Create chart\n        ctx.chart = new Chart(ctx, {\n          type: 'bar',\n          data: {\n            labels: labels,\n            datasets: [\n              {\n                label: 'Average Score',\n                data: performanceData,\n                backgroundColor: '#3b82f6',\n                borderWidth: 0,\n                borderRadius: 6,\n                maxBarThickness: 30\n              },\n              {\n                label: 'Attendance Rate',\n                data: attendanceData,\n                backgroundColor: '#10b981',\n                borderWidth: 0,\n                borderRadius: 6,\n                maxBarThickness: 30\n              }\n            ]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                  padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function(context) {\n                    const label = context.dataset.label || '';\n                    const value = context.raw || 0;\n                    return `${label}: ${value}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                ticks: {\n                  callback: function(value) {\n                    return value + '%';\n                  }\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const refreshDashboard = () => {\n      fetchDashboardData();\n    };\n\n    const scrollToSection = (sectionId) => {\n      const section = document.getElementById(sectionId);\n      if (section) {\n        section.scrollIntoView({ behavior: 'smooth' });\n      }\n    };\n\n    // Auto-refresh logic\n    const setupAutoRefresh = () => {\n      // Clear any existing interval\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n      \n      // Set new interval (every 5 minutes)\n      autoRefreshInterval.value = setInterval(() => {\n        fetchDashboardData();\n      }, 5 * 60 * 1000);\n    };\n\n    // Fetch data on component mount\n    onMounted(async () => {\n      try {\n        // Initialize with dummy data while loading\n        nextTick(() => {\n          initDummyData();\n        });\n        \n        // Set up API interceptor to handle 404 errors gracefully\n        api.interceptors.response.use(\n          response => response,\n          error => {\n            if (error.response && error.response.status === 404) {\n              console.warn(`API endpoint not found: ${error.config.url}`);\n              // Don't rethrow, allow handling in the catch block\n            }\n            return Promise.reject(error);\n          }\n        );\n        \n        // Set auth token for API requests\n        if (store.state.auth.token) {\n          api.defaults.headers.common['Authorization'] = `Bearer ${store.state.auth.token}`;\n        }\n        \n        // Fetch available years and sections with data\n        await fetchAvailableFilters();\n        \n        // Fetch sections and subjects if year is selected\n        if (selectedYear.value) {\n          await fetchSectionsAndSubjects(selectedYear.value);\n        }\n        \n        // Fetch dashboard data\n        await fetchDashboardData();\n        setupAutoRefresh();\n      } catch (error) {\n        console.error('Error initializing dashboard:', error);\n        // Initialize with dummy data if there's an error\n        initDummyData();\n      }\n    });\n\n    // Clean up on component unmount\n    onUnmounted(() => {\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n    });\n\n    return {\n      performanceChart,\n      assessmentTypeChart,\n      performanceTrendChart,\n      sectionChart,\n      selectedYear,\n      selectedSection,\n      selectedSubject,\n      sections,\n      subjects,\n      availableYears,\n      isCITHead,\n      userName,\n      hasActiveFilters,\n      totalStudents,\n      totalTeachers,\n      averageAttendance,\n      averageScore,\n      activeSections,\n      hasAttendanceData,\n      hasScoreData,\n      hasPerformanceData,\n      hasAssessmentData,\n      hasSectionData,\n      dashboardContainer,\n      isLoading,\n      lastUpdate,\n      formatDate,\n      scrollToSection,\n      handleYearChange,\n      handleSectionChange,\n      handleFilterChange,\n      clearFilters,\n      getFilterDisplay,\n      refreshDashboard,\n      fetchAvailableFilters\n    }\n  }\n}\n</script>\n\n<style scoped>\n.dashboard {\n  padding: 2rem;\n  background-color: #f8f9fa;\n  min-height: 100vh;\n}\n\n/* Greeting Section Styles */\n.greeting-section {\n  padding-bottom: 1.5rem;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n}\n\n.greeting {\n  font-size: 2.25rem;\n  font-weight: 700;\n  color: #003366;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.5px;\n}\n\n.greeting-subtitle {\n  color: #64748b;\n  font-size: 1.125rem;\n  font-weight: 400;\n  margin: 0;\n}\n\n/* Filter and Form Styles */\n.btn-filter {\n  background-color: white;\n  border: 1px solid #e2e8f0;\n  padding: 0.75rem 1.25rem;\n  font-size: 0.9rem;\n  color: #1e293b;\n  min-width: 220px;\n  text-align: left;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s ease;\n}\n\n.btn-filter:hover {\n  background-color: #f8fafc;\n  border-color: #003366;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);\n}\n\n.filter-menu {\n  width: 320px;\n  padding: 1.25rem;\n  border: none;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\n  border-radius: 12px;\n}\n\n.dropdown-header {\n  color: #003366;\n  font-weight: 700;\n  padding: 0;\n  margin-bottom: 1.25rem;\n  font-size: 1rem;\n}\n\n.form-label {\n  font-weight: 600;\n  color: #475569;\n  margin-bottom: 0.5rem;\n  font-size: 0.875rem;\n}\n\n.last-update-badge {\n  font-size: 0.85rem;\n  color: #64748b;\n  display: flex;\n  align-items: center;\n}\n\n.btn-refresh {\n  background: white;\n  border: 1px solid #e2e8f0;\n  color: #4a5568;\n  padding: 0.5rem;\n  border-radius: 8px;\n  width: 36px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s ease;\n}\n\n.btn-refresh:hover {\n  background: #f7fafc;\n  color: #2d3748;\n  border-color: #cbd5e1;\n}\n\n/* Dashboard Cards */\n.dashboard-card {\n  background: #fff;\n  border-radius: 12px;\n  padding: 1.5rem;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  display: flex;\n  align-items: center;\n  gap: 1.25rem;\n  height: 100%;\n  transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n.dashboard-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);\n}\n\n.icon-container {\n  width: 52px;\n  height: 52px;\n  border-radius: 12px;\n  background-color: #003366;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: transform 0.2s ease;\n}\n\n.dashboard-card:hover .icon-container {\n  transform: scale(1.05);\n}\n\n.icon-container i {\n  color: white;\n  font-size: 1.5rem;\n}\n\n.card-info {\n  flex: 1;\n}\n\n.stat-title {\n  font-size: 0.875rem;\n  color: #64748b;\n  margin: 0 0 0.5rem 0;\n  font-weight: 600;\n  letter-spacing: 0.3px;\n}\n\n.stat-value {\n  font-size: 1.75rem;\n  font-weight: 700;\n  color: #1e293b;\n  line-height: 1.2;\n}\n\n.stat-value.loading {\n  color: #94a3b8;\n  font-size: 1.5rem;\n}\n\n.no-data {\n  color: #94a3b8;\n  font-style: italic;\n  font-size: 0.875rem;\n}\n\n/* Chart Cards */\n.chart-card {\n  background: white;\n  border-radius: 12px;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  height: 100%;\n}\n\n.card-body {\n  padding: 1.5rem;\n}\n\n.card-title {\n  font-size: 1.125rem;\n  font-weight: 700;\n  color: #1e293b;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.3px;\n}\n\n.chart-description {\n  font-size: 0.85rem;\n  color: #64748b;\n  margin-bottom: 1.25rem;\n  font-style: italic;\n}\n\n.chart-container {\n  position: relative;\n  height: 400px;\n  width: 100%;\n  margin-bottom: 1rem;\n}\n\n.loading-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background-color: rgba(255, 255, 255, 0.8);\n  z-index: 10;\n  border-radius: 8px;\n}\n\n.loading-overlay i {\n  font-size: 2rem;\n  color: #003366;\n  margin-bottom: 1rem;\n}\n\n.loading-overlay p {\n  font-size: 0.9rem;\n  color: #64748b;\n}\n\n.no-data-message {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  color: #94a3b8;\n  font-style: italic;\n  text-align: center;\n  width: 100%;\n  padding: 1rem;\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n  .dashboard {\n    padding: 1rem;\n  }\n\n  .greeting {\n    font-size: 1.75rem;\n  }\n  \n  .filter-menu {\n    width: 100%;\n    max-width: 320px;\n  }\n\n  .btn-filter {\n    min-width: auto;\n    width: 100%;\n  }\n  \n  .chart-container {\n    height: 300px;\n  }\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}