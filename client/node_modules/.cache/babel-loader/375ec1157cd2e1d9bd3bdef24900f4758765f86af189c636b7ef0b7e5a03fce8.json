{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { ref, onMounted, computed, watch, onUnmounted, nextTick } from 'vue';\nimport { useStore } from 'vuex';\nimport Chart from 'chart.js/auto';\nimport axios from 'axios';\nimport moment from 'moment';\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: 'http://localhost:8000/api'\n});\nexport default {\n  name: 'Dashboard',\n  setup() {\n    const store = useStore();\n    const performanceChart = ref(null);\n    const assessmentTypeChart = ref(null);\n    const performanceTrendChart = ref(null);\n    const assessmentTypePerformanceChart = ref(null);\n    const selectedYear = ref('');\n    const selectedSection = ref('');\n    const selectedStartDate = ref('');\n    const selectedEndDate = ref('');\n    const dashboardContainer = ref(null);\n    const isLoading = ref(false);\n    const lastUpdate = ref(null);\n    const autoRefreshInterval = ref(null);\n    const sections = ref([]);\n    const subjects = ref([]);\n    const availableYears = ref([]);\n    const today = computed(() => moment().format('YYYY-MM-DD'));\n\n    // Time filter state for each chart\n    const attendanceTimeFilter = ref('month'); // Default is month\n    const assessmentTypeTimeFilter = ref('month');\n    const trendTimeFilter = ref('month');\n    const typePerformanceTimeFilter = ref('month');\n\n    // Chart data cache for report generation\n    const chartDataCache = ref({\n      attendance: null,\n      assessmentType: null,\n      performanceTrend: null,\n      assessmentTypePerformance: null\n    });\n\n    // Computed properties\n    const isCITHead = computed(() => store.getters.isCITHead);\n    const token = computed(() => store.state.auth.token);\n\n    // Get user name\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'User' : 'User';\n    });\n\n    // Check if filters are active\n    const hasActiveFilters = computed(() => {\n      return Boolean(selectedYear.value || selectedSection.value);\n    });\n\n    // Set auth token for all requests\n    watch(token, newToken => {\n      if (newToken) {\n        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      }\n    }, {\n      immediate: true\n    });\n\n    // Dashboard stats\n    const totalStudents = ref(0);\n    const totalTeachers = ref(0);\n    const averageAttendance = ref(0);\n    const averageScore = ref(0);\n    const activeSections = ref(0);\n    const data = ref({\n      totalStudents: 0,\n      totalTeachers: 0,\n      activeSections: 0,\n      attendanceDistribution: [0, 0, 0],\n      assessmentTypes: [],\n      performanceTrends: [],\n      sections: [],\n      assessmentTypePerformance: {}\n    });\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      try {\n        if (!data.value || !data.value.attendanceDistribution) return false;\n\n        // Ensure all values are numbers and valid\n        const validDistribution = Array.isArray(data.value.attendanceDistribution) ? data.value.attendanceDistribution.map(val => typeof val === 'number' ? val : 0) : [0, 0, 0];\n\n        // Check if we have any non-zero values\n        const hasData = validDistribution.some(val => val > 0);\n        return hasData;\n      } catch (error) {\n        console.error('Error checking attendance data:', error);\n        return false;\n      }\n    });\n    const hasScoreData = computed(() => {\n      if (!data.value) return false;\n\n      // Check for average score\n      if (data.value.averageScore > 0) return true;\n\n      // Check assessment types for any with scores\n      if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n        return data.value.assessmentTypes.some(type => type.averageScore > 0 && type.count > 0);\n      }\n      return false;\n    });\n    const hasPerformanceData = computed(() => {\n      if (!data.value) return false;\n\n      // Check for assessment data\n      if (hasAssessmentData.value) return true;\n\n      // Check for performance trends\n      if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n        return data.value.performanceTrends.some(trend => trend.averageScore > 0);\n      }\n\n      // Check sections data\n      if (Array.isArray(data.value.sections) && data.value.sections.length > 0) {\n        return data.value.sections.some(section => section.averageScore > 0);\n      }\n      return false;\n    });\n    const hasAssessmentData = computed(() => {\n      if (!data.value) return false;\n\n      // Check for assessment types data\n      if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n        return data.value.assessmentTypes.some(type => type.count > 0 && type.averageScore > 0);\n      }\n      return false;\n    });\n    const hasSectionData = computed(() => {\n      return data.value?.sections?.length > 0;\n    });\n\n    // Fetch available years and sections directly from database records\n    const fetchAvailableFilters = async () => {\n      try {\n        isLoading.value = true;\n\n        // Get all student records to extract years and sections\n        const response = await api.get('/students', {\n          headers: {\n            'Authorization': `Bearer ${token.value}`\n          }\n        });\n        if (response.data && Array.isArray(response.data)) {\n          // Extract unique years and sections from student records\n          const students = response.data;\n\n          // Get unique years with data\n          const years = [...new Set(students.map(student => student.year))].filter(Boolean);\n          availableYears.value = years.length > 0 ? years.sort() : ['1st', '2nd', '3rd', '4th'];\n\n          // Get unique sections based on selectedYear\n          await updateSectionsForSelectedYear();\n          console.log('Fetched available filters:', {\n            years: availableYears.value,\n            sections: sections.value\n          });\n        }\n        isLoading.value = false;\n      } catch (error) {\n        console.error('Error fetching available filters:', error);\n        // Keep default years if API fails\n        availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        isLoading.value = false;\n      }\n    };\n\n    // New function to update sections based on selected year\n    const updateSectionsForSelectedYear = async () => {\n      try {\n        console.log('Updating sections for year:', selectedYear.value || 'All Years');\n        sections.value = []; // Clear existing sections first\n\n        const params = {};\n        if (selectedYear.value) {\n          params.year = selectedYear.value;\n        }\n\n        // Get students filtered by year if selected\n        const response = await api.get('/students', {\n          params,\n          headers: {\n            'Authorization': `Bearer ${token.value}`\n          }\n        });\n        if (response.data && Array.isArray(response.data)) {\n          const students = response.data;\n\n          // Get unique sections matching the selected year\n          let uniqueSections = [];\n          if (selectedYear.value) {\n            // Filter students by the selected year before extracting sections\n            uniqueSections = [...new Set(students.filter(student => student.year === selectedYear.value).map(student => student.section))].filter(Boolean);\n          } else {\n            // If no year selected, get all unique sections\n            uniqueSections = [...new Set(students.map(student => student.section))].filter(Boolean);\n          }\n          console.log(`Found ${uniqueSections.length} sections for ${selectedYear.value || 'all years'}:`, uniqueSections);\n\n          // Map sections to include teacher info if available\n          sections.value = uniqueSections.map(sectionName => ({\n            id: sectionName,\n            name: sectionName,\n            teacherName: '' // We could fetch teacher info in the future\n          }));\n        } else {\n          console.warn('No student data received when updating sections');\n          sections.value = [];\n        }\n      } catch (error) {\n        console.error('Error updating sections for year:', error);\n        sections.value = [];\n      }\n    };\n\n    // Fetch attendance data for the charts\n    const fetchAttendanceData = async () => {\n      try {\n        console.log('Fetching attendance with filters:', {\n          year: selectedYear.value || 'All Years',\n          section: selectedSection.value || 'All Sections'\n        });\n        let attendanceDistribution = [0, 0, 0]; // Default empty distribution [present, late, absent]\n\n        // First approach: Try direct approach with specific filter handling\n        try {\n          console.log('Fetching attendance directly with filters');\n\n          // Build query params differently for Windows/PowerShell URL handling\n          let url = `${api.defaults.baseURL}/attendance`;\n          let queryParts = [];\n          if (selectedYear.value) {\n            queryParts.push(`year=${encodeURIComponent(selectedYear.value)}`);\n          }\n          if (selectedSection.value) {\n            queryParts.push(`section=${encodeURIComponent(selectedSection.value)}`);\n          }\n          if (selectedStartDate.value) {\n            queryParts.push(`startDate=${encodeURIComponent(selectedStartDate.value)}`);\n          }\n          if (selectedEndDate.value) {\n            queryParts.push(`endDate=${encodeURIComponent(selectedEndDate.value)}`);\n          }\n\n          // Add query string if we have parameters\n          if (queryParts.length > 0) {\n            url += '?' + queryParts.join('&');\n          }\n          console.log('Fetching attendance from URL:', url);\n\n          // Make direct fetch request\n          const response = await fetch(url, {\n            headers: {\n              'Authorization': `Bearer ${token.value}`\n            }\n          });\n          if (response.ok) {\n            const attendanceData = await response.json();\n            console.log('Attendance data received:', Array.isArray(attendanceData) ? `${attendanceData.length} records` : 'Non-array data');\n            if (Array.isArray(attendanceData) && attendanceData.length > 0) {\n              // Process attendance records\n              const statusCounts = [0, 0, 0]; // [present, late, absent]\n\n              attendanceData.forEach(record => {\n                if (record.status === 'present') statusCounts[0]++;else if (record.status === 'late') statusCounts[1]++;else if (record.status === 'absent') statusCounts[2]++;\n              });\n              console.log('Calculated attendance counts:', statusCounts);\n\n              // Only use this data if we have at least one attendance record\n              if (statusCounts.some(count => count > 0)) {\n                attendanceDistribution = statusCounts;\n                return attendanceDistribution;\n              }\n            }\n          } else {\n            console.warn(`Attendance API returned status: ${response.status}`);\n          }\n        } catch (error) {\n          console.log('Error fetching attendance directly:', error.message);\n        }\n\n        // Second approach: Try fetching from dashboard stats\n        try {\n          console.log('Trying to get attendance from dashboard stats');\n\n          // Build URL for stats\n          let url = `${api.defaults.baseURL}/dashboard/stats`;\n          let queryParts = [];\n          if (selectedYear.value) {\n            queryParts.push(`year=${encodeURIComponent(selectedYear.value)}`);\n          }\n          if (selectedSection.value) {\n            queryParts.push(`section=${encodeURIComponent(selectedSection.value)}`);\n          }\n          if (queryParts.length > 0) {\n            url += '?' + queryParts.join('&');\n          }\n          console.log('Fetching dashboard stats from URL:', url);\n          const response = await fetch(url, {\n            headers: {\n              'Authorization': `Bearer ${token.value}`\n            }\n          });\n          if (response.ok) {\n            const statsData = await response.json();\n            if (statsData && Array.isArray(statsData.attendanceDistribution)) {\n              console.log('Attendance distribution from stats:', statsData.attendanceDistribution);\n\n              // Validate attendance distribution data\n              const validDistribution = statsData.attendanceDistribution.map(val => typeof val === 'number' ? val : 0);\n\n              // Only use if we have some valid data\n              if (validDistribution.some(val => val > 0)) {\n                attendanceDistribution = validDistribution;\n                return attendanceDistribution;\n              }\n            }\n          }\n        } catch (error) {\n          console.log('Error fetching from dashboard stats:', error.message);\n        }\n\n        // Third approach: Try to get attendance by date\n        try {\n          console.log('Trying to get attendance by date for recent days');\n          const today = new Date();\n          const lastWeek = new Array(7).fill(0).map((_, i) => {\n            const date = new Date(today);\n            date.setDate(date.getDate() - i);\n            return date.toISOString().split('T')[0]; // Format as YYYY-MM-DD\n          });\n          let allAttendanceRecords = [];\n\n          // Get attendance for recent dates\n          for (const date of lastWeek) {\n            try {\n              let url = `${api.defaults.baseURL}/attendance/date/${date}`;\n              if (selectedYear.value) {\n                url += `?year=${encodeURIComponent(selectedYear.value)}`;\n                if (selectedSection.value) {\n                  url += `&section=${encodeURIComponent(selectedSection.value)}`;\n                }\n              }\n              const response = await fetch(url, {\n                headers: {\n                  'Authorization': `Bearer ${token.value}`\n                }\n              });\n              if (response.ok) {\n                const dateAttendance = await response.json();\n                if (Array.isArray(dateAttendance)) {\n                  allAttendanceRecords = [...allAttendanceRecords, ...dateAttendance];\n                }\n              }\n            } catch (error) {\n              // Silently continue to next date\n            }\n          }\n          console.log(`Collected ${allAttendanceRecords.length} attendance records from recent dates`);\n          if (allAttendanceRecords.length > 0) {\n            // Process all attendance records\n            const statusCounts = [0, 0, 0]; // [present, late, absent]\n\n            allAttendanceRecords.forEach(record => {\n              if (record.status === 'present') statusCounts[0]++;else if (record.status === 'late') statusCounts[1]++;else if (record.status === 'absent') statusCounts[2]++;\n            });\n            console.log('Calculated attendance counts from dates:', statusCounts);\n            if (statusCounts.some(count => count > 0)) {\n              attendanceDistribution = statusCounts;\n              return attendanceDistribution;\n            }\n          }\n        } catch (error) {\n          console.log('Error fetching attendance by date:', error.message);\n        }\n\n        // Return empty distribution if all approaches failed\n        console.log('All attendance data fetching approaches failed. Using empty distribution.');\n        return attendanceDistribution;\n      } catch (error) {\n        console.error('Error in attendance data fetching:', error);\n        return [0, 0, 0];\n      }\n    };\n    const fetchDashboardData = async () => {\n      try {\n        isLoading.value = true;\n\n        // Prepare query parameters using the URL-friendly format\n        let queryParts = [];\n        if (selectedYear.value) {\n          queryParts.push(`year=${encodeURIComponent(selectedYear.value)}`);\n        }\n        if (selectedSection.value) {\n          queryParts.push(`section=${encodeURIComponent(selectedSection.value)}`);\n        }\n        if (selectedStartDate.value) {\n          queryParts.push(`startDate=${encodeURIComponent(selectedStartDate.value)}`);\n        }\n        if (selectedEndDate.value) {\n          queryParts.push(`endDate=${encodeURIComponent(selectedEndDate.value)}`);\n        }\n        const filterParams = queryParts.length > 0 ? '?' + queryParts.join('&') : '';\n        console.log('Fetching dashboard data with params:', filterParams || 'none');\n\n        // First, fetch attendance data\n        const attendanceDistribution = await fetchAttendanceData();\n        console.log('Attendance distribution for current filters:', attendanceDistribution);\n\n        // Get dashboard stats\n        const statsUrl = `${api.defaults.baseURL}/dashboard/stats${filterParams}`;\n        console.log('Fetching dashboard stats from URL:', statsUrl);\n        let statsData = {};\n        try {\n          const response = await fetch(statsUrl, {\n            headers: {\n              'Authorization': `Bearer ${token.value}`\n            }\n          });\n          if (response.ok) {\n            statsData = await response.json();\n            console.log('Dashboard stats response:', statsData);\n          } else {\n            console.warn(`Dashboard stats API returned status: ${response.status}`);\n          }\n        } catch (error) {\n          console.error('Error fetching dashboard stats:', error.message);\n        }\n\n        // Initialize data value with defaults and merge with stats data\n        data.value = {\n          totalStudents: statsData.totalStudents || 0,\n          totalTeachers: statsData.totalTeachers || 0,\n          activeSections: statsData.activeSections || 0,\n          attendanceDistribution: attendanceDistribution || [0, 0, 0],\n          assessmentTypes: [],\n          performanceTrends: [],\n          sections: []\n        };\n\n        // Check if we received any meaningful data\n        const hasValidData = data.value.totalStudents > 0 || data.value.totalTeachers > 0 || data.value.activeSections > 0 || attendanceDistribution && attendanceDistribution.some(val => val > 0);\n\n        // If no valid data, it means the filter combination doesn't match any records\n        if (!hasValidData && (selectedYear.value || selectedSection.value)) {\n          console.warn('No data found for the selected filters');\n        }\n\n        // Update basic stats\n        totalStudents.value = data.value.totalStudents;\n        totalTeachers.value = data.value.totalTeachers;\n        activeSections.value = data.value.activeSections;\n\n        // Calculate average attendance from distribution\n        const totalAttendance = attendanceDistribution.reduce((a, b) => a + b, 0);\n        if (totalAttendance > 0) {\n          // Calculate percentage of present and late (not absent)\n          const presentAttendance = attendanceDistribution[0] + attendanceDistribution[1];\n          averageAttendance.value = Math.round(presentAttendance / totalAttendance * 100);\n        } else {\n          averageAttendance.value = 0;\n        }\n\n        // Process assessment data for charts\n        await fetchAssessmentData();\n\n        // Calculate averageScore from assessment data\n        if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n          let totalScore = 0;\n          let totalCount = 0;\n          data.value.assessmentTypes.forEach(type => {\n            if (type.averageScore > 0 && type.count > 0) {\n              totalScore += type.averageScore * type.count;\n              totalCount += type.count;\n            }\n          });\n          if (totalCount > 0) {\n            averageScore.value = Math.round(totalScore / totalCount);\n            data.value.averageScore = averageScore.value;\n          } else {\n            averageScore.value = 0;\n            data.value.averageScore = 0;\n          }\n          console.log(`Calculated average score: ${averageScore.value}% from ${totalCount} assessments`);\n        } else {\n          averageScore.value = 0;\n          data.value.averageScore = 0;\n        }\n\n        // Update charts with new data\n        updateCharts(data.value);\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Failed to fetch dashboard data:', error);\n\n        // Initialize with empty data if main stats request fails\n        data.value = {\n          totalStudents: 0,\n          totalTeachers: 0,\n          activeSections: 0,\n          attendanceDistribution: [0, 0, 0],\n          averageAttendance: 0,\n          assessmentTypes: [],\n          performanceTrends: [],\n          averageScore: 0,\n          sections: []\n        };\n        totalStudents.value = 0;\n        totalTeachers.value = 0;\n        activeSections.value = 0;\n        averageAttendance.value = 0;\n        averageScore.value = 0;\n\n        // Update charts with empty data\n        updateCharts(data.value);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    // Fetch assessment data directly with better approach\n    const fetchAssessmentData = async () => {\n      try {\n        console.log('Fetching assessment data for filters:', {\n          year: selectedYear.value || 'All',\n          section: selectedSection.value || 'All',\n          startDate: selectedStartDate.value,\n          endDate: selectedEndDate.value\n        });\n\n        // Test directly with fetch to avoid axios URL encoding issues on Windows\n        const params = new URLSearchParams();\n\n        // Add params only if they exist\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedStartDate.value) params.append('startDate', selectedStartDate.value);\n        if (selectedEndDate.value) params.append('endDate', selectedEndDate.value);\n\n        // Build the URL with query string\n        const queryString = params.toString();\n        const url = `${api.defaults.baseURL}/assessments${queryString ? '?' + queryString : ''}`;\n        console.log('Fetching assessments from URL:', url);\n\n        // Make the direct fetch request\n        const response = await fetch(url, {\n          headers: {\n            'Authorization': `Bearer ${token.value}`\n          }\n        });\n        let assessments = [];\n        if (response.ok) {\n          assessments = await response.json();\n          console.log('Fetched assessments count:', assessments?.length || 0);\n        } else {\n          console.error('Assessments API failed with status:', response.status);\n          throw new Error(`API error: ${response.status}`);\n        }\n        if (Array.isArray(assessments) && assessments.length > 0) {\n          console.log('Successfully fetched assessment data');\n\n          // Process the assessment data\n          const assessmentTypes = {\n            'Quiz': {\n              count: 0,\n              totalScore: 0,\n              scores: []\n            },\n            'Activity': {\n              count: 0,\n              totalScore: 0,\n              scores: []\n            },\n            'Performance Task': {\n              count: 0,\n              totalScore: 0,\n              scores: []\n            }\n          };\n\n          // Log sample assessment data to understand structure\n          console.log('Sample assessment data:', assessments.slice(0, 1));\n\n          // Process each assessment\n          assessments.forEach(assessment => {\n            // Make sure we have a type - default to \"Other\" if none found\n            const type = assessment.type || assessment.assessmentType || assessment.assessment_type || 'Other';\n\n            // Initialize type if it doesn't exist\n            if (!assessmentTypes[type]) {\n              assessmentTypes[type] = {\n                count: 0,\n                totalScore: 0,\n                scores: []\n              };\n            }\n\n            // Increment count for this type\n            assessmentTypes[type].count++;\n\n            // Process scores if available\n            if (assessment.scores) {\n              // Handle both array and Map formats\n              let scoreArray = [];\n              if (Array.isArray(assessment.scores)) {\n                scoreArray = assessment.scores;\n              } else if (assessment.scores instanceof Map) {\n                scoreArray = Array.from(assessment.scores.values());\n              } else if (typeof assessment.scores === 'object') {\n                // Handle object format\n                scoreArray = Object.values(assessment.scores);\n              }\n\n              // Filter for valid scores and calculate percentages\n              const validScores = scoreArray.filter(score => typeof score === 'number');\n              validScores.forEach(score => {\n                const percentage = assessment.maxScore ? score / assessment.maxScore * 100 : score;\n                assessmentTypes[type].totalScore += percentage;\n                assessmentTypes[type].scores.push(percentage);\n              });\n            }\n          });\n\n          // Calculate averages and prepare for chart\n          data.value.assessmentTypes = Object.keys(assessmentTypes).filter(type => assessmentTypes[type].count > 0) // Only include types with data\n          .map(type => {\n            const typeData = assessmentTypes[type];\n            const averageScore = typeData.scores.length > 0 ? typeData.totalScore / typeData.scores.length : 0;\n            return {\n              type,\n              averageScore: Math.round(averageScore),\n              count: typeData.count,\n              completionRate: typeData.count > 0 ? 100 : 0\n            };\n          });\n          console.log(`Assessment types processed:`, data.value.assessmentTypes.map(t => `${t.type}: ${t.count} assessments, avg ${t.averageScore}%`));\n\n          // Generate performance trends from assessment data\n          data.value.performanceTrends = assessments.filter(a => a.date || a.assessmentDate || a.assessment_date) // Only include assessments with dates\n          .map(assessment => {\n            // Get the date - check various possible field names\n            const date = assessment.date || assessment.assessmentDate || assessment.assessment_date;\n\n            // Calculate average score for this assessment\n            let averageScore = 0;\n            let scoreArray = [];\n\n            // Handle different score formats\n            if (assessment.scores) {\n              if (Array.isArray(assessment.scores)) {\n                scoreArray = assessment.scores;\n              } else if (assessment.scores instanceof Map) {\n                scoreArray = Array.from(assessment.scores.values());\n              } else if (typeof assessment.scores === 'object') {\n                scoreArray = Object.values(assessment.scores);\n              }\n\n              // Calculate average from valid scores\n              const validScores = scoreArray.filter(score => typeof score === 'number');\n              if (validScores.length > 0) {\n                const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                averageScore = assessment.maxScore ? totalScore / validScores.length / assessment.maxScore * 100 : totalScore / validScores.length;\n              }\n            }\n            return {\n              date: date,\n              title: assessment.name || assessment.title || assessment.type || 'Assessment',\n              averageScore: Math.round(averageScore),\n              type: assessment.type || assessment.assessmentType || 'Assessment'\n            };\n          }).filter(trend => trend.date && trend.averageScore > 0) // Only keep trends with dates and scores\n          .sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date\n\n          console.log(`Performance trends processed: ${data.value.performanceTrends.length} data points with dates and scores`);\n\n          // Process section data if available\n          // Group assessments by section\n          const sectionPerformance = {};\n\n          // Only process section performance if we actually have data\n          if (assessments.length > 0) {\n            assessments.forEach(assessment => {\n              const section = assessment.section || assessment.sectionName || '';\n              if (section) {\n                if (!sectionPerformance[section]) {\n                  sectionPerformance[section] = {\n                    totalScore: 0,\n                    scoreCount: 0,\n                    assessmentCount: 0\n                  };\n                }\n                sectionPerformance[section].assessmentCount++;\n\n                // Process scores\n                let scoreArray = [];\n                if (assessment.scores) {\n                  if (Array.isArray(assessment.scores)) {\n                    scoreArray = assessment.scores;\n                  } else if (assessment.scores instanceof Map) {\n                    scoreArray = Array.from(assessment.scores.values());\n                  } else if (typeof assessment.scores === 'object') {\n                    scoreArray = Object.values(assessment.scores);\n                  }\n\n                  // Process valid scores\n                  const validScores = scoreArray.filter(score => typeof score === 'number');\n                  validScores.forEach(score => {\n                    const percentage = assessment.maxScore ? score / assessment.maxScore * 100 : score;\n                    sectionPerformance[section].totalScore += percentage;\n                    sectionPerformance[section].scoreCount++;\n                  });\n                }\n              }\n            });\n\n            // Prepare section data for chart if we have any\n            if (Object.keys(sectionPerformance).length > 0) {\n              data.value.sections = Object.keys(sectionPerformance).filter(sectionName => sectionPerformance[sectionName].scoreCount > 0) // Only include sections with scores\n              .map(sectionName => {\n                const section = sectionPerformance[sectionName];\n                const averageScore = section.scoreCount > 0 ? section.totalScore / section.scoreCount : 0;\n                return {\n                  name: sectionName,\n                  averageScore: Math.round(averageScore),\n                  attendanceRate: 0,\n                  // We don't have this data\n                  performance: Math.round(averageScore),\n                  // For backward compatibility\n                  assessmentCount: section.assessmentCount\n                };\n              });\n              console.log(`Section data processed: ${data.value.sections.length} sections with performance data`);\n            }\n          }\n        } else {\n          console.warn('No assessment data found for the selected filters');\n          // Set default values\n          data.value.assessmentTypes = [{\n            type: 'Quiz',\n            averageScore: 0,\n            count: 0\n          }, {\n            type: 'Activity',\n            averageScore: 0,\n            count: 0\n          }, {\n            type: 'Performance Task',\n            averageScore: 0,\n            count: 0\n          }];\n          data.value.performanceTrends = [];\n          data.value.sections = [];\n        }\n      } catch (error) {\n        console.error('Error fetching assessment data:', error);\n        // Set default values\n        data.value.assessmentTypes = [{\n          type: 'Quiz',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Activity',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Performance Task',\n          averageScore: 0,\n          count: 0\n        }];\n        data.value.performanceTrends = [];\n        data.value.sections = [];\n      }\n    };\n    const updateCharts = data => {\n      updatePerformanceChart(data);\n      updateAssessmentTypeChart(data);\n      updatePerformanceTrendChart(data);\n      updateAssessmentTypePerformanceChart(data);\n    };\n\n    // Update initEmptyCharts to properly handle chart destruction\n    const initEmptyCharts = () => {\n      // First destroy any existing charts to prevent \"Canvas is already in use\" errors\n      const charts = [performanceChart.value, assessmentTypeChart.value, performanceTrendChart.value, assessmentTypePerformanceChart.value];\n\n      // Destroy all existing charts first\n      charts.forEach(canvas => {\n        if (canvas) {\n          const ctx = canvas.getContext('2d');\n          if (ctx) {\n            const existingChart = Chart.getChart(ctx);\n            if (existingChart) {\n              existingChart.destroy();\n            }\n          }\n        }\n      });\n\n      // Create empty data structure\n      const emptyData = {\n        totalStudents: 0,\n        totalTeachers: 0,\n        activeSections: 0,\n        averageAttendance: 0,\n        averageScore: 0,\n        attendanceDistribution: [0, 0, 0],\n        assessmentTypes: [{\n          type: 'Quiz',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Activity',\n          averageScore: 0,\n          count: 0\n        }, {\n          type: 'Performance Task',\n          averageScore: 0,\n          count: 0\n        }],\n        performanceTrends: [],\n        sections: []\n      };\n\n      // Update charts with empty data\n      updateCharts(emptyData);\n    };\n\n    // Format date for display\n    const formatDate = date => {\n      if (!date) return '';\n      return moment(date).format('MMMM D, YYYY h:mm A');\n    };\n\n    // Handle year change\n    const handleYearChange = async () => {\n      console.log('Year changed to:', selectedYear.value);\n\n      // Reset the section when year changes\n      selectedSection.value = '';\n\n      // Update sections based on the new year\n      await updateSectionsForSelectedYear();\n\n      // Update dashboard data with new filters\n      await fetchDashboardData();\n    };\n\n    // Handle section change\n    const handleSectionChange = async () => {\n      // Update dashboard data with new filters\n      fetchDashboardData();\n    };\n\n    // Handle filter change\n    const handleFilterChange = () => {\n      fetchDashboardData();\n    };\n\n    // Clear all filters\n    const clearFilters = () => {\n      console.log('Clearing all filters');\n\n      // Reset all filter values\n      selectedYear.value = '';\n      selectedSection.value = '';\n      selectedStartDate.value = '';\n      selectedEndDate.value = '';\n\n      // Reset sections \n      sections.value = [];\n\n      // Refresh the dashboard with no filters\n      fetchAvailableFilters().then(() => {\n        console.log('Available filters refreshed, fetching dashboard data');\n        fetchDashboardData();\n      });\n    };\n\n    // Get filter display text\n    const getFilterDisplay = () => {\n      const filters = [];\n      if (selectedYear.value) filters.push(selectedYear.value);\n      if (selectedSection.value) filters.push(selectedSection.value);\n\n      // Add date range to display if selected\n      if (selectedStartDate.value && selectedEndDate.value) {\n        const formattedStart = moment(selectedStartDate.value).format('MMM D');\n        const formattedEnd = moment(selectedEndDate.value).format('MMM D, YYYY');\n        filters.push(`${formattedStart} - ${formattedEnd}`);\n      } else if (selectedStartDate.value) {\n        filters.push(`From ${moment(selectedStartDate.value).format('MMM D, YYYY')}`);\n      } else if (selectedEndDate.value) {\n        filters.push(`Until ${moment(selectedEndDate.value).format('MMM D, YYYY')}`);\n      }\n      return filters.length > 0 ? filters.join(' - ') : 'Filter View';\n    };\n\n    // Update charts with data\n    const updatePerformanceChart = data => {\n      if (!performanceChart.value) return;\n      const ctx = performanceChart.value.getContext('2d');\n      if (!ctx) return;\n\n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Attendance status distribution data\n      const attendanceLabels = ['Present', 'Late', 'Absent'];\n      let attendanceData = data.attendanceDistribution || [0, 0, 0];\n\n      // Log attendance data for debugging\n      console.log('Raw attendance data:', attendanceData);\n\n      // Ensure each value is a number\n      attendanceData = attendanceData.map(val => typeof val === 'number' ? val : 0);\n\n      // Ensure we have at least some data to display\n      const totalAttendanceCount = attendanceData.reduce((a, b) => a + b, 0);\n\n      // Check if we have valid data to show\n      const hasValidData = totalAttendanceCount > 0;\n\n      // Log for debugging\n      console.log('Final attendance distribution data:', attendanceData, 'hasValidData:', hasValidData);\n\n      // Create chart\n      if (hasValidData) {\n        new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: attendanceLabels,\n            datasets: [{\n              data: attendanceData,\n              backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],\n              borderWidth: 0,\n              hoverOffset: 4\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            cutout: '70%',\n            plugins: {\n              legend: {\n                position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                  padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function (context) {\n                    const label = context.label || '';\n                    const value = context.raw || 0;\n                    const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);\n                    const percentage = total > 0 ? Math.round(value / total * 100) : 0;\n                    return `${label}: ${value} (${percentage}%)`;\n                  }\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart with \"No data available\" message\n        new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: ['No Data'],\n            datasets: [{\n              data: [1],\n              backgroundColor: ['#e2e8f0'],\n              borderWidth: 0\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            cutout: '70%',\n            plugins: {\n              legend: {\n                display: false\n              },\n              tooltip: {\n                enabled: false\n              }\n            }\n          }\n        });\n      }\n    };\n    const updateAssessmentTypeChart = data => {\n      if (!assessmentTypeChart.value) return;\n      const ctx = assessmentTypeChart.value.getContext('2d');\n      if (!ctx) return;\n\n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Assessment types data\n      const assessmentData = data.assessmentTypes || [];\n      const labels = [];\n      const values = [];\n      const counts = [];\n      const colors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#6366f1'];\n      try {\n        // Extract assessment types data\n        if (Array.isArray(assessmentData) && assessmentData.length > 0) {\n          // If array format\n          assessmentData.forEach((item, index) => {\n            if (item && typeof item === 'object') {\n              // Only include items with a count > 0\n              if (item.count > 0) {\n                labels.push(item.type || `Type ${index + 1}`);\n                values.push(parseFloat(item.averageScore) || 0);\n                counts.push(item.count || 0);\n              }\n            }\n          });\n        } else if (typeof assessmentData === 'object' && assessmentData !== null) {\n          // If object format\n          Object.entries(assessmentData).forEach(([type, data], index) => {\n            if (data.count > 0) {\n              labels.push(type);\n              values.push(parseFloat(data.averageScore) || 0);\n              counts.push(data.count || 0);\n            }\n          });\n        }\n        console.log(`Assessment type chart data: ${labels.length} types with data`);\n        console.log('Assessment types:', labels);\n        console.log('Average scores:', values);\n        console.log('Assessment counts:', counts);\n\n        // If no data was extracted, use default types\n        if (labels.length === 0) {\n          labels.push('Quiz', 'Activity', 'Performance Task');\n          values.push(0, 0, 0);\n          counts.push(0, 0, 0);\n        }\n      } catch (error) {\n        console.error('Error processing assessment data:', error);\n        // Fallback to default labels and values\n        labels.push('Quiz', 'Activity', 'Performance Task');\n        values.push(0, 0, 0);\n        counts.push(0, 0, 0);\n      }\n\n      // Check if we have any valid data\n      const hasData = labels.length > 0 && values.some(v => v > 0);\n\n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: labels,\n          datasets: [{\n            label: 'Average Score (%)',\n            data: values,\n            backgroundColor: colors.slice(0, labels.length),\n            borderWidth: 0,\n            borderRadius: 6,\n            maxBarThickness: 50\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: function (context) {\n                  const type = labels[context.dataIndex];\n                  const count = counts[context.dataIndex];\n                  return `${type}: ${context.raw}% (${count} assessments)`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              ticks: {\n                callback: function (value) {\n                  return value + '%';\n                }\n              }\n            }\n          }\n        }\n      });\n    };\n    const updatePerformanceTrendChart = data => {\n      if (!performanceTrendChart.value) return;\n      const ctx = performanceTrendChart.value.getContext('2d');\n      if (!ctx) return;\n\n      // Properly destroy any existing chart\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      let trends = [];\n      if (data.performanceTrends && Array.isArray(data.performanceTrends)) {\n        // Filter out trends that have no valid score or date\n        trends = data.performanceTrends.filter(trend => trend.date && (typeof trend.averageScore === 'number' || typeof trend.score === 'number')).map(trend => ({\n          date: new Date(trend.date),\n          value: parseFloat(trend.averageScore || trend.score) || 0,\n          name: trend.title || trend.name || 'Assessment'\n        })).sort((a, b) => a.date - b.date);\n      }\n      console.log(`Performance trend chart data: ${trends.length} valid data points`);\n\n      // Check if we have any valid data points\n      const hasData = trends.length > 0 && trends.some(t => t.value > 0);\n      if (hasData) {\n        // Create new chart after destroying the old one\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: trends.map(trend => moment(trend.date).format('MMM D, YYYY')),\n            datasets: [{\n              label: 'Average Score',\n              data: trends.map(trend => trend.value),\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2,\n              tension: 0.4,\n              fill: true,\n              pointRadius: 4,\n              pointBackgroundColor: 'rgb(59, 130, 246)',\n              pointHoverRadius: 6\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  title: tooltipItems => {\n                    if (!tooltipItems.length || !trends[tooltipItems[0].dataIndex]) return '';\n                    const trend = trends[tooltipItems[0].dataIndex];\n                    return `${moment(trend.date).format('MMM D, YYYY')} - ${trend.name}`;\n                  },\n                  label: context => {\n                    return `Score: ${context.raw.toFixed(1)}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart to show the \"No data available\" message\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'Average Score',\n              data: [],\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n    const updateAssessmentTypePerformanceChart = data => {\n      if (!assessmentTypePerformanceChart.value) return;\n      const ctx = assessmentTypePerformanceChart.value.getContext('2d');\n      if (!ctx) return;\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process the performance trends data by assessment type\n      const trendsByType = {\n        Quiz: [],\n        Activity: [],\n        'Performance Task': []\n      };\n\n      // Process performance trends data\n      let hasValidData = false;\n      if (Array.isArray(data.performanceTrends)) {\n        data.performanceTrends.forEach(trend => {\n          // Only process trends with valid scores and dates\n          if (trend.date && (typeof trend.averageScore === 'number' || typeof trend.score === 'number')) {\n            const type = trend.type || trend.title || 'Other';\n            const score = parseFloat(trend.averageScore || trend.score) || 0;\n\n            // Create the array for this type if it doesn't exist\n            if (!trendsByType[type]) {\n              trendsByType[type] = [];\n            }\n            trendsByType[type].push({\n              date: new Date(trend.date),\n              score: score\n            });\n            if (score > 0) {\n              hasValidData = true;\n            }\n          }\n        });\n      }\n\n      // Sort data points by date for each type\n      Object.keys(trendsByType).forEach(type => {\n        trendsByType[type].sort((a, b) => a.date - b.date);\n      });\n\n      // Get unique dates across all types\n      const allDates = [...new Set(Object.values(trendsByType).flat().map(item => item.date))].sort((a, b) => a - b);\n\n      // Only proceed if we have valid dates\n      if (allDates.length > 0 && hasValidData) {\n        console.log(`Assessment type performance chart: ${allDates.length} dates with data`);\n\n        // Create datasets\n        const datasets = Object.entries(trendsByType).filter(([_, data]) => data.length > 0) // Only include types with data\n        .map(([type, data], index) => {\n          const colors = ['rgb(52, 211, 153)',\n          // Green for Quiz\n          'rgb(59, 130, 246)',\n          // Blue for Activity\n          'rgb(251, 191, 36)' // Yellow for Performance Task\n          ];\n          const color = colors[index % colors.length];\n          return {\n            label: type,\n            data: allDates.map(date => {\n              const point = data.find(d => d.date.getTime() === date.getTime());\n              return point ? point.score : null;\n            }),\n            borderColor: color,\n            backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),\n            fill: true,\n            tension: 0.4,\n            pointRadius: 4,\n            pointHoverRadius: 6,\n            spanGaps: true // This will connect points even if there are null values\n          };\n        });\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: allDates.map(date => moment(date).format('MMM D, YYYY')),\n            datasets\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            interaction: {\n              intersect: false,\n              mode: 'index'\n            },\n            plugins: {\n              legend: {\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  label: context => {\n                    const value = context.raw !== null ? context.raw.toFixed(1) : 'N/A';\n                    return `${context.dataset.label}: ${value}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart if no valid data\n        console.log('No valid assessment type performance data, showing empty chart');\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'No Data',\n              data: [],\n              borderColor: 'rgb(203, 213, 225)',\n              backgroundColor: 'rgba(203, 213, 225, 0.1)'\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    // Update the refreshDashboard function to properly handle chart destruction\n    const refreshDashboard = async () => {\n      try {\n        isLoading.value = true;\n\n        // Destroy existing charts before fetching new data\n        initEmptyCharts();\n\n        // Wait a tick to ensure DOM updates\n        await nextTick();\n\n        // Fetch new data\n        await fetchDashboardData();\n\n        // Update the last refresh time\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Error refreshing dashboard:', error);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    const scrollToSection = sectionId => {\n      const section = document.getElementById(sectionId);\n      if (section) {\n        section.scrollIntoView({\n          behavior: 'smooth'\n        });\n      }\n    };\n\n    // Restore auto-refresh in onMounted function\n    onMounted(async () => {\n      try {\n        // Make sure DOM is rendered before initializing charts\n        await nextTick();\n        console.log('Dashboard mounted, initializing');\n\n        // Initialize with empty data while waiting for API\n        initEmptyCharts();\n\n        // Set up API interceptor to handle 404 errors gracefully\n        api.interceptors.response.use(response => response, error => {\n          if (error.response && error.response.status === 404) {\n            console.warn(`API endpoint not found: ${error.config.url}`);\n          }\n          return Promise.reject(error);\n        });\n\n        // Set auth token for API requests\n        if (store.state.auth.token) {\n          api.defaults.headers.common['Authorization'] = `Bearer ${store.state.auth.token}`;\n        }\n\n        // Fetch available years and sections with data\n        await fetchAvailableFilters();\n\n        // Ensure all available years are set properly\n        if (availableYears.value.length === 0) {\n          availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        }\n\n        // Fetch dashboard data\n        await fetchDashboardData();\n\n        // Set up auto-refresh\n        if (autoRefreshInterval.value) {\n          clearInterval(autoRefreshInterval.value);\n        }\n\n        // Refresh every 5 minutes, but only if tab is visible\n        autoRefreshInterval.value = setInterval(() => {\n          if (document.visibilityState === 'visible') {\n            refreshDashboard();\n          }\n        }, 5 * 60 * 1000); // 5 minutes\n      } catch (error) {\n        console.error('Error initializing dashboard:', error);\n        // Make sure we still have empty charts if data loading fails\n        await nextTick();\n        initEmptyCharts();\n      }\n    });\n\n    // Clean up on component unmount\n    onUnmounted(() => {\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n    });\n\n    // Add watch for date changes\n    watch([selectedStartDate, selectedEndDate], () => {\n      if (selectedStartDate.value && selectedEndDate.value) {\n        // Validate date range\n        const start = moment(selectedStartDate.value);\n        const end = moment(selectedEndDate.value);\n        if (end.isBefore(start)) {\n          selectedEndDate.value = selectedStartDate.value;\n        }\n      }\n    });\n\n    // New function to set time filter for a specific chart and refresh its data\n    const setChartTimeFilter = async (chartType, timeRange) => {\n      console.log(`Setting ${chartType} chart time filter to ${timeRange}`);\n\n      // Update the time filter for the specified chart\n      switch (chartType) {\n        case 'attendance':\n          attendanceTimeFilter.value = timeRange;\n          break;\n        case 'assessmentType':\n          assessmentTypeTimeFilter.value = timeRange;\n          break;\n        case 'trend':\n          trendTimeFilter.value = timeRange;\n          break;\n        case 'typePerformance':\n          typePerformanceTimeFilter.value = timeRange;\n          break;\n      }\n\n      // Set date range based on the selected time filter\n      const today = new Date();\n      let startDate = new Date();\n      if (timeRange === 'day') {\n        // Just today\n        startDate = today;\n      } else if (timeRange === 'week') {\n        // Last 7 days\n        startDate.setDate(today.getDate() - 7);\n      } else if (timeRange === 'month') {\n        // Last 30 days\n        startDate.setDate(today.getDate() - 30);\n      }\n\n      // Format dates for API calls\n      const formattedStartDate = moment(startDate).format('YYYY-MM-DD');\n      const formattedEndDate = moment(today).format('YYYY-MM-DD');\n      console.log(`Date range: ${formattedStartDate} to ${formattedEndDate}`);\n\n      // Store original date filter values\n      const originalStartDate = selectedStartDate.value;\n      const originalEndDate = selectedEndDate.value;\n\n      // Set new date filter values temporarily for this chart update\n      selectedStartDate.value = formattedStartDate;\n      selectedEndDate.value = formattedEndDate;\n\n      // Show loading indicator for the specific chart\n      isLoading.value = true;\n      try {\n        // Fetch data based on chart type\n        if (chartType === 'attendance') {\n          const attendanceData = await fetchAttendanceData();\n          data.value.attendanceDistribution = attendanceData;\n\n          // Update attendance chart\n          updatePerformanceChart(data.value);\n\n          // Cache data for report generation\n          chartDataCache.value.attendance = {\n            timeRange,\n            data: attendanceData,\n            labels: ['Present', 'Late', 'Absent'],\n            startDate: formattedStartDate,\n            endDate: formattedEndDate\n          };\n        } else if (chartType === 'assessmentType' || chartType === 'trend' || chartType === 'typePerformance') {\n          // Fetch updated assessment data\n          await fetchAssessmentData();\n\n          // Cache assessment type data\n          if (chartType === 'assessmentType') {\n            chartDataCache.value.assessmentType = {\n              timeRange,\n              data: data.value.assessmentTypes,\n              startDate: formattedStartDate,\n              endDate: formattedEndDate\n            };\n            updateAssessmentTypeChart(data.value);\n          }\n\n          // Cache performance trend data\n          if (chartType === 'trend') {\n            chartDataCache.value.performanceTrend = {\n              timeRange,\n              data: data.value.performanceTrends,\n              startDate: formattedStartDate,\n              endDate: formattedEndDate\n            };\n            updatePerformanceTrendChart(data.value);\n          }\n\n          // Cache assessment type performance data\n          if (chartType === 'typePerformance') {\n            chartDataCache.value.assessmentTypePerformance = {\n              timeRange,\n              data: data.value.performanceTrends,\n              startDate: formattedStartDate,\n              endDate: formattedEndDate\n            };\n            updateAssessmentTypePerformanceChart(data.value);\n          }\n        }\n      } catch (error) {\n        console.error(`Error updating ${chartType} chart with ${timeRange} filter:`, error);\n      } finally {\n        // Restore original date filter values\n        selectedStartDate.value = originalStartDate;\n        selectedEndDate.value = originalEndDate;\n        isLoading.value = false;\n      }\n    };\n\n    // Function to generate and export chart data\n    const generateChartData = async chartType => {\n      console.log(`Generating report for ${chartType} chart`);\n\n      // Get the appropriate time filter for the chart\n      let timeRange = 'month';\n      switch (chartType) {\n        case 'attendance':\n          timeRange = attendanceTimeFilter.value;\n          break;\n        case 'assessmentType':\n          timeRange = assessmentTypeTimeFilter.value;\n          break;\n        case 'performanceTrend':\n          timeRange = trendTimeFilter.value;\n          break;\n        case 'assessmentTypePerformance':\n          timeRange = typePerformanceTimeFilter.value;\n          break;\n      }\n\n      // Get the chart data from cache\n      const chartData = chartDataCache.value[chartType];\n      if (!chartData) {\n        console.warn(`No cached data available for ${chartType} chart`);\n        alert('No data available to generate report. Please try refreshing the chart first.');\n        return;\n      }\n      try {\n        isLoading.value = true;\n\n        // Prepare report data\n        const reportData = {\n          chartType,\n          timeRange,\n          startDate: chartData.startDate,\n          endDate: chartData.endDate,\n          data: chartData.data,\n          filters: {\n            year: selectedYear.value || 'All',\n            section: selectedSection.value || 'All'\n          }\n        };\n\n        // Call backend API to generate report\n        const response = await api.post('/reports/generate', reportData, {\n          responseType: 'blob' // Important for downloading files\n        });\n\n        // Check if the response is successful\n        if (response.status === 200) {\n          // Create blob URL and trigger download\n          const blob = new Blob([response.data], {\n            type: response.headers['content-type']\n          });\n          const url = window.URL.createObjectURL(blob);\n          const link = document.createElement('a');\n\n          // Determine file extension based on content type\n          const contentType = response.headers['content-type'];\n          const fileExt = contentType.includes('excel') ? 'xlsx' : 'pdf';\n\n          // Generate filename\n          const fileName = `${chartType}_report_${timeRange}_${moment().format('YYYY-MM-DD')}.${fileExt}`;\n          link.href = url;\n          link.setAttribute('download', fileName);\n          document.body.appendChild(link);\n          link.click();\n          link.remove();\n          console.log(`Report successfully generated: ${fileName}`);\n        } else {\n          console.error('Error generating report:', response);\n          alert('Failed to generate report. Please try again.');\n        }\n      } catch (error) {\n        console.error('Error generating report:', error);\n        alert('Failed to generate report. Please try again.');\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    // Function aliases for compatibility\n    const onYearChange = handleYearChange;\n    const onSectionChange = handleSectionChange;\n    const onSubjectChange = () => {}; // Empty function since we don't have a subject change handler\n    const fetchData = fetchDashboardData;\n    const fetchSections = updateSectionsForSelectedYear;\n    const fetchSubjects = () => {}; // Placeholder since not implemented\n\n    return {\n      onYearChange,\n      onSectionChange,\n      onSubjectChange,\n      fetchData,\n      fetchSections,\n      fetchSubjects,\n      updatePerformanceChart,\n      updateAssessmentTypeChart,\n      updatePerformanceTrendChart,\n      updateAssessmentTypePerformanceChart,\n      initEmptyCharts,\n      data,\n      selectedYear,\n      selectedSection,\n      selectedSubject: ref(''),\n      // Add a missing ref for this property\n      sections,\n      subjects,\n      availableYears,\n      dashboardContainer,\n      performanceChart,\n      assessmentTypeChart,\n      performanceTrendChart,\n      assessmentTypePerformanceChart,\n      isLoading,\n      lastUpdate,\n      selectedStartDate,\n      selectedEndDate,\n      today,\n      attendanceTimeFilter,\n      assessmentTypeTimeFilter,\n      trendTimeFilter,\n      typePerformanceTimeFilter,\n      chartDataCache,\n      setChartTimeFilter,\n      generateChartData,\n      formatDate,\n      clearFilters,\n      getFilterDisplay,\n      refreshDashboard,\n      scrollToSection\n    };\n  }\n};","map":{"version":3,"names":["ref","onMounted","computed","watch","onUnmounted","nextTick","useStore","Chart","axios","moment","api","create","baseURL","name","setup","store","performanceChart","assessmentTypeChart","performanceTrendChart","assessmentTypePerformanceChart","selectedYear","selectedSection","selectedStartDate","selectedEndDate","dashboardContainer","isLoading","lastUpdate","autoRefreshInterval","sections","subjects","availableYears","today","format","attendanceTimeFilter","assessmentTypeTimeFilter","trendTimeFilter","typePerformanceTimeFilter","chartDataCache","attendance","assessmentType","performanceTrend","assessmentTypePerformance","isCITHead","getters","token","state","auth","userName","user","firstName","lastName","trim","hasActiveFilters","Boolean","value","newToken","defaults","headers","common","immediate","totalStudents","totalTeachers","averageAttendance","averageScore","activeSections","data","attendanceDistribution","assessmentTypes","performanceTrends","hasAttendanceData","validDistribution","Array","isArray","map","val","hasData","some","error","console","hasScoreData","type","count","hasPerformanceData","hasAssessmentData","length","trend","section","hasSectionData","fetchAvailableFilters","response","get","students","years","Set","student","year","filter","sort","updateSectionsForSelectedYear","log","params","uniqueSections","sectionName","id","teacherName","warn","fetchAttendanceData","url","queryParts","push","encodeURIComponent","join","fetch","ok","attendanceData","json","statusCounts","forEach","record","status","message","statsData","Date","lastWeek","fill","_","i","date","setDate","getDate","toISOString","split","allAttendanceRecords","dateAttendance","fetchDashboardData","filterParams","statsUrl","hasValidData","totalAttendance","reduce","a","b","presentAttendance","Math","round","fetchAssessmentData","totalScore","totalCount","updateCharts","startDate","endDate","URLSearchParams","append","queryString","toString","assessments","Error","scores","slice","assessment","assessment_type","scoreArray","Map","from","values","Object","validScores","score","percentage","maxScore","keys","typeData","completionRate","t","assessmentDate","assessment_date","sum","title","sectionPerformance","scoreCount","assessmentCount","attendanceRate","performance","updatePerformanceChart","updateAssessmentTypeChart","updatePerformanceTrendChart","updateAssessmentTypePerformanceChart","initEmptyCharts","charts","canvas","ctx","getContext","existingChart","getChart","destroy","emptyData","formatDate","handleYearChange","handleSectionChange","handleFilterChange","clearFilters","then","getFilterDisplay","filters","formattedStart","formattedEnd","attendanceLabels","totalAttendanceCount","labels","datasets","backgroundColor","borderWidth","hoverOffset","options","responsive","maintainAspectRatio","cutout","plugins","legend","position","usePointStyle","padding","font","size","tooltip","callbacks","label","context","raw","total","chart","display","enabled","assessmentData","counts","colors","item","index","parseFloat","entries","v","borderRadius","maxBarThickness","dataIndex","scales","y","beginAtZero","max","ticks","callback","trends","borderColor","tension","pointRadius","pointBackgroundColor","pointHoverRadius","tooltipItems","toFixed","text","x","maxRotation","minRotation","trendsByType","Quiz","Activity","allDates","flat","color","point","find","d","getTime","replace","spanGaps","interaction","intersect","mode","dataset","refreshDashboard","scrollToSection","sectionId","document","getElementById","scrollIntoView","behavior","interceptors","use","config","Promise","reject","clearInterval","setInterval","visibilityState","start","end","isBefore","setChartTimeFilter","chartType","timeRange","formattedStartDate","formattedEndDate","originalStartDate","originalEndDate","generateChartData","chartData","alert","reportData","post","responseType","blob","Blob","window","URL","createObjectURL","link","createElement","contentType","fileExt","includes","fileName","href","setAttribute","body","appendChild","click","remove","onYearChange","onSectionChange","onSubjectChange","fetchData","fetchSections","fetchSubjects","selectedSubject"],"sources":["D:\\au_dev\\client\\src\\views\\Dashboard.vue"],"sourcesContent":["<template>\n  <div class=\"dashboard\" ref=\"dashboardContainer\">\n    <!-- Greeting Section -->\n    <div class=\"greeting-section mb-4\">\n      <h2 class=\"greeting\">Welcome, Dean {{ userName }}</h2>\n      <p class=\"greeting-subtitle\">Computer and Information Technology Department Dashboard</p>\n    </div>\n    \n    <div class=\"d-flex justify-content-between align-items-center mb-4\">\n      <!-- Combined Filter Dropdown -->\n      <div class=\"dropdown\">\n        <button class=\"btn btn-filter dropdown-toggle\" type=\"button\" id=\"filterDropdown\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">\n          <i class=\"fas fa-filter me-2\"></i>\n          {{ getFilterDisplay() }}\n        </button>\n        <div class=\"dropdown-menu filter-menu p-3\" aria-labelledby=\"filterDropdown\">\n          <h6 class=\"dropdown-header\">Filter Options</h6>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Academic Year</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedYear\" @change=\"handleYearChange\">\n              <option value=\"\">All Years</option>\n              <option v-for=\"year in availableYears\" :key=\"year\" :value=\"year\">{{ year }}</option>\n          </select>\n        </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Section</label>\n            <select class=\"form-select mb-2\" v-model=\"selectedSection\" @change=\"handleSectionChange\" :disabled=\"!selectedYear\">\n              <option value=\"\">All Sections</option>\n              <option v-for=\"section in sections\" :key=\"section.id\" :value=\"section.name\">\n                {{ section.name }}{{ section.teacherName ? ` - ${section.teacherName}` : '' }}\n              </option>\n            </select>\n          </div>\n          <div class=\"mb-3\">\n            <label class=\"form-label\">Date Range</label>\n            <div class=\"d-flex gap-2\">\n              <div class=\"flex-grow-1\">\n                <label class=\"small text-muted\">From</label>\n                <input \n                  type=\"date\" \n                  class=\"form-control form-control-sm\" \n                  v-model=\"selectedStartDate\"\n                  :max=\"today\"\n                >\n              </div>\n              <div class=\"flex-grow-1\">\n                <label class=\"small text-muted\">To</label>\n                <input \n                  type=\"date\" \n                  class=\"form-control form-control-sm\" \n                  v-model=\"selectedEndDate\"\n                  :max=\"today\"\n                >\n              </div>\n            </div>\n          </div>\n          <div class=\"d-flex justify-content-between\">\n            <button class=\"btn btn-outline-secondary\" @click=\"clearFilters\">Clear Filters</button>\n            <button class=\"btn btn-primary\" @click=\"refreshDashboard\">Apply</button>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Last Updated -->\n      <div class=\"last-update-badge\" v-if=\"lastUpdate\">\n        Last updated: {{ formatDate(lastUpdate) }}\n        <button class=\"btn btn-refresh ms-2\" @click=\"refreshDashboard\" title=\"Refresh Dashboard\">\n          <i class=\"fas fa-sync-alt\"></i>\n        </button>\n      </div>\n    </div>\n\n    <!-- Stats Cards -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Total Students Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-user-graduate\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Students</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ totalStudents }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n        </div>\n      </div>\n      </div>\n\n      <!-- Total Teachers Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-chalkboard-teacher\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Total Teachers</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ totalTeachers }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n        </div>\n      </div>\n        </div>\n\n      <!-- Active Sections Card -->\n      <div class=\"col-md-4\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-users\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Active Sections</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading\">{{ activeSections }}</div>\n            <div class=\"stat-value loading\" v-else><i class=\"fas fa-spinner fa-spin\"></i></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Performance Stats -->\n    <div class=\"row g-4 mb-4\">\n      <!-- Average Attendance Card -->\n      <div v-if=\"isCITHead\" class=\"col-md-6\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-clock\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Average Attendance</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading && hasAttendanceData\">{{ averageAttendance }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"isLoading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n        </div>\n      </div>\n      </div>\n      \n      <!-- Average Score Card -->\n      <div class=\"col-md-6\">\n        <div class=\"dashboard-card\">\n          <div class=\"icon-container\">\n          <i class=\"fas fa-chart-line\"></i>\n        </div>\n          <div class=\"card-info\">\n            <h3 class=\"stat-title\">Average Score</h3>\n            <div class=\"stat-value\" v-if=\"!isLoading && hasScoreData\">{{ averageScore }}%</div>\n            <div class=\"stat-value loading\" v-else-if=\"isLoading\"><i class=\"fas fa-spinner fa-spin\"></i></div>\n            <div class=\"no-data\" v-else>No data available</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Charts Row -->\n    <div class=\"row mb-4\">\n      <!-- Attendance Distribution Chart -->\n      <div class=\"col-md-6 mb-4\">\n      <div class=\"chart-card\">\n          <div class=\"card-header\">\n            <div class=\"card-title-container\">\n              <h3 class=\"card-title\">Student Attendance Distribution</h3>\n              <div class=\"date-filter-buttons\">\n                <button \n                  :class=\"['btn-filter-date', attendanceTimeFilter === 'day' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('attendance', 'day')\">Day</button>\n                <button \n                  :class=\"['btn-filter-date', attendanceTimeFilter === 'week' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('attendance', 'week')\">Week</button>\n                <button \n                  :class=\"['btn-filter-date', attendanceTimeFilter === 'month' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('attendance', 'month')\">Month</button>\n              </div>\n            </div>\n            <div class=\"generate-data-container\">\n              <button \n                class=\"btn btn-generate\" \n                @click=\"generateChartData('attendance')\"\n                :disabled=\"!chartDataCache.attendance\">\n                <i class=\"fas fa-download\"></i> Generate\n              </button>\n            </div>\n          </div>\n          <div class=\"card-body\">\n            <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"performanceChart\"></canvas>\n              <p v-if=\"!data?.attendanceDistribution || (data.attendanceDistribution && data.attendanceDistribution.every(value => value === 0) && !isLoading)\" class=\"no-data-message\">No attendance data available</p>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Assessment Type Distribution -->\n      <div class=\"col-md-6 mb-4\">\n      <div class=\"chart-card\">\n          <div class=\"card-header\">\n            <div class=\"card-title-container\">\n              <h3 class=\"card-title\">Assessment Types Distribution</h3>\n              <div class=\"date-filter-buttons\">\n                <button \n                  :class=\"['btn-filter-date', assessmentTypeTimeFilter === 'day' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('assessmentType', 'day')\">Day</button>\n                <button \n                  :class=\"['btn-filter-date', assessmentTypeTimeFilter === 'week' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('assessmentType', 'week')\">Week</button>\n                <button \n                  :class=\"['btn-filter-date', assessmentTypeTimeFilter === 'month' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('assessmentType', 'month')\">Month</button>\n              </div>\n            </div>\n            <div class=\"generate-data-container\">\n              <button \n                class=\"btn btn-generate\" \n                @click=\"generateChartData('assessmentType')\"\n                :disabled=\"!chartDataCache.assessmentType\">\n                <i class=\"fas fa-download\"></i> Generate\n              </button>\n            </div>\n          </div>\n          <div class=\"card-body\">\n            <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"assessmentTypeChart\"></canvas>\n              <p v-if=\"!data?.assessmentTypes || (data.assessmentTypes && Object.keys(data.assessmentTypes).length === 0 && !isLoading)\" class=\"no-data-message\">No assessment data available</p>\n            </div>\n          </div>\n      </div>\n    </div>\n\n      <!-- Performance Trend Chart -->\n      <div class=\"col-md-6 mb-4\">\n        <div class=\"chart-card\">\n          <div class=\"card-header\">\n            <div class=\"card-title-container\">\n              <h3 class=\"card-title\">Performance Trend</h3>\n              <div class=\"date-filter-buttons\">\n                <button \n                  :class=\"['btn-filter-date', trendTimeFilter === 'day' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('trend', 'day')\">Day</button>\n                <button \n                  :class=\"['btn-filter-date', trendTimeFilter === 'week' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('trend', 'week')\">Week</button>\n                <button \n                  :class=\"['btn-filter-date', trendTimeFilter === 'month' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('trend', 'month')\">Month</button>\n              </div>\n            </div>\n            <div class=\"generate-data-container\">\n              <button \n                class=\"btn btn-generate\" \n                @click=\"generateChartData('performanceTrend')\"\n                :disabled=\"!chartDataCache.performanceTrend\">\n                <i class=\"fas fa-download\"></i> Generate\n              </button>\n            </div>\n          </div>\n          <div class=\"card-body\">\n            <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"performanceTrendChart\"></canvas>\n              <p v-if=\"!data?.performanceTrends || (data.performanceTrends && data.performanceTrends.length === 0 && !isLoading)\" class=\"no-data-message\">No performance trend data available</p>\n            </div>\n          </div>\n      </div>\n    </div>\n\n    <!-- Assessment Type Performance -->\n      <div class=\"col-md-6 mb-4\">\n    <div class=\"chart-card\">\n          <div class=\"card-header\">\n            <div class=\"card-title-container\">\n              <h3 class=\"card-title\">Assessment Type Performance</h3>\n              <div class=\"date-filter-buttons\">\n                <button \n                  :class=\"['btn-filter-date', typePerformanceTimeFilter === 'day' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('typePerformance', 'day')\">Day</button>\n                <button \n                  :class=\"['btn-filter-date', typePerformanceTimeFilter === 'week' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('typePerformance', 'week')\">Week</button>\n                <button \n                  :class=\"['btn-filter-date', typePerformanceTimeFilter === 'month' ? 'active' : '']\" \n                  @click=\"setChartTimeFilter('typePerformance', 'month')\">Month</button>\n              </div>\n            </div>\n            <div class=\"generate-data-container\">\n              <button \n                class=\"btn btn-generate\" \n                @click=\"generateChartData('assessmentTypePerformance')\"\n                :disabled=\"!chartDataCache.assessmentTypePerformance\">\n                <i class=\"fas fa-download\"></i> Generate\n              </button>\n            </div>\n          </div>\n          <div class=\"card-body\">\n            <div class=\"chart-container\">\n              <div v-if=\"isLoading\" class=\"loading-overlay\">\n                <i class=\"fas fa-spinner fa-spin\"></i>\n                <p>Loading chart data...</p>\n              </div>\n              <canvas ref=\"assessmentTypePerformanceChart\"></canvas>\n              <p v-if=\"!data?.assessmentTypePerformance || (data.assessmentTypePerformance && Object.keys(data.assessmentTypePerformance).length === 0 && !isLoading)\" class=\"no-data-message\">No assessment type performance data available</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted, computed, watch, onUnmounted, nextTick } from 'vue'\nimport { useStore } from 'vuex'\nimport Chart from 'chart.js/auto'\nimport axios from 'axios'\nimport moment from 'moment'\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: 'http://localhost:8000/api'\n});\n\nexport default {\n  name: 'Dashboard',\n  setup() {\n    const store = useStore()\n    const performanceChart = ref(null)\n    const assessmentTypeChart = ref(null)\n    const performanceTrendChart = ref(null)\n    const assessmentTypePerformanceChart = ref(null)\n    const selectedYear = ref('')\n    const selectedSection = ref('')\n    const selectedStartDate = ref('')\n    const selectedEndDate = ref('')\n    const dashboardContainer = ref(null)\n    const isLoading = ref(false)\n    const lastUpdate = ref(null)\n    const autoRefreshInterval = ref(null)\n    const sections = ref([])\n    const subjects = ref([])\n    const availableYears = ref([])\n    const today = computed(() => moment().format('YYYY-MM-DD'))\n    \n    // Time filter state for each chart\n    const attendanceTimeFilter = ref('month') // Default is month\n    const assessmentTypeTimeFilter = ref('month')\n    const trendTimeFilter = ref('month')\n    const typePerformanceTimeFilter = ref('month')\n    \n    // Chart data cache for report generation\n    const chartDataCache = ref({\n      attendance: null,\n      assessmentType: null,\n      performanceTrend: null,\n      assessmentTypePerformance: null\n    })\n    \n    // Computed properties\n    const isCITHead = computed(() => store.getters.isCITHead)\n    const token = computed(() => store.state.auth.token)\n    \n    // Get user name\n    const userName = computed(() => {\n      const user = store.state.auth.user;\n      return user ? user.name || `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'User' : 'User';\n    });\n    \n    // Check if filters are active\n    const hasActiveFilters = computed(() => {\n      return Boolean(selectedYear.value || selectedSection.value);\n    });\n\n    // Set auth token for all requests\n    watch(token, (newToken) => {\n      if (newToken) {\n        api.defaults.headers.common['Authorization'] = `Bearer ${newToken}`;\n      }\n    }, { immediate: true });\n\n    // Dashboard stats\n    const totalStudents = ref(0)\n    const totalTeachers = ref(0)\n    const averageAttendance = ref(0)\n    const averageScore = ref(0)\n    const activeSections = ref(0)\n    const data = ref({\n      totalStudents: 0,\n      totalTeachers: 0,\n      activeSections: 0,\n      attendanceDistribution: [0, 0, 0],\n      assessmentTypes: [],\n      performanceTrends: [],\n      sections: [],\n      assessmentTypePerformance: {}\n    })\n\n    // Computed properties for data availability\n    const hasAttendanceData = computed(() => {\n      try {\n        if (!data.value || !data.value.attendanceDistribution) return false;\n        \n        // Ensure all values are numbers and valid\n        const validDistribution = Array.isArray(data.value.attendanceDistribution) \n          ? data.value.attendanceDistribution.map(val => (typeof val === 'number') ? val : 0)\n          : [0, 0, 0];\n        \n        // Check if we have any non-zero values\n        const hasData = validDistribution.some(val => val > 0);\n        \n        return hasData;\n      } catch (error) {\n        console.error('Error checking attendance data:', error);\n        return false;\n      }\n    });\n\n    const hasScoreData = computed(() => {\n      if (!data.value) return false;\n      \n      // Check for average score\n      if (data.value.averageScore > 0) return true;\n      \n      // Check assessment types for any with scores\n      if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n        return data.value.assessmentTypes.some(type => (type.averageScore > 0 && type.count > 0));\n      }\n      \n      return false;\n    });\n\n    const hasPerformanceData = computed(() => {\n      if (!data.value) return false;\n      \n      // Check for assessment data\n      if (hasAssessmentData.value) return true;\n      \n      // Check for performance trends\n      if (Array.isArray(data.value.performanceTrends) && data.value.performanceTrends.length > 0) {\n        return data.value.performanceTrends.some(trend => trend.averageScore > 0);\n      }\n      \n      // Check sections data\n      if (Array.isArray(data.value.sections) && data.value.sections.length > 0) {\n        return data.value.sections.some(section => section.averageScore > 0);\n      }\n      \n      return false;\n    });\n\n    const hasAssessmentData = computed(() => {\n      if (!data.value) return false;\n      \n      // Check for assessment types data\n      if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n        return data.value.assessmentTypes.some(type => type.count > 0 && type.averageScore > 0);\n      }\n      \n      return false;\n    });\n\n    const hasSectionData = computed(() => {\n      return data.value?.sections?.length > 0;\n    });\n\n    // Fetch available years and sections directly from database records\n    const fetchAvailableFilters = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Get all student records to extract years and sections\n        const response = await api.get('/students', {\n          headers: { 'Authorization': `Bearer ${token.value}` }\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n          // Extract unique years and sections from student records\n          const students = response.data;\n          \n          // Get unique years with data\n          const years = [...new Set(students.map(student => student.year))].filter(Boolean);\n          availableYears.value = years.length > 0 ? years.sort() : ['1st', '2nd', '3rd', '4th'];\n          \n          // Get unique sections based on selectedYear\n          await updateSectionsForSelectedYear();\n          \n          console.log('Fetched available filters:', {\n            years: availableYears.value,\n            sections: sections.value\n          });\n        }\n        \n        isLoading.value = false;\n      } catch (error) {\n        console.error('Error fetching available filters:', error);\n        // Keep default years if API fails\n        availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        isLoading.value = false;\n      }\n    };\n\n    // New function to update sections based on selected year\n    const updateSectionsForSelectedYear = async () => {\n      try {\n        console.log('Updating sections for year:', selectedYear.value || 'All Years');\n        sections.value = []; // Clear existing sections first\n        \n        const params = {};\n        if (selectedYear.value) {\n          params.year = selectedYear.value;\n        }\n        \n        // Get students filtered by year if selected\n        const response = await api.get('/students', {\n          params,\n          headers: { 'Authorization': `Bearer ${token.value}` }\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n          const students = response.data;\n          \n          // Get unique sections matching the selected year\n          let uniqueSections = [];\n          \n          if (selectedYear.value) {\n            // Filter students by the selected year before extracting sections\n            uniqueSections = [...new Set(\n              students\n                .filter(student => student.year === selectedYear.value)\n                .map(student => student.section)\n            )].filter(Boolean);\n          } else {\n            // If no year selected, get all unique sections\n            uniqueSections = [...new Set(\n              students.map(student => student.section)\n            )].filter(Boolean);\n          }\n          \n          console.log(`Found ${uniqueSections.length} sections for ${selectedYear.value || 'all years'}:`, uniqueSections);\n          \n          // Map sections to include teacher info if available\n          sections.value = uniqueSections.map(sectionName => ({\n            id: sectionName,\n            name: sectionName,\n            teacherName: '' // We could fetch teacher info in the future\n          }));\n        } else {\n          console.warn('No student data received when updating sections');\n          sections.value = [];\n        }\n      } catch (error) {\n        console.error('Error updating sections for year:', error);\n        sections.value = [];\n      }\n    };\n\n    // Fetch attendance data for the charts\n    const fetchAttendanceData = async () => {\n      try {\n        console.log('Fetching attendance with filters:', {\n          year: selectedYear.value || 'All Years',\n          section: selectedSection.value || 'All Sections'\n        });\n        \n        let attendanceDistribution = [0, 0, 0]; // Default empty distribution [present, late, absent]\n        \n        // First approach: Try direct approach with specific filter handling\n        try {\n          console.log('Fetching attendance directly with filters');\n          \n          // Build query params differently for Windows/PowerShell URL handling\n          let url = `${api.defaults.baseURL}/attendance`;\n          let queryParts = [];\n          \n          if (selectedYear.value) {\n            queryParts.push(`year=${encodeURIComponent(selectedYear.value)}`);\n          }\n          \n          if (selectedSection.value) {\n            queryParts.push(`section=${encodeURIComponent(selectedSection.value)}`);\n          }\n          \n          if (selectedStartDate.value) {\n            queryParts.push(`startDate=${encodeURIComponent(selectedStartDate.value)}`);\n          }\n          \n          if (selectedEndDate.value) {\n            queryParts.push(`endDate=${encodeURIComponent(selectedEndDate.value)}`);\n          }\n          \n          // Add query string if we have parameters\n          if (queryParts.length > 0) {\n            url += '?' + queryParts.join('&');\n          }\n          \n          console.log('Fetching attendance from URL:', url);\n          \n          // Make direct fetch request\n          const response = await fetch(url, {\n            headers: {\n              'Authorization': `Bearer ${token.value}`\n            }\n          });\n          \n          if (response.ok) {\n            const attendanceData = await response.json();\n            console.log('Attendance data received:', \n              Array.isArray(attendanceData) ? `${attendanceData.length} records` : 'Non-array data');\n            \n            if (Array.isArray(attendanceData) && attendanceData.length > 0) {\n              // Process attendance records\n              const statusCounts = [0, 0, 0]; // [present, late, absent]\n              \n              attendanceData.forEach(record => {\n                if (record.status === 'present') statusCounts[0]++;\n                else if (record.status === 'late') statusCounts[1]++;\n                else if (record.status === 'absent') statusCounts[2]++;\n              });\n              \n              console.log('Calculated attendance counts:', statusCounts);\n              \n              // Only use this data if we have at least one attendance record\n              if (statusCounts.some(count => count > 0)) {\n                attendanceDistribution = statusCounts;\n                return attendanceDistribution;\n              }\n            }\n          } else {\n            console.warn(`Attendance API returned status: ${response.status}`);\n          }\n        } catch (error) {\n          console.log('Error fetching attendance directly:', error.message);\n        }\n        \n        // Second approach: Try fetching from dashboard stats\n        try {\n          console.log('Trying to get attendance from dashboard stats');\n          \n          // Build URL for stats\n          let url = `${api.defaults.baseURL}/dashboard/stats`;\n          let queryParts = [];\n          \n          if (selectedYear.value) {\n            queryParts.push(`year=${encodeURIComponent(selectedYear.value)}`);\n          }\n          \n          if (selectedSection.value) {\n            queryParts.push(`section=${encodeURIComponent(selectedSection.value)}`);\n          }\n          \n          if (queryParts.length > 0) {\n            url += '?' + queryParts.join('&');\n          }\n          \n          console.log('Fetching dashboard stats from URL:', url);\n          \n          const response = await fetch(url, {\n            headers: {\n              'Authorization': `Bearer ${token.value}`\n            }\n          });\n          \n          if (response.ok) {\n            const statsData = await response.json();\n            \n            if (statsData && Array.isArray(statsData.attendanceDistribution)) {\n              console.log('Attendance distribution from stats:', statsData.attendanceDistribution);\n              \n              // Validate attendance distribution data\n              const validDistribution = statsData.attendanceDistribution.map(val => \n                (typeof val === 'number') ? val : 0\n              );\n              \n              // Only use if we have some valid data\n              if (validDistribution.some(val => val > 0)) {\n                attendanceDistribution = validDistribution;\n                return attendanceDistribution;\n              }\n            }\n          }\n        } catch (error) {\n          console.log('Error fetching from dashboard stats:', error.message);\n        }\n        \n        // Third approach: Try to get attendance by date\n        try {\n          console.log('Trying to get attendance by date for recent days');\n          \n          const today = new Date();\n          const lastWeek = new Array(7).fill(0).map((_, i) => {\n            const date = new Date(today);\n            date.setDate(date.getDate() - i);\n            return date.toISOString().split('T')[0]; // Format as YYYY-MM-DD\n          });\n          \n          let allAttendanceRecords = [];\n          \n          // Get attendance for recent dates\n          for (const date of lastWeek) {\n            try {\n              let url = `${api.defaults.baseURL}/attendance/date/${date}`;\n              if (selectedYear.value) {\n                url += `?year=${encodeURIComponent(selectedYear.value)}`;\n                if (selectedSection.value) {\n                  url += `&section=${encodeURIComponent(selectedSection.value)}`;\n                }\n              }\n              \n              const response = await fetch(url, {\n                headers: {\n                  'Authorization': `Bearer ${token.value}`\n                }\n              });\n              \n              if (response.ok) {\n                const dateAttendance = await response.json();\n                if (Array.isArray(dateAttendance)) {\n                  allAttendanceRecords = [...allAttendanceRecords, ...dateAttendance];\n                }\n              }\n            } catch (error) {\n              // Silently continue to next date\n            }\n          }\n          \n          console.log(`Collected ${allAttendanceRecords.length} attendance records from recent dates`);\n          \n          if (allAttendanceRecords.length > 0) {\n            // Process all attendance records\n            const statusCounts = [0, 0, 0]; // [present, late, absent]\n            \n            allAttendanceRecords.forEach(record => {\n              if (record.status === 'present') statusCounts[0]++;\n              else if (record.status === 'late') statusCounts[1]++;\n              else if (record.status === 'absent') statusCounts[2]++;\n            });\n            \n            console.log('Calculated attendance counts from dates:', statusCounts);\n            \n            if (statusCounts.some(count => count > 0)) {\n              attendanceDistribution = statusCounts;\n              return attendanceDistribution;\n            }\n          }\n        } catch (error) {\n          console.log('Error fetching attendance by date:', error.message);\n        }\n        \n        // Return empty distribution if all approaches failed\n        console.log('All attendance data fetching approaches failed. Using empty distribution.');\n        return attendanceDistribution;\n      } catch (error) {\n        console.error('Error in attendance data fetching:', error);\n        return [0, 0, 0];\n      }\n    };\n\n    const fetchDashboardData = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Prepare query parameters using the URL-friendly format\n        let queryParts = [];\n        if (selectedYear.value) {\n          queryParts.push(`year=${encodeURIComponent(selectedYear.value)}`);\n        }\n        \n        if (selectedSection.value) {\n          queryParts.push(`section=${encodeURIComponent(selectedSection.value)}`);\n        }\n        \n        if (selectedStartDate.value) {\n          queryParts.push(`startDate=${encodeURIComponent(selectedStartDate.value)}`);\n        }\n        \n        if (selectedEndDate.value) {\n          queryParts.push(`endDate=${encodeURIComponent(selectedEndDate.value)}`);\n        }\n        \n        const filterParams = queryParts.length > 0 ? '?' + queryParts.join('&') : '';\n        console.log('Fetching dashboard data with params:', filterParams || 'none');\n        \n        // First, fetch attendance data\n        const attendanceDistribution = await fetchAttendanceData();\n        console.log('Attendance distribution for current filters:', attendanceDistribution);\n        \n        // Get dashboard stats\n        const statsUrl = `${api.defaults.baseURL}/dashboard/stats${filterParams}`;\n        console.log('Fetching dashboard stats from URL:', statsUrl);\n        \n        let statsData = {};\n        try {\n          const response = await fetch(statsUrl, {\n            headers: {\n              'Authorization': `Bearer ${token.value}`\n            }\n          });\n          \n          if (response.ok) {\n            statsData = await response.json();\n            console.log('Dashboard stats response:', statsData);\n          } else {\n            console.warn(`Dashboard stats API returned status: ${response.status}`);\n          }\n        } catch (error) {\n          console.error('Error fetching dashboard stats:', error.message);\n        }\n        \n        // Initialize data value with defaults and merge with stats data\n        data.value = {\n          totalStudents: statsData.totalStudents || 0,\n          totalTeachers: statsData.totalTeachers || 0,\n          activeSections: statsData.activeSections || 0,\n          attendanceDistribution: attendanceDistribution || [0, 0, 0],\n          assessmentTypes: [],\n          performanceTrends: [],\n          sections: []\n        };\n        \n        // Check if we received any meaningful data\n        const hasValidData = \n          (data.value.totalStudents > 0) || \n          (data.value.totalTeachers > 0) || \n          (data.value.activeSections > 0) || \n          (attendanceDistribution && attendanceDistribution.some(val => val > 0));\n        \n        // If no valid data, it means the filter combination doesn't match any records\n        if (!hasValidData && (selectedYear.value || selectedSection.value)) {\n          console.warn('No data found for the selected filters');\n        }\n        \n        // Update basic stats\n        totalStudents.value = data.value.totalStudents;\n        totalTeachers.value = data.value.totalTeachers;\n        activeSections.value = data.value.activeSections;\n        \n        // Calculate average attendance from distribution\n        const totalAttendance = attendanceDistribution.reduce((a, b) => a + b, 0);\n        if (totalAttendance > 0) {\n          // Calculate percentage of present and late (not absent)\n          const presentAttendance = attendanceDistribution[0] + attendanceDistribution[1];\n          averageAttendance.value = Math.round((presentAttendance / totalAttendance) * 100);\n        } else {\n          averageAttendance.value = 0;\n        }\n        \n        // Process assessment data for charts\n        await fetchAssessmentData();\n        \n        // Calculate averageScore from assessment data\n        if (data.value.assessmentTypes && Array.isArray(data.value.assessmentTypes)) {\n          let totalScore = 0;\n          let totalCount = 0;\n          \n          data.value.assessmentTypes.forEach(type => {\n            if (type.averageScore > 0 && type.count > 0) {\n              totalScore += type.averageScore * type.count;\n              totalCount += type.count;\n            }\n          });\n          \n          if (totalCount > 0) {\n            averageScore.value = Math.round(totalScore / totalCount);\n            data.value.averageScore = averageScore.value;\n          } else {\n            averageScore.value = 0;\n            data.value.averageScore = 0;\n          }\n          \n          console.log(`Calculated average score: ${averageScore.value}% from ${totalCount} assessments`);\n        } else {\n          averageScore.value = 0;\n          data.value.averageScore = 0;\n        }\n\n        // Update charts with new data\n        updateCharts(data.value);\n        \n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Failed to fetch dashboard data:', error);\n        \n        // Initialize with empty data if main stats request fails\n        data.value = {\n          totalStudents: 0,\n          totalTeachers: 0,\n          activeSections: 0,\n          attendanceDistribution: [0, 0, 0],\n          averageAttendance: 0,\n          assessmentTypes: [],\n          performanceTrends: [],\n          averageScore: 0,\n          sections: []\n        };\n        \n        totalStudents.value = 0;\n        totalTeachers.value = 0;\n        activeSections.value = 0;\n        averageAttendance.value = 0;\n        averageScore.value = 0;\n        \n        // Update charts with empty data\n        updateCharts(data.value);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    \n    // Fetch assessment data directly with better approach\n    const fetchAssessmentData = async () => {\n      try {\n        console.log('Fetching assessment data for filters:', {\n          year: selectedYear.value || 'All',\n          section: selectedSection.value || 'All',\n          startDate: selectedStartDate.value,\n          endDate: selectedEndDate.value\n        });\n        \n        // Test directly with fetch to avoid axios URL encoding issues on Windows\n        const params = new URLSearchParams();\n        \n        // Add params only if they exist\n        if (selectedYear.value) params.append('year', selectedYear.value);\n        if (selectedSection.value) params.append('section', selectedSection.value);\n        if (selectedStartDate.value) params.append('startDate', selectedStartDate.value);\n        if (selectedEndDate.value) params.append('endDate', selectedEndDate.value);\n        \n        // Build the URL with query string\n        const queryString = params.toString();\n        const url = `${api.defaults.baseURL}/assessments${queryString ? '?' + queryString : ''}`;\n        \n        console.log('Fetching assessments from URL:', url);\n        \n        // Make the direct fetch request\n        const response = await fetch(url, {\n          headers: {\n            'Authorization': `Bearer ${token.value}`\n          }\n        });\n        \n        let assessments = [];\n        \n        if (response.ok) {\n          assessments = await response.json();\n          console.log('Fetched assessments count:', assessments?.length || 0);\n        } else {\n          console.error('Assessments API failed with status:', response.status);\n          throw new Error(`API error: ${response.status}`);\n        }\n        \n        if (Array.isArray(assessments) && assessments.length > 0) {\n          console.log('Successfully fetched assessment data');\n          \n          // Process the assessment data\n          const assessmentTypes = {\n            'Quiz': { count: 0, totalScore: 0, scores: [] },\n            'Activity': { count: 0, totalScore: 0, scores: [] },\n            'Performance Task': { count: 0, totalScore: 0, scores: [] }\n          };\n          \n          // Log sample assessment data to understand structure\n          console.log('Sample assessment data:', assessments.slice(0, 1));\n          \n          // Process each assessment\n          assessments.forEach(assessment => {\n            // Make sure we have a type - default to \"Other\" if none found\n            const type = assessment.type || assessment.assessmentType || assessment.assessment_type || 'Other';\n            \n            // Initialize type if it doesn't exist\n            if (!assessmentTypes[type]) {\n              assessmentTypes[type] = { count: 0, totalScore: 0, scores: [] };\n            }\n            \n            // Increment count for this type\n            assessmentTypes[type].count++;\n            \n            // Process scores if available\n            if (assessment.scores) {\n              // Handle both array and Map formats\n              let scoreArray = [];\n              if (Array.isArray(assessment.scores)) {\n                scoreArray = assessment.scores;\n              } else if (assessment.scores instanceof Map) {\n                scoreArray = Array.from(assessment.scores.values());\n              } else if (typeof assessment.scores === 'object') {\n                // Handle object format\n                scoreArray = Object.values(assessment.scores);\n              }\n              \n              // Filter for valid scores and calculate percentages\n              const validScores = scoreArray.filter(score => typeof score === 'number');\n              validScores.forEach(score => {\n                const percentage = assessment.maxScore ? (score / assessment.maxScore) * 100 : score;\n                assessmentTypes[type].totalScore += percentage;\n                assessmentTypes[type].scores.push(percentage);\n              });\n            }\n          });\n          \n          // Calculate averages and prepare for chart\n          data.value.assessmentTypes = Object.keys(assessmentTypes)\n            .filter(type => assessmentTypes[type].count > 0) // Only include types with data\n            .map(type => {\n              const typeData = assessmentTypes[type];\n              const averageScore = typeData.scores.length > 0 \n                ? typeData.totalScore / typeData.scores.length \n                : 0;\n                \n              return {\n                type,\n                averageScore: Math.round(averageScore),\n                count: typeData.count,\n                completionRate: typeData.count > 0 ? 100 : 0\n              };\n            });\n          \n          console.log(`Assessment types processed:`, \n            data.value.assessmentTypes.map(t => `${t.type}: ${t.count} assessments, avg ${t.averageScore}%`));\n          \n          // Generate performance trends from assessment data\n          data.value.performanceTrends = assessments\n            .filter(a => a.date || a.assessmentDate || a.assessment_date) // Only include assessments with dates\n            .map(assessment => {\n              // Get the date - check various possible field names\n              const date = assessment.date || assessment.assessmentDate || assessment.assessment_date;\n              \n              // Calculate average score for this assessment\n              let averageScore = 0;\n              let scoreArray = [];\n              \n              // Handle different score formats\n              if (assessment.scores) {\n                if (Array.isArray(assessment.scores)) {\n                  scoreArray = assessment.scores;\n                } else if (assessment.scores instanceof Map) {\n                  scoreArray = Array.from(assessment.scores.values());\n                } else if (typeof assessment.scores === 'object') {\n                  scoreArray = Object.values(assessment.scores);\n                }\n                \n                // Calculate average from valid scores\n                const validScores = scoreArray.filter(score => typeof score === 'number');\n                if (validScores.length > 0) {\n                  const totalScore = validScores.reduce((sum, score) => sum + score, 0);\n                  averageScore = assessment.maxScore \n                    ? (totalScore / validScores.length / assessment.maxScore) * 100\n                    : totalScore / validScores.length;\n                }\n              }\n              \n              return {\n                date: date,\n                title: assessment.name || assessment.title || assessment.type || 'Assessment',\n                averageScore: Math.round(averageScore),\n                type: assessment.type || assessment.assessmentType || 'Assessment'\n              };\n            })\n            .filter(trend => trend.date && trend.averageScore > 0) // Only keep trends with dates and scores\n            .sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date\n          \n          console.log(`Performance trends processed: ${data.value.performanceTrends.length} data points with dates and scores`);\n          \n          // Process section data if available\n          // Group assessments by section\n          const sectionPerformance = {};\n          \n          // Only process section performance if we actually have data\n          if (assessments.length > 0) {\n            assessments.forEach(assessment => {\n              const section = assessment.section || assessment.sectionName || '';\n              if (section) {\n                if (!sectionPerformance[section]) {\n                  sectionPerformance[section] = {\n                    totalScore: 0,\n                    scoreCount: 0,\n                    assessmentCount: 0\n                  };\n                }\n                \n                sectionPerformance[section].assessmentCount++;\n                \n                // Process scores\n                let scoreArray = [];\n                if (assessment.scores) {\n                  if (Array.isArray(assessment.scores)) {\n                    scoreArray = assessment.scores;\n                  } else if (assessment.scores instanceof Map) {\n                    scoreArray = Array.from(assessment.scores.values());\n                  } else if (typeof assessment.scores === 'object') {\n                    scoreArray = Object.values(assessment.scores);\n                  }\n                  \n                  // Process valid scores\n                  const validScores = scoreArray.filter(score => typeof score === 'number');\n                  validScores.forEach(score => {\n                    const percentage = assessment.maxScore ? (score / assessment.maxScore) * 100 : score;\n                    sectionPerformance[section].totalScore += percentage;\n                    sectionPerformance[section].scoreCount++;\n                  });\n                }\n              }\n            });\n            \n            // Prepare section data for chart if we have any\n            if (Object.keys(sectionPerformance).length > 0) {\n              data.value.sections = Object.keys(sectionPerformance)\n                .filter(sectionName => sectionPerformance[sectionName].scoreCount > 0) // Only include sections with scores\n                .map(sectionName => {\n                  const section = sectionPerformance[sectionName];\n                  const averageScore = section.scoreCount > 0 \n                    ? section.totalScore / section.scoreCount \n                    : 0;\n                  \n                  return {\n                    name: sectionName,\n                    averageScore: Math.round(averageScore),\n                    attendanceRate: 0, // We don't have this data\n                    performance: Math.round(averageScore), // For backward compatibility\n                    assessmentCount: section.assessmentCount\n                  };\n                });\n              \n              console.log(`Section data processed: ${data.value.sections.length} sections with performance data`);\n            }\n          }\n        } else {\n          console.warn('No assessment data found for the selected filters');\n          // Set default values\n          data.value.assessmentTypes = [\n            { type: 'Quiz', averageScore: 0, count: 0 },\n            { type: 'Activity', averageScore: 0, count: 0 },\n            { type: 'Performance Task', averageScore: 0, count: 0 }\n          ];\n          data.value.performanceTrends = [];\n          data.value.sections = [];\n        }\n      } catch (error) {\n        console.error('Error fetching assessment data:', error);\n        // Set default values\n        data.value.assessmentTypes = [\n          { type: 'Quiz', averageScore: 0, count: 0 },\n          { type: 'Activity', averageScore: 0, count: 0 },\n          { type: 'Performance Task', averageScore: 0, count: 0 }\n        ];\n        data.value.performanceTrends = [];\n        data.value.sections = [];\n      }\n    };\n\n    const updateCharts = (data) => {\n      updatePerformanceChart(data);\n      updateAssessmentTypeChart(data);\n      updatePerformanceTrendChart(data);\n      updateAssessmentTypePerformanceChart(data);\n    };\n\n    // Update initEmptyCharts to properly handle chart destruction\n    const initEmptyCharts = () => {\n      // First destroy any existing charts to prevent \"Canvas is already in use\" errors\n      const charts = [\n        performanceChart.value, \n        assessmentTypeChart.value, \n        performanceTrendChart.value,\n        assessmentTypePerformanceChart.value\n      ];\n      \n      // Destroy all existing charts first\n      charts.forEach(canvas => {\n        if (canvas) {\n          const ctx = canvas.getContext('2d');\n          if (ctx) {\n            const existingChart = Chart.getChart(ctx);\n            if (existingChart) {\n              existingChart.destroy();\n            }\n          }\n        }\n      });\n      \n      // Create empty data structure\n      const emptyData = {\n        totalStudents: 0,\n        totalTeachers: 0,\n        activeSections: 0,\n        averageAttendance: 0,\n        averageScore: 0,\n        attendanceDistribution: [0, 0, 0],\n        assessmentTypes: [\n          { type: 'Quiz', averageScore: 0, count: 0 },\n          { type: 'Activity', averageScore: 0, count: 0 },\n          { type: 'Performance Task', averageScore: 0, count: 0 }\n        ],\n        performanceTrends: [],\n        sections: []\n      };\n      \n      // Update charts with empty data\n      updateCharts(emptyData);\n    };\n\n    // Format date for display\n    const formatDate = (date) => {\n      if (!date) return '';\n      return moment(date).format('MMMM D, YYYY h:mm A');\n    };\n\n    // Handle year change\n    const handleYearChange = async () => {\n      console.log('Year changed to:', selectedYear.value);\n      \n      // Reset the section when year changes\n      selectedSection.value = '';\n      \n      // Update sections based on the new year\n      await updateSectionsForSelectedYear();\n      \n      // Update dashboard data with new filters\n      await fetchDashboardData();\n    };\n\n    // Handle section change\n    const handleSectionChange = async () => {\n      // Update dashboard data with new filters\n      fetchDashboardData();\n    };\n\n    // Handle filter change\n    const handleFilterChange = () => {\n      fetchDashboardData();\n    };\n\n    // Clear all filters\n    const clearFilters = () => {\n      console.log('Clearing all filters');\n      \n      // Reset all filter values\n      selectedYear.value = '';\n      selectedSection.value = '';\n      selectedStartDate.value = '';\n      selectedEndDate.value = '';\n      \n      // Reset sections \n      sections.value = [];\n      \n      // Refresh the dashboard with no filters\n      fetchAvailableFilters().then(() => {\n        console.log('Available filters refreshed, fetching dashboard data');\n        fetchDashboardData();\n      });\n    };\n\n    // Get filter display text\n    const getFilterDisplay = () => {\n      const filters = []\n      if (selectedYear.value) filters.push(selectedYear.value)\n      if (selectedSection.value) filters.push(selectedSection.value)\n      \n      // Add date range to display if selected\n      if (selectedStartDate.value && selectedEndDate.value) {\n        const formattedStart = moment(selectedStartDate.value).format('MMM D')\n        const formattedEnd = moment(selectedEndDate.value).format('MMM D, YYYY')\n        filters.push(`${formattedStart} - ${formattedEnd}`)\n      } else if (selectedStartDate.value) {\n        filters.push(`From ${moment(selectedStartDate.value).format('MMM D, YYYY')}`)\n      } else if (selectedEndDate.value) {\n        filters.push(`Until ${moment(selectedEndDate.value).format('MMM D, YYYY')}`)\n      }\n      \n      return filters.length > 0 ? filters.join(' - ') : 'Filter View'\n    };\n\n    // Update charts with data\n    const updatePerformanceChart = (data) => {\n      if (!performanceChart.value) return;\n      \n      const ctx = performanceChart.value.getContext('2d');\n      if (!ctx) return;\n      \n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      \n      // Attendance status distribution data\n      const attendanceLabels = ['Present', 'Late', 'Absent'];\n      let attendanceData = data.attendanceDistribution || [0, 0, 0];\n      \n      // Log attendance data for debugging\n      console.log('Raw attendance data:', attendanceData);\n      \n      // Ensure each value is a number\n      attendanceData = attendanceData.map(val => (typeof val === 'number') ? val : 0);\n      \n      // Ensure we have at least some data to display\n      const totalAttendanceCount = attendanceData.reduce((a, b) => a + b, 0);\n      \n      // Check if we have valid data to show\n      const hasValidData = totalAttendanceCount > 0;\n      \n      // Log for debugging\n      console.log('Final attendance distribution data:', attendanceData, 'hasValidData:', hasValidData);\n      \n      // Create chart\n      if (hasValidData) {\n        new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: attendanceLabels,\n            datasets: [{\n              data: attendanceData,\n              backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],\n              borderWidth: 0,\n              hoverOffset: 4\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            cutout: '70%',\n            plugins: {\n              legend: {\n                position: 'bottom',\n                labels: {\n                  usePointStyle: true,\n                  padding: 15,\n                  font: {\n                    size: 12\n                  }\n                }\n              },\n              tooltip: {\n                callbacks: {\n                  label: function(context) {\n                    const label = context.label || '';\n                    const value = context.raw || 0;\n                    const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);\n                    const percentage = total > 0 ? Math.round((value / total) * 100) : 0;\n                    return `${label}: ${value} (${percentage}%)`;\n                  }\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart with \"No data available\" message\n        new Chart(ctx, {\n          type: 'doughnut',\n          data: {\n            labels: ['No Data'],\n            datasets: [{\n              data: [1],\n              backgroundColor: ['#e2e8f0'],\n              borderWidth: 0\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            cutout: '70%',\n            plugins: {\n              legend: {\n                display: false\n              },\n              tooltip: {\n                enabled: false\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const updateAssessmentTypeChart = (data) => {\n      if (!assessmentTypeChart.value) return;\n      \n      const ctx = assessmentTypeChart.value.getContext('2d');\n      if (!ctx) return;\n      \n      // Dispose of existing chart if it exists\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n      \n      // Assessment types data\n      const assessmentData = data.assessmentTypes || [];\n      const labels = [];\n      const values = [];\n      const counts = [];\n      const colors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#6366f1'];\n      \n      try {\n        // Extract assessment types data\n        if (Array.isArray(assessmentData) && assessmentData.length > 0) {\n          // If array format\n          assessmentData.forEach((item, index) => {\n            if (item && typeof item === 'object') {\n              // Only include items with a count > 0\n              if (item.count > 0) {\n                labels.push(item.type || `Type ${index + 1}`);\n                values.push(parseFloat(item.averageScore) || 0);\n                counts.push(item.count || 0);\n              }\n            }\n          });\n        } else if (typeof assessmentData === 'object' && assessmentData !== null) {\n          // If object format\n          Object.entries(assessmentData).forEach(([type, data], index) => {\n            if (data.count > 0) {\n              labels.push(type);\n              values.push(parseFloat(data.averageScore) || 0);\n              counts.push(data.count || 0);\n            }\n          });\n        }\n        \n        console.log(`Assessment type chart data: ${labels.length} types with data`);\n        console.log('Assessment types:', labels);\n        console.log('Average scores:', values);\n        console.log('Assessment counts:', counts);\n        \n        // If no data was extracted, use default types\n        if (labels.length === 0) {\n          labels.push('Quiz', 'Activity', 'Performance Task');\n          values.push(0, 0, 0);\n          counts.push(0, 0, 0);\n        }\n      } catch (error) {\n        console.error('Error processing assessment data:', error);\n        // Fallback to default labels and values\n        labels.push('Quiz', 'Activity', 'Performance Task');\n        values.push(0, 0, 0);\n        counts.push(0, 0, 0);\n      }\n      \n      // Check if we have any valid data\n      const hasData = labels.length > 0 && values.some(v => v > 0);\n      \n      // Create chart\n      new Chart(ctx, {\n        type: 'bar',\n        data: {\n          labels: labels,\n          datasets: [{\n            label: 'Average Score (%)',\n            data: values,\n            backgroundColor: colors.slice(0, labels.length),\n            borderWidth: 0,\n            borderRadius: 6,\n            maxBarThickness: 50\n          }]\n        },\n        options: {\n          responsive: true,\n          maintainAspectRatio: false,\n          plugins: {\n            legend: {\n              display: false\n            },\n            tooltip: {\n              callbacks: {\n                label: function(context) {\n                  const type = labels[context.dataIndex];\n                  const count = counts[context.dataIndex];\n                  return `${type}: ${context.raw}% (${count} assessments)`;\n                }\n              }\n            }\n          },\n          scales: {\n            y: {\n              beginAtZero: true,\n              max: 100,\n              ticks: {\n                callback: function(value) {\n                  return value + '%';\n                }\n              }\n            }\n          }\n        }\n      });\n    };\n\n    const updatePerformanceTrendChart = (data) => {\n      if (!performanceTrendChart.value) return;\n      \n      const ctx = performanceTrendChart.value.getContext('2d');\n      if (!ctx) return;\n      \n      // Properly destroy any existing chart\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      let trends = [];\n      if (data.performanceTrends && Array.isArray(data.performanceTrends)) {\n        // Filter out trends that have no valid score or date\n        trends = data.performanceTrends\n          .filter(trend => \n            trend.date && \n            (typeof trend.averageScore === 'number' || typeof trend.score === 'number')\n          )\n          .map(trend => ({\n            date: new Date(trend.date),\n            value: parseFloat(trend.averageScore || trend.score) || 0,\n            name: trend.title || trend.name || 'Assessment'\n          }))\n          .sort((a, b) => a.date - b.date);\n      }\n      \n      console.log(`Performance trend chart data: ${trends.length} valid data points`);\n      \n      // Check if we have any valid data points\n      const hasData = trends.length > 0 && trends.some(t => t.value > 0);\n      \n      if (hasData) {\n        // Create new chart after destroying the old one\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: trends.map(trend => moment(trend.date).format('MMM D, YYYY')),\n            datasets: [{\n              label: 'Average Score',\n              data: trends.map(trend => trend.value),\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2,\n              tension: 0.4,\n              fill: true,\n              pointRadius: 4,\n              pointBackgroundColor: 'rgb(59, 130, 246)',\n              pointHoverRadius: 6\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  title: (tooltipItems) => {\n                    if (!tooltipItems.length || !trends[tooltipItems[0].dataIndex]) return '';\n                    const trend = trends[tooltipItems[0].dataIndex];\n                    return `${moment(trend.date).format('MMM D, YYYY')} - ${trend.name}`;\n                  },\n                  label: (context) => {\n                    return `Score: ${context.raw.toFixed(1)}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart to show the \"No data available\" message\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'Average Score',\n              data: [],\n              borderColor: 'rgb(59, 130, 246)',\n              backgroundColor: 'rgba(59, 130, 246, 0.1)',\n              borderWidth: 2\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                display: true,\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Average Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    const updateAssessmentTypePerformanceChart = (data) => {\n      if (!assessmentTypePerformanceChart.value) return;\n      \n      const ctx = assessmentTypePerformanceChart.value.getContext('2d');\n      if (!ctx) return;\n\n      const existingChart = Chart.getChart(ctx);\n      if (existingChart) existingChart.destroy();\n\n      // Process the performance trends data by assessment type\n      const trendsByType = {\n        Quiz: [],\n        Activity: [],\n        'Performance Task': []\n      };\n\n      // Process performance trends data\n      let hasValidData = false;\n      if (Array.isArray(data.performanceTrends)) {\n        data.performanceTrends.forEach(trend => {\n          // Only process trends with valid scores and dates\n          if (trend.date && (typeof trend.averageScore === 'number' || typeof trend.score === 'number')) {\n            const type = trend.type || trend.title || 'Other';\n            const score = parseFloat(trend.averageScore || trend.score) || 0;\n            \n            // Create the array for this type if it doesn't exist\n            if (!trendsByType[type]) {\n              trendsByType[type] = [];\n            }\n            \n            trendsByType[type].push({\n              date: new Date(trend.date),\n              score: score\n            });\n            \n            if (score > 0) {\n              hasValidData = true;\n            }\n          }\n        });\n      }\n\n      // Sort data points by date for each type\n      Object.keys(trendsByType).forEach(type => {\n        trendsByType[type].sort((a, b) => a.date - b.date);\n      });\n\n      // Get unique dates across all types\n      const allDates = [...new Set(\n        Object.values(trendsByType)\n          .flat()\n          .map(item => item.date)\n      )].sort((a, b) => a - b);\n      \n      // Only proceed if we have valid dates\n      if (allDates.length > 0 && hasValidData) {\n        console.log(`Assessment type performance chart: ${allDates.length} dates with data`);\n        \n        // Create datasets\n        const datasets = Object.entries(trendsByType)\n          .filter(([_, data]) => data.length > 0) // Only include types with data\n          .map(([type, data], index) => {\n            const colors = [\n              'rgb(52, 211, 153)',   // Green for Quiz\n              'rgb(59, 130, 246)',   // Blue for Activity\n              'rgb(251, 191, 36)'    // Yellow for Performance Task\n            ];\n            const color = colors[index % colors.length];\n  \n            return {\n              label: type,\n              data: allDates.map(date => {\n                const point = data.find(d => d.date.getTime() === date.getTime());\n                return point ? point.score : null;\n              }),\n              borderColor: color,\n              backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),\n              fill: true,\n              tension: 0.4,\n              pointRadius: 4,\n              pointHoverRadius: 6,\n              spanGaps: true // This will connect points even if there are null values\n            };\n          });\n  \n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: allDates.map(date => moment(date).format('MMM D, YYYY')),\n            datasets\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            interaction: {\n              intersect: false,\n              mode: 'index'\n            },\n            plugins: {\n              legend: {\n                position: 'top'\n              },\n              tooltip: {\n                callbacks: {\n                  label: (context) => {\n                    const value = context.raw !== null ? context.raw.toFixed(1) : 'N/A';\n                    return `${context.dataset.label}: ${value}%`;\n                  }\n                }\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              },\n              x: {\n                ticks: {\n                  maxRotation: 45,\n                  minRotation: 45\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // Create an empty chart if no valid data\n        console.log('No valid assessment type performance data, showing empty chart');\n        new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: [],\n            datasets: [{\n              label: 'No Data',\n              data: [],\n              borderColor: 'rgb(203, 213, 225)',\n              backgroundColor: 'rgba(203, 213, 225, 0.1)'\n            }]\n          },\n          options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n              legend: {\n                position: 'top'\n              }\n            },\n            scales: {\n              y: {\n                beginAtZero: true,\n                max: 100,\n                title: {\n                  display: true,\n                  text: 'Score (%)'\n                }\n              }\n            }\n          }\n        });\n      }\n    };\n\n    // Update the refreshDashboard function to properly handle chart destruction\n    const refreshDashboard = async () => {\n      try {\n        isLoading.value = true;\n        \n        // Destroy existing charts before fetching new data\n        initEmptyCharts();\n        \n        // Wait a tick to ensure DOM updates\n        await nextTick();\n        \n        // Fetch new data\n        await fetchDashboardData();\n        \n        // Update the last refresh time\n        lastUpdate.value = new Date();\n      } catch (error) {\n        console.error('Error refreshing dashboard:', error);\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    const scrollToSection = (sectionId) => {\n      const section = document.getElementById(sectionId);\n      if (section) {\n        section.scrollIntoView({ behavior: 'smooth' });\n      }\n    };\n\n    // Restore auto-refresh in onMounted function\n    onMounted(async () => {\n      try {\n        // Make sure DOM is rendered before initializing charts\n        await nextTick();\n\n        console.log('Dashboard mounted, initializing');\n        \n        // Initialize with empty data while waiting for API\n        initEmptyCharts();\n        \n        // Set up API interceptor to handle 404 errors gracefully\n        api.interceptors.response.use(\n          response => response,\n          error => {\n            if (error.response && error.response.status === 404) {\n              console.warn(`API endpoint not found: ${error.config.url}`);\n            }\n            return Promise.reject(error);\n          }\n        );\n        \n        // Set auth token for API requests\n        if (store.state.auth.token) {\n          api.defaults.headers.common['Authorization'] = `Bearer ${store.state.auth.token}`;\n        }\n        \n        // Fetch available years and sections with data\n        await fetchAvailableFilters();\n        \n        // Ensure all available years are set properly\n        if (availableYears.value.length === 0) {\n          availableYears.value = ['1st', '2nd', '3rd', '4th'];\n        }\n        \n        // Fetch dashboard data\n        await fetchDashboardData();\n        \n        // Set up auto-refresh\n        if (autoRefreshInterval.value) {\n          clearInterval(autoRefreshInterval.value);\n        }\n        \n        // Refresh every 5 minutes, but only if tab is visible\n        autoRefreshInterval.value = setInterval(() => {\n          if (document.visibilityState === 'visible') {\n            refreshDashboard();\n          }\n        }, 5 * 60 * 1000); // 5 minutes\n      } catch (error) {\n        console.error('Error initializing dashboard:', error);\n        // Make sure we still have empty charts if data loading fails\n        await nextTick();\n        initEmptyCharts();\n      }\n    });\n\n    // Clean up on component unmount\n    onUnmounted(() => {\n      if (autoRefreshInterval.value) {\n        clearInterval(autoRefreshInterval.value);\n      }\n    });\n\n    // Add watch for date changes\n    watch([selectedStartDate, selectedEndDate], () => {\n      if (selectedStartDate.value && selectedEndDate.value) {\n        // Validate date range\n        const start = moment(selectedStartDate.value);\n        const end = moment(selectedEndDate.value);\n        \n        if (end.isBefore(start)) {\n          selectedEndDate.value = selectedStartDate.value;\n        }\n      }\n    });\n\n    // New function to set time filter for a specific chart and refresh its data\n    const setChartTimeFilter = async (chartType, timeRange) => {\n      console.log(`Setting ${chartType} chart time filter to ${timeRange}`);\n      \n      // Update the time filter for the specified chart\n      switch (chartType) {\n        case 'attendance':\n          attendanceTimeFilter.value = timeRange;\n          break;\n        case 'assessmentType':\n          assessmentTypeTimeFilter.value = timeRange;\n          break;\n        case 'trend':\n          trendTimeFilter.value = timeRange;\n          break;\n        case 'typePerformance':\n          typePerformanceTimeFilter.value = timeRange;\n          break;\n      }\n      \n      // Set date range based on the selected time filter\n      const today = new Date();\n      let startDate = new Date();\n      \n      if (timeRange === 'day') {\n        // Just today\n        startDate = today;\n      } else if (timeRange === 'week') {\n        // Last 7 days\n        startDate.setDate(today.getDate() - 7);\n      } else if (timeRange === 'month') {\n        // Last 30 days\n        startDate.setDate(today.getDate() - 30);\n      }\n      \n      // Format dates for API calls\n      const formattedStartDate = moment(startDate).format('YYYY-MM-DD');\n      const formattedEndDate = moment(today).format('YYYY-MM-DD');\n      \n      console.log(`Date range: ${formattedStartDate} to ${formattedEndDate}`);\n      \n      // Store original date filter values\n      const originalStartDate = selectedStartDate.value;\n      const originalEndDate = selectedEndDate.value;\n      \n      // Set new date filter values temporarily for this chart update\n      selectedStartDate.value = formattedStartDate;\n      selectedEndDate.value = formattedEndDate;\n      \n      // Show loading indicator for the specific chart\n      isLoading.value = true;\n      \n      try {\n        // Fetch data based on chart type\n        if (chartType === 'attendance') {\n          const attendanceData = await fetchAttendanceData();\n          data.value.attendanceDistribution = attendanceData;\n          \n          // Update attendance chart\n          updatePerformanceChart(data.value);\n          \n          // Cache data for report generation\n          chartDataCache.value.attendance = {\n            timeRange,\n            data: attendanceData,\n            labels: ['Present', 'Late', 'Absent'],\n            startDate: formattedStartDate,\n            endDate: formattedEndDate\n          };\n        } else if (chartType === 'assessmentType' || chartType === 'trend' || chartType === 'typePerformance') {\n          // Fetch updated assessment data\n          await fetchAssessmentData();\n          \n          // Cache assessment type data\n          if (chartType === 'assessmentType') {\n            chartDataCache.value.assessmentType = {\n              timeRange,\n              data: data.value.assessmentTypes,\n              startDate: formattedStartDate,\n              endDate: formattedEndDate\n            };\n            updateAssessmentTypeChart(data.value);\n          }\n          \n          // Cache performance trend data\n          if (chartType === 'trend') {\n            chartDataCache.value.performanceTrend = {\n              timeRange,\n              data: data.value.performanceTrends,\n              startDate: formattedStartDate,\n              endDate: formattedEndDate\n            };\n            updatePerformanceTrendChart(data.value);\n          }\n          \n          // Cache assessment type performance data\n          if (chartType === 'typePerformance') {\n            chartDataCache.value.assessmentTypePerformance = {\n              timeRange,\n              data: data.value.performanceTrends,\n              startDate: formattedStartDate,\n              endDate: formattedEndDate\n            };\n            updateAssessmentTypePerformanceChart(data.value);\n          }\n        }\n      } catch (error) {\n        console.error(`Error updating ${chartType} chart with ${timeRange} filter:`, error);\n      } finally {\n        // Restore original date filter values\n        selectedStartDate.value = originalStartDate;\n        selectedEndDate.value = originalEndDate;\n        isLoading.value = false;\n      }\n    };\n    \n    // Function to generate and export chart data\n    const generateChartData = async (chartType) => {\n      console.log(`Generating report for ${chartType} chart`);\n      \n      // Get the appropriate time filter for the chart\n      let timeRange = 'month';\n      switch (chartType) {\n        case 'attendance':\n          timeRange = attendanceTimeFilter.value;\n          break;\n        case 'assessmentType':\n          timeRange = assessmentTypeTimeFilter.value;\n          break;\n        case 'performanceTrend':\n          timeRange = trendTimeFilter.value;\n          break;\n        case 'assessmentTypePerformance':\n          timeRange = typePerformanceTimeFilter.value;\n          break;\n      }\n      \n      // Get the chart data from cache\n      const chartData = chartDataCache.value[chartType];\n      \n      if (!chartData) {\n        console.warn(`No cached data available for ${chartType} chart`);\n        alert('No data available to generate report. Please try refreshing the chart first.');\n        return;\n      }\n      \n      try {\n        isLoading.value = true;\n        \n        // Prepare report data\n        const reportData = {\n          chartType,\n          timeRange,\n          startDate: chartData.startDate,\n          endDate: chartData.endDate,\n          data: chartData.data,\n          filters: {\n            year: selectedYear.value || 'All',\n            section: selectedSection.value || 'All'\n          }\n        };\n        \n        // Call backend API to generate report\n        const response = await api.post('/reports/generate', reportData, {\n          responseType: 'blob' // Important for downloading files\n        });\n        \n        // Check if the response is successful\n        if (response.status === 200) {\n          // Create blob URL and trigger download\n          const blob = new Blob([response.data], { type: response.headers['content-type'] });\n          const url = window.URL.createObjectURL(blob);\n          const link = document.createElement('a');\n          \n          // Determine file extension based on content type\n          const contentType = response.headers['content-type'];\n          const fileExt = contentType.includes('excel') ? 'xlsx' : 'pdf';\n          \n          // Generate filename\n          const fileName = `${chartType}_report_${timeRange}_${moment().format('YYYY-MM-DD')}.${fileExt}`;\n          \n          link.href = url;\n          link.setAttribute('download', fileName);\n          document.body.appendChild(link);\n          link.click();\n          link.remove();\n          \n          console.log(`Report successfully generated: ${fileName}`);\n        } else {\n          console.error('Error generating report:', response);\n          alert('Failed to generate report. Please try again.');\n        }\n      } catch (error) {\n        console.error('Error generating report:', error);\n        alert('Failed to generate report. Please try again.');\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    // Function aliases for compatibility\n    const onYearChange = handleYearChange;\n    const onSectionChange = handleSectionChange;\n    const onSubjectChange = () => {}; // Empty function since we don't have a subject change handler\n    const fetchData = fetchDashboardData;\n    const fetchSections = updateSectionsForSelectedYear;\n    const fetchSubjects = () => {}; // Placeholder since not implemented\n\n    return {\n        onYearChange,\n        onSectionChange,\n        onSubjectChange,\n        fetchData,\n        fetchSections,\n        fetchSubjects,\n        updatePerformanceChart,\n        updateAssessmentTypeChart,\n        updatePerformanceTrendChart,\n        updateAssessmentTypePerformanceChart,\n        initEmptyCharts,\n        data,\n        selectedYear,\n        selectedSection,\n        selectedSubject: ref(''), // Add a missing ref for this property\n        sections,\n        subjects,\n        availableYears,\n        dashboardContainer,\n        performanceChart,\n        assessmentTypeChart,\n        performanceTrendChart,\n        assessmentTypePerformanceChart,\n        isLoading,\n        lastUpdate,\n        selectedStartDate,\n        selectedEndDate,\n        today,\n        attendanceTimeFilter,\n        assessmentTypeTimeFilter,\n        trendTimeFilter,\n        typePerformanceTimeFilter,\n        chartDataCache,\n        setChartTimeFilter,\n        generateChartData,\n        formatDate,\n        clearFilters,\n        getFilterDisplay,\n        refreshDashboard,\n        scrollToSection\n      }\n  }\n}\n</script>\n\n<style scoped>\n.dashboard {\n  padding: 2rem;\n  background-color: #f8f9fa;\n  min-height: 100vh;\n}\n\n/* Greeting Section Styles */\n.greeting-section {\n  padding-bottom: 1.5rem;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n}\n\n.greeting {\n  font-size: 2.25rem;\n  font-weight: 700;\n  color: #003366;\n  margin-bottom: 0.5rem;\n  letter-spacing: -0.5px;\n}\n\n.greeting-subtitle {\n  color: #64748b;\n  font-size: 1.125rem;\n  font-weight: 400;\n  margin: 0;\n}\n\n/* Filter and Form Styles */\n.btn-filter {\n  background-color: white;\n  border: 1px solid #e2e8f0;\n  padding: 0.75rem 1.25rem;\n  font-size: 0.9rem;\n  color: #1e293b;\n  min-width: 220px;\n  text-align: left;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s ease;\n}\n\n.btn-filter:hover {\n  background-color: #f8fafc;\n  border-color: #003366;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);\n}\n\n.filter-menu {\n  width: 320px;\n  padding: 1.25rem;\n  border: none;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\n  border-radius: 12px;\n}\n\n.dropdown-header {\n  color: #003366;\n  font-weight: 700;\n  padding: 0;\n  margin-bottom: 1.25rem;\n  font-size: 1rem;\n}\n\n.form-label {\n  font-weight: 600;\n  color: #475569;\n  margin-bottom: 0.5rem;\n  font-size: 0.875rem;\n}\n\n.last-update-badge {\n  font-size: 0.85rem;\n  color: #64748b;\n  display: flex;\n  align-items: center;\n}\n\n.btn-refresh {\n  background: white;\n  border: 1px solid #e2e8f0;\n  color: #4a5568;\n  padding: 0.5rem;\n  border-radius: 8px;\n  width: 36px;\n  height: 36px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s ease;\n}\n\n.btn-refresh:hover {\n  background: #f7fafc;\n  color: #2d3748;\n  border-color: #cbd5e1;\n}\n\n/* Dashboard Cards */\n.dashboard-card {\n  background: #fff;\n  border-radius: 12px;\n  padding: 1.5rem;\n  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);\n  display: flex;\n  align-items: center;\n  gap: 1.25rem;\n  height: 100%;\n  transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n.dashboard-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);\n}\n\n.icon-container {\n  width: 52px;\n  height: 52px;\n  border-radius: 12px;\n  background-color: #003366;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: transform 0.2s ease;\n}\n\n.dashboard-card:hover .icon-container {\n  transform: scale(1.05);\n}\n\n.icon-container i {\n  color: white;\n  font-size: 1.5rem;\n}\n\n.card-info {\n  flex: 1;\n}\n\n.stat-title {\n  font-size: 0.875rem;\n  color: #64748b;\n  margin: 0 0 0.5rem 0;\n  font-weight: 600;\n  letter-spacing: 0.3px;\n}\n\n.stat-value {\n  font-size: 1.75rem;\n  font-weight: 700;\n  color: #1e293b;\n  line-height: 1.2;\n}\n\n.stat-value.loading {\n  color: #94a3b8;\n  font-size: 1.5rem;\n}\n\n.no-data {\n  color: #94a3b8;\n  font-style: italic;\n  font-size: 0.875rem;\n}\n\n/* Chart Cards */\n.chart-card {\n  background-color: #fff;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.card-header {\n  padding: 16px;\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  border-bottom: 1px solid #e5e5e5;\n  background-color: #f8f9fa;\n}\n\n.card-title-container {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n\n.card-title {\n  font-size: 1.1rem;\n  font-weight: 600;\n  color: #333;\n  margin-bottom: 8px;\n}\n\n.card-body {\n  padding: 1.5rem;\n  flex: 1;\n  position: relative;\n}\n\n.chart-description {\n  font-size: 0.85rem;\n  color: #64748b;\n  margin-bottom: 1.25rem;\n  font-style: italic;\n}\n\n.chart-container {\n  position: relative;\n  width: 100%;\n  height: 300px;\n}\n\n.loading-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(255, 255, 255, 0.8);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  z-index: 10;\n}\n\n.loading-overlay i {\n  font-size: 2rem;\n  color: #2563eb;\n  margin-bottom: 1rem;\n}\n\n.no-data-message {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  color: #64748b;\n  font-size: 0.9rem;\n  font-weight: 500;\n}\n\n/* Date filter buttons */\n.date-filter-buttons {\n  display: flex;\n  gap: 8px;\n  margin-bottom: 15px;\n}\n\n.btn-filter-date {\n  font-size: 0.8rem;\n  padding: 6px 12px;\n  border-radius: 6px;\n  background-color: #f1f5f9;\n  border: 1px solid #e2e8f0;\n  color: #64748b;\n  font-weight: 500;\n  transition: all 0.2s ease;\n}\n\n.btn-filter-date:hover {\n  background-color: #e2e8f0;\n  color: #1e293b;\n}\n\n.btn-filter-date.active {\n  background-color: #003366;\n  color: white;\n  border-color: #003366;\n}\n\n/* Generate data button */\n.generate-data-container {\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 10px;\n}\n\n.btn-generate {\n  font-size: 0.85rem;\n  background-color: #003366;\n  color: white;\n  border: none;\n  border-radius: 6px;\n  padding: 8px 15px;\n  font-weight: 500;\n  transition: all 0.2s ease;\n}\n\n.btn-generate:hover {\n  background-color: #00264d;\n  transform: translateY(-1px);\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n  .dashboard {\n    padding: 1rem;\n  }\n\n  .greeting {\n    font-size: 1.75rem;\n  }\n  \n  .filter-menu {\n    width: 100%;\n    max-width: 320px;\n  }\n\n  .btn-filter {\n    min-width: auto;\n    width: 100%;\n  }\n  \n  .chart-container {\n    height: 300px;\n  }\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}